{
  "$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
  "contentVersion": "1.0.0.0",
  "parameters": {
    "factoryName": {
      "type": "string",
      "metadata": "Data Factory name"
    },
    "Metadata Datastore": {
      "type": "string"
    },
    "AzureDataLakeStorage_Source": {
      "type": "string"
    },
    "AzureDataLakeStorage_Sink": {
      "type": "string"
    },
    "ProdDCSForAzureService": {
      "type": "string"
    }
  },
  "variables": {
    "factoryId": "[concat('Microsoft.DataFactory/factories/', parameters('factoryName'))]"
  },
  "resources": [
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_ADLS_to_ADLS_delimited_mask_pl')]",
      "type": "Microsoft.DataFactory/factories/pipelines",
      "apiVersion": "2018-06-01",
      "properties": {
        "activities": [
          {
            "name": "Select Tables That Require Masking",
            "description": "Select tables with a data mapping and assigned algorithms, as well as filters that may be needed for conditional masking.",
            "type": "Lookup",
            "dependsOn": [
              {
                "activity": "For Each Directory To Purge",
                "dependencyConditions": [
                  "Succeeded"
                ]
              }
            ],
            "policy": {
              "timeout": "0.12:00:00",
              "retry": 0,
              "retryIntervalInSeconds": 30,
              "secureOutput": false,
              "secureInput": false
            },
            "userProperties": [],
            "typeProperties": {
              "source": {
                "type": "AzureSqlSource",
                "sqlReaderQuery": {
                  "value": "WITH\ntables_requiring_filters AS\n(\n    SELECT DISTINCT\n        dataset, specified_database, specified_schema, identified_table\n    FROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_RULESET_TABLE')}\n    WHERE ISJSON(assigned_algorithm) = 1\n    AND dataset = '@{variables('DATASET')}'\n    AND specified_database = '@{pipeline().parameters.P_SOURCE_CONTAINER}'\n    AND specified_schema LIKE '@{pipeline().parameters.P_SOURCE_DIRECTORY}%'\n),\ntables_not_requiring_filters AS\n(\n    SELECT DISTINCT\n        dataset, specified_database, specified_schema, identified_table\n    FROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_RULESET_TABLE')}\n    WHERE assigned_algorithm IS NOT NULL\n    AND assigned_algorithm != ''\n    AND dataset = '@{variables('DATASET')}'\n    AND specified_database = '@{pipeline().parameters.P_SOURCE_CONTAINER}'\n    AND specified_schema LIKE '@{pipeline().parameters.P_SOURCE_DIRECTORY}%'\n    EXCEPT\n    SELECT dataset, specified_database, specified_schema, identified_table\n    FROM tables_requiring_filters\n    WHERE dataset = '@{variables('DATASET')}'\n    AND specified_database = '@{pipeline().parameters.P_SOURCE_CONTAINER}'\n    AND specified_schema LIKE '@{pipeline().parameters.P_SOURCE_DIRECTORY}%'\n),\nall_filters AS\n(\n    SELECT DISTINCT\n        JSON_VALUE(kc.value, '$.alias') as filter_alias,\n        replace(JSON_VALUE(kc.value, '$.condition'), '@{variables('CONDITIONAL_MASKING_RESERVED_CHARACTER')}', concat('byName(''', d.identified_column, ''') ')) as filter_value\n    FROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_RULESET_TABLE')} d \n        CROSS APPLY OPENJSON(d.assigned_algorithm) kc\n    WHERE\n        ISJSON(assigned_algorithm,ARRAY) = 1\n        AND\n        identified_table in (\n            SELECT identified_table FROM tables_requiring_filters\n        )\n        AND JSON_VALUE(kc.value,'$.alias') != 'default'\n    UNION\n    SELECT DISTINCT\n        'default' as filter_alias,\n        STRING_AGG(concat('not(', replace(JSON_VALUE(kc.value, '$.condition'), '@{variables('CONDITIONAL_MASKING_RESERVED_CHARACTER')}', concat('byName(''', d.identified_column, ''')')),')'), ' && ') as filter_value\n    FROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_RULESET_TABLE')} d \n        CROSS APPLY OPENJSON(d.assigned_algorithm) kc\n    WHERE\n        ISJSON(assigned_algorithm,ARRAY) = 1\n        AND\n        identified_table in (\n            SELECT identified_table FROM tables_requiring_filters\n        )\n        AND JSON_VALUE(kc.value,'$.alias') != 'default'\n), sources_and_filters AS (\n    SELECT\n        dataset,\n        specified_database,\n        specified_schema,\n        identified_table,\n        filter_alias,\n        filter_value\n    FROM tables_requiring_filters CROSS JOIN all_filters\n    UNION\n    SELECT\n        dataset,\n        specified_database,\n        specified_schema,\n        identified_table,\n        '',\n        ''\n    FROM tables_not_requiring_filters\n)\nSELECT DISTINCT\n\tdm.source_dataset,\n\tdm.source_database,\n\tdm.source_schema,\n    REVERSE(SUBSTRING(REVERSE(dm.source_schema), CHARINDEX('/', REVERSE(dm.source_schema)), LEN(dm.source_schema))) AS source_directory,\n    REVERSE(SUBSTRING(REVERSE(dm.source_schema),0, CHARINDEX('/', REVERSE(dm.source_schema)))) AS source_prefix,\n\tdm.source_table,\n\tdm.sink_dataset,\n\tdm.sink_database,\n\tdm.sink_schema,\n    REVERSE(SUBSTRING(REVERSE(dm.sink_schema), CHARINDEX('/', REVERSE(dm.sink_schema)), LEN(dm.sink_schema))) AS sink_directory,\n    REVERSE(SUBSTRING(REVERSE(dm.source_schema),0, CHARINDEX('/', REVERSE(dm.source_schema)))) AS sink_prefix,\n\tdm.sink_table,\n\trs.filter_alias,\n\trs.filter_value\nFROM\n\tsources_and_filters rs\n\tJOIN @{variables('METADATA_SCHEMA')}.@{variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')} dm\n\tON (\n\t\trs.dataset = dm.source_dataset AND\n\t\trs.specified_database = dm.source_database AND\n\t\trs.specified_schema = dm.source_schema AND\n\t\trs.identified_table = dm.source_table\n\t)\nWHERE\n\tdm.sink_database = '@{pipeline().parameters.P_SINK_CONTAINER}'\n    AND dm.sink_schema LIKE '@{pipeline().parameters.P_SINK_DIRECTORY}%'\n\tAND (dm.mapping_complete IS NULL OR dm.mapping_complete = 0)\n\tAND (ISJSON(dm.masked_status) = 0  OR dm.masked_status IS NULL)\nUNION\nSELECT DISTINCT\n\tdm.source_dataset,\n\tdm.source_database,\n\tdm.source_schema,\n    REVERSE(SUBSTRING(REVERSE(dm.source_schema), CHARINDEX('/', REVERSE(dm.source_schema)), LEN(dm.source_schema))) AS source_directory,\n    REVERSE(SUBSTRING(REVERSE(dm.source_schema),0, CHARINDEX('/', REVERSE(dm.source_schema)))) AS source_prefix,\n\tdm.source_table,\n\tdm.sink_dataset,\n\tdm.sink_database,\n\tdm.sink_schema,\n    REVERSE(SUBSTRING(REVERSE(dm.sink_schema), CHARINDEX('/', REVERSE(dm.sink_schema)), LEN(dm.sink_schema))) AS sink_directory,\n    REVERSE(SUBSTRING(REVERSE(dm.source_schema),0, CHARINDEX('/', REVERSE(dm.source_schema)))) AS sink_prefix,\n\tdm.sink_table,\n\trs.filter_alias,\n\trs.filter_value\nFROM\n\tsources_and_filters rs\n\tJOIN @{variables('METADATA_SCHEMA')}.@{variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')} dm\n\tCROSS APPLY OPENJSON(dm.masked_status) kc\n\tON (\n\t\trs.dataset = dm.source_dataset AND\n\t\trs.specified_database = dm.source_database AND\n\t\trs.specified_schema = dm.source_schema AND\n\t\trs.identified_table = dm.source_table\n\t)\nWHERE\n\tdm.sink_database = '@{pipeline().parameters.P_SINK_CONTAINER}'\n    AND dm.sink_schema LIKE '@{pipeline().parameters.P_SINK_DIRECTORY}%'\n\tAND (dm.mapping_complete IS NULL OR dm.mapping_complete = 0)\n\tAND ISJSON(dm.masked_status) = 1\n\tAND kc.[key] = rs.filter_alias\n    AND kc.[value] = 'false'\n\tAND\t(\n\t\t(filter_alias = 'default' AND  \n\t\t\tidentified_table IN (\n\t\t\t\tSELECT DISTINCT\n\t\t\t\t\tidentified_table\n\t\t\tFROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_RULESET_TABLE')} d\n\t\t\t\tCROSS APPLY OPENJSON(d.assigned_algorithm) kc\n\t\t\tWHERE\n\t\t\t\tISJSON(assigned_algorithm,ARRAY) = 1\n\t\t\t\tAND JSON_VALUE(kc.value, '$.alias') = 'default'\n\t\t\t)\n\t\t)\n\t\tOR\n\t\t(filter_alias != 'default')\n\t)",
                  "type": "Expression"
                },
                "queryTimeout": "02:00:00",
                "partitionOption": "None"
              },
              "dataset": {
                "referenceName": "dcsazure_ADLS_to_ADLS_delimited_metadata_mask_ds",
                "type": "DatasetReference",
                "parameters": {
                  "DS_METADATA_SCHEMA": {
                    "value": "@variables('METADATA_SCHEMA')",
                    "type": "Expression"
                  },
                  "DS_METADATA_TABLE": {
                    "value": "@variables('METADATA_RULESET_TABLE')",
                    "type": "Expression"
                  }
                }
              },
              "firstRowOnly": false
            }
          },
          {
            "name": "For Each Table To Mask",
            "type": "ForEach",
            "dependsOn": [
              {
                "activity": "Configure Masked Status",
                "dependencyConditions": [
                  "Succeeded"
                ]
              }
            ],
            "userProperties": [],
            "typeProperties": {
              "items": {
                "value": "@activity('Select Tables That Require Masking').output.value",
                "type": "Expression"
              },
              "isSequential": false,
              "activities": [
                {
                  "name": "Get Source Metadata Mask",
                  "type": "Lookup",
                  "dependsOn": [],
                  "policy": {
                    "timeout": "0.12:00:00",
                    "retry": 0,
                    "retryIntervalInSeconds": 30,
                    "secureOutput": false,
                    "secureInput": false
                  },
                  "userProperties": [],
                  "typeProperties": {
                    "source": {
                      "type": "AzureSqlSource",
                      "sqlReaderQuery": {
                        "value": "SELECT TOP 1 source_metadata\nFROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_RULESET_TABLE')}\nWHERE dataset = '@{variables('DATASET')}'\nAND specified_database = '@{item().source_database}'\nAND specified_schema = '@{item().source_schema}'\nAND identified_table = '@{item().source_table}'\n",
                        "type": "Expression"
                      },
                      "queryTimeout": "02:00:00",
                      "partitionOption": "None"
                    },
                    "dataset": {
                      "referenceName": "dcsazure_ADLS_to_ADLS_delimited_metadata_mask_ds",
                      "type": "DatasetReference",
                      "parameters": {
                        "DS_METADATA_SCHEMA": {
                          "value": "@variables('METADATA_SCHEMA')",
                          "type": "Expression"
                        },
                        "DS_METADATA_TABLE": {
                          "value": "@variables('METADATA_RULESET_TABLE')",
                          "type": "Expression"
                        }
                      }
                    }
                  }
                },
                {
                  "name": "Check For Conditional Masking",
                  "description": "Identify whether the table needs to be masked with conditional masking",
                  "type": "IfCondition",
                  "dependsOn": [
                    {
                      "activity": "Get Source Metadata Mask",
                      "dependencyConditions": [
                        "Succeeded"
                      ]
                    },
                    {
                      "activity": "Lookup Masking Parameters",
                      "dependencyConditions": [
                        "Succeeded"
                      ]
                    }
                  ],
                  "userProperties": [],
                  "typeProperties": {
                    "expression": {
                      "value": "@greater(length(item().filter_alias),0)",
                      "type": "Expression"
                    },
                    "ifFalseActivities": [
                      {
                        "name": "Perform Masking Per Table No Filter",
                        "description": "Perform masking for the entire table",
                        "type": "ExecuteDataFlow",
                        "dependsOn": [],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "dataflow": {
                            "referenceName": "dcsazure_ADLS_to_ADLS_delimited_unfiltered_mask_df",
                            "type": "DataFlowReference",
                            "parameters": {
                              "runId": {
                                "value": "'@{pipeline().RunId}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_CONTAINER": {
                                "value": "'@{item().source_database}'",
                                "type": "Expression"
                              },
                              "DF_SINK_CONTAINER": {
                                "value": "'@{item().sink_database}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_DIRECTORY": {
                                "value": "'@{item().source_directory}'",
                                "type": "Expression"
                              },
                              "DF_SINK_DIRECTORY": {
                                "value": "'@{item().sink_directory}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_PREFIX": {
                                "value": "'@{item().source_prefix}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_TABLE": {
                                "value": "'@{item().source_table}'",
                                "type": "Expression"
                              },
                              "DF_SINK_TABLE": {
                                "value": "'@{item().sink_table}'",
                                "type": "Expression"
                              },
                              "DF_COLUMN_DELIMITER": {
                                "value": "'@{json(activity('Get Source Metadata Mask').output.firstRow.source_metadata).column_delimiter}'",
                                "type": "Expression"
                              },
                              "DF_QUOTE_CHARACTER": {
                                "value": "'@{json(activity('Get Source Metadata Mask').output.firstRow.source_metadata).quote_character}'",
                                "type": "Expression"
                              },
                              "DF_ESCAPE_CHARACTER": {
                                "value": "'@{json(activity('Get Source Metadata Mask').output.firstRow.source_metadata).escape_character}'",
                                "type": "Expression"
                              },
                              "DF_NULL_VALUE": {
                                "value": "'@{json(activity('Get Source Metadata Mask').output.firstRow.source_metadata).null_value}'",
                                "type": "Expression"
                              },
                              "DF_FIELD_ALGORITHM_ASSIGNMENT": {
                                "value": "'@{activity('Lookup Masking Parameters').output.firstRow.FieldAlgorithmAssignments}'",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_MASK": {
                                "value": "@activity('Lookup Masking Parameters').output.firstRow.ColumnsToMask",
                                "type": "Expression"
                              },
                              "DF_BODY_TYPE_MAPPING": {
                                "value": "@activity('Lookup Masking Parameters').output.firstRow.DataFactoryTypeMapping",
                                "type": "Expression"
                              },
                              "DF_TRIM_LENGTHS": {
                                "value": "@activity('Lookup Masking Parameters').output.firstRow.TrimLengths",
                                "type": "Expression"
                              },
                              "DF_FAIL_ON_NONCONFORMANT_DATA": {
                                "value": "@pipeline().parameters.P_FAIL_ON_NONCONFORMANT_DATA",
                                "type": "Expression"
                              },
                              "DF_TARGET_BATCH_SIZE": {
                                "value": "@variables('TARGET_BATCH_SIZE')",
                                "type": "Expression"
                              },
                              "DF_FIELD_DATE_FORMAT": {
                                "value": "'@{activity('Lookup Masking Parameters').output.firstRow.DateFormatAssignments}'",
                                "type": "Expression"
                              }
                            },
                            "datasetParameters": {
                              "Source": {},
                              "Sink": {}
                            },
                            "linkedServiceParameters": {}
                          },
                          "staging": {},
                          "compute": {
                            "coreCount": 8,
                            "computeType": "General"
                          },
                          "traceLevel": "None",
                          "cacheSinks": {
                            "firstRowOnly": true
                          }
                        }
                      },
                      {
                        "name": "Fail After Updating Masked State No Filter",
                        "type": "Fail",
                        "dependsOn": [
                          {
                            "activity": "Update Masked State No Filter Failed",
                            "dependencyConditions": [
                              "Succeeded"
                            ]
                          }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                          "message": {
                            "value": "@concat('Failed to mask ', item().source_database, ':', item().source_schema, ' with extension ', item().identified_table)",
                            "type": "Expression"
                          },
                          "errorCode": "500"
                        }
                      },
                      {
                        "name": "Update Masked State No Filter",
                        "type": "SqlServerStoredProcedure",
                        "dependsOn": [
                          {
                            "activity": "Perform Masking Per Table No Filter",
                            "dependencyConditions": [
                              "Succeeded"
                            ]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "storedProcedureName": {
                            "value": "@{variables('METADATA_SCHEMA')}.@{variables('METADATA_EVENT_PROCEDURE_NAME')}",
                            "type": "Expression"
                          },
                          "storedProcedureParameters": {
                            "activity_run_id": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table No Filter').ActivityRunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "error_message": {
                              "value": null,
                              "type": "String"
                            },
                            "execution_end_time": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table No Filter').ExecutionEndTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "execution_start_time": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table No Filter').ExecutionStartTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "filter_alias": {
                              "value": null,
                              "type": "String"
                            },
                            "filter_condition": {
                              "value": null,
                              "type": "String"
                            },
                            "input_parameters": {
                              "value": {
                                "value": "{\n    \"DF_FIELD_ALGORITHM_ASSIGNMENT\": \"@{activity('Lookup Masking Parameters').output.firstRow.FieldAlgorithmAssignments}\",\n    \"DF_COLUMNS_TO_MASK\": \"@{activity('Lookup Masking Parameters').output.firstRow.ColumnsToMask}\",\n    \"DF_BODY_TYPE_MAPPING\": \"@{activity('Lookup Masking Parameters').output.firstRow.DataFactoryTypeMapping}\",\n    \"DF_FAIL_ON_NONCONFORMANT_DATA\": \"@{pipeline().parameters.P_FAIL_ON_NONCONFORMANT_DATA}\",\n    \"DF_TRIM_LENGTHS\": \"@{activity('Lookup Masking Parameters').output.firstRow.TrimLengths}\",\n    \"DF_FIELD_DATE_FORMAT\": \"@{activity('Lookup Masking Parameters').output.firstRow.DateFormatAssignments}\"\n}\n",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "is_masking_activity": {
                              "value": "true",
                              "type": "Boolean"
                            },
                            "pipeline_name": {
                              "value": {
                                "value": "@pipeline().Pipeline",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "pipeline_run_id": {
                              "value": {
                                "value": "@pipeline().RunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "pipeline_success": {
                              "value": "true",
                              "type": "Boolean"
                            },
                            "sink_database": {
                              "value": {
                                "value": "@item().sink_database",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "sink_schema": {
                              "value": {
                                "value": "@item().sink_schema",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_table": {
                              "value": {
                                "value": "@item().sink_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_database": {
                              "value": {
                                "value": "@item().source_database",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_metadata": {
                              "value": {
                                "value": "@activity('Get Source Metadata Mask').output.firstRow.source_metadata",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_schema": {
                              "value": {
                                "value": "@item().source_schema",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_table": {
                              "value": {
                                "value": "@item().source_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            }
                          }
                        },
                        "linkedServiceName": {
                          "referenceName": "[parameters('Metadata Datastore')]",
                          "type": "LinkedServiceReference"
                        }
                      },
                      {
                        "name": "Update Masked State No Filter Failed",
                        "type": "SqlServerStoredProcedure",
                        "dependsOn": [
                          {
                            "activity": "Perform Masking Per Table No Filter",
                            "dependencyConditions": [
                              "Failed"
                            ]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "storedProcedureName": {
                            "value": "@{variables('METADATA_SCHEMA')}.@{variables('METADATA_EVENT_PROCEDURE_NAME')}",
                            "type": "Expression"
                          },
                          "storedProcedureParameters": {
                            "activity_run_id": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table No Filter').ActivityRunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "error_message": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table No Filter').Error.message",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "execution_end_time": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table No Filter').ExecutionEndTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "execution_start_time": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table No Filter').ExecutionStartTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "filter_alias": {
                              "value": null,
                              "type": "String"
                            },
                            "filter_condition": {
                              "value": null,
                              "type": "String"
                            },
                            "input_parameters": {
                              "value": {
                                "value": "{\n    \"DF_FIELD_ALGORITHM_ASSIGNMENT\": \"@{activity('Lookup Masking Parameters').output.firstRow.FieldAlgorithmAssignments}\",\n    \"DF_COLUMNS_TO_MASK\": \"@{activity('Lookup Masking Parameters').output.firstRow.ColumnsToMask}\",\n    \"DF_BODY_TYPE_MAPPING\": \"@{activity('Lookup Masking Parameters').output.firstRow.DataFactoryTypeMapping}\",\n    \"DF_FAIL_ON_NONCONFORMANT_DATA\": \"@{pipeline().parameters.P_FAIL_ON_NONCONFORMANT_DATA}\",\n    \"DF_TRIM_LENGTHS\": \"@{activity('Lookup Masking Parameters').output.firstRow.TrimLengths}\",\n    \"DF_FIELD_DATE_FORMAT\": \"@{activity('Lookup Masking Parameters').output.firstRow.DateFormatAssignments}\"\n}\n",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "is_masking_activity": {
                              "value": "true",
                              "type": "Boolean"
                            },
                            "pipeline_name": {
                              "value": {
                                "value": "@pipeline().Pipeline",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "pipeline_run_id": {
                              "value": {
                                "value": "@pipeline().RunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "pipeline_success": {
                              "value": "false",
                              "type": "Boolean"
                            },
                            "sink_database": {
                              "value": {
                                "value": "@item().sink_database",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "sink_schema": {
                              "value": {
                                "value": "@item().sink_schema",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_table": {
                              "value": {
                                "value": "@item().sink_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_database": {
                              "value": {
                                "value": "@item().source_database",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_metadata": {
                              "value": {
                                "value": "@activity('Get Source Metadata Mask').output.firstRow.source_metadata",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_schema": {
                              "value": {
                                "value": "@item().source_schema",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_table": {
                              "value": {
                                "value": "@item().source_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            }
                          }
                        },
                        "linkedServiceName": {
                          "referenceName": "[parameters('Metadata Datastore')]",
                          "type": "LinkedServiceReference"
                        }
                      }
                    ],
                    "ifTrueActivities": [
                      {
                        "name": "Perform Masking Per Table With Filter",
                        "description": "Perform masking for the part of this table that satisfies the specified filter",
                        "type": "ExecuteDataFlow",
                        "dependsOn": [],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "dataflow": {
                            "referenceName": "dcsazure_ADLS_to_ADLS_delimited_filtered_mask_df",
                            "type": "DataFlowReference",
                            "parameters": {
                              "runId": {
                                "value": "'@{pipeline().RunId}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_CONTAINER": {
                                "value": "'@{item().source_database}'",
                                "type": "Expression"
                              },
                              "DF_SINK_CONTAINER": {
                                "value": "'@{item().sink_database}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_DIRECTORY": {
                                "value": "'@{item().source_directory}'",
                                "type": "Expression"
                              },
                              "DF_SINK_DIRECTORY": {
                                "value": "'@{item().sink_directory}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_PREFIX": {
                                "value": "'@{item().source_prefix}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_TABLE": {
                                "value": "'@{item().source_table}'",
                                "type": "Expression"
                              },
                              "DF_SINK_TABLE": {
                                "value": "'@{item().sink_table}'",
                                "type": "Expression"
                              },
                              "DF_COLUMN_DELIMITER": {
                                "value": "'@{json(activity('Get Source Metadata Mask').output.firstRow.source_metadata).column_delimiter}'",
                                "type": "Expression"
                              },
                              "DF_QUOTE_CHARACTER": {
                                "value": "'@{json(activity('Get Source Metadata Mask').output.firstRow.source_metadata).quote_character}'",
                                "type": "Expression"
                              },
                              "DF_ESCAPE_CHARACTER": {
                                "value": "'@{json(activity('Get Source Metadata Mask').output.firstRow.source_metadata).escape_character}'",
                                "type": "Expression"
                              },
                              "DF_NULL_VALUE": {
                                "value": "'@{json(activity('Get Source Metadata Mask').output.firstRow.source_metadata).null_value}'",
                                "type": "Expression"
                              },
                              "DF_FIELD_ALGORITHM_ASSIGNMENT": {
                                "value": "'@{activity('Lookup Masking Parameters').output.firstRow.FieldAlgorithmAssignments\n}'",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_MASK": {
                                "value": "@activity('Lookup Masking Parameters').output.firstRow.ColumnsToMask",
                                "type": "Expression"
                              },
                              "DF_BODY_TYPE_MAPPING": {
                                "value": "@activity('Lookup Masking Parameters').output.firstRow.DataFactoryTypeMapping",
                                "type": "Expression"
                              },
                              "DF_TRIM_LENGTHS": {
                                "value": "@activity('Lookup Masking Parameters').output.firstRow.TrimLengths",
                                "type": "Expression"
                              },
                              "DF_FAIL_ON_NONCONFORMANT_DATA": {
                                "value": "@pipeline().parameters.P_FAIL_ON_NONCONFORMANT_DATA",
                                "type": "Expression"
                              },
                              "DF_TARGET_BATCH_SIZE": {
                                "value": "@variables('TARGET_BATCH_SIZE')",
                                "type": "Expression"
                              },
                              "DF_FIELD_DATE_FORMAT": {
                                "value": "'@{activity('Lookup Masking Parameters').output.firstRow.DateFormatAssignments}'",
                                "type": "Expression"
                              },
                              "DF_FILTER_CONDITION": {
                                "value": "@item().filter_value",
                                "type": "Expression"
                              }
                            },
                            "datasetParameters": {
                              "Source": {},
                              "Sink": {}
                            },
                            "linkedServiceParameters": {}
                          },
                          "staging": {},
                          "compute": {
                            "coreCount": 8,
                            "computeType": "General"
                          },
                          "traceLevel": "Fine"
                        }
                      },
                      {
                        "name": "Update Masked Status With Filter",
                        "type": "SqlServerStoredProcedure",
                        "dependsOn": [
                          {
                            "activity": "Perform Masking Per Table With Filter",
                            "dependencyConditions": [
                              "Succeeded"
                            ]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "storedProcedureName": {
                            "value": "@{variables('METADATA_SCHEMA')}.@{variables('METADATA_EVENT_PROCEDURE_NAME')}",
                            "type": "Expression"
                          },
                          "storedProcedureParameters": {
                            "activity_run_id": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table With Filter').ActivityRunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "error_message": {
                              "value": null,
                              "type": "String"
                            },
                            "execution_end_time": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table With Filter').ExecutionEndTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "execution_start_time": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table With Filter').ExecutionStartTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "filter_alias": {
                              "value": {
                                "value": "@item().filter_alias",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "filter_condition": {
                              "value": {
                                "value": "@item().filter_value",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "input_parameters": {
                              "value": {
                                "value": "{\n    \"DF_FIELD_ALGORITHM_ASSIGNMENT\": \"@{activity('Lookup Masking Parameters').output.firstRow.FieldAlgorithmAssignments}\",\n    \"DF_COLUMNS_TO_MASK\": \"@{activity('Lookup Masking Parameters').output.firstRow.ColumnsToMask}\",\n    \"DF_BODY_TYPE_MAPPING\": \"@{activity('Lookup Masking Parameters').output.firstRow.DataFactoryTypeMapping}\",\n    \"DF_FAIL_ON_NONCONFORMANT_DATA\": \"@{pipeline().parameters.P_FAIL_ON_NONCONFORMANT_DATA}\",\n    \"DF_TRIM_LENGTHS\": \"@{activity('Lookup Masking Parameters').output.firstRow.TrimLengths}\",\n    \"DF_FIELD_DATE_FORMAT\": \"@{activity('Lookup Masking Parameters').output.firstRow.DateFormatAssignments}\"\n}\n",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "is_masking_activity": {
                              "value": "true",
                              "type": "Boolean"
                            },
                            "pipeline_name": {
                              "value": {
                                "value": "@pipeline().Pipeline",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "pipeline_run_id": {
                              "value": {
                                "value": "@pipeline().RunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "pipeline_success": {
                              "value": "true",
                              "type": "Boolean"
                            },
                            "sink_database": {
                              "value": {
                                "value": "@item().sink_database",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "sink_schema": {
                              "value": {
                                "value": "@item().sink_schema",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_table": {
                              "value": {
                                "value": "@item().sink_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_database": {
                              "value": {
                                "value": "@item().source_database",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_metadata": {
                              "value": {
                                "value": "@activity('Get Source Metadata Mask').output.firstRow.source_metadata",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_schema": {
                              "value": {
                                "value": "@item().source_schema",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_table": {
                              "value": {
                                "value": "@item().source_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            }
                          }
                        },
                        "linkedServiceName": {
                          "referenceName": "[parameters('Metadata Datastore')]",
                          "type": "LinkedServiceReference"
                        }
                      },
                      {
                        "name": "Update Masked Status With Filter Failed",
                        "type": "SqlServerStoredProcedure",
                        "dependsOn": [
                          {
                            "activity": "Perform Masking Per Table With Filter",
                            "dependencyConditions": [
                              "Failed"
                            ]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "storedProcedureName": {
                            "value": "@{variables('METADATA_SCHEMA')}.@{variables('METADATA_EVENT_PROCEDURE_NAME')}",
                            "type": "Expression"
                          },
                          "storedProcedureParameters": {
                            "activity_run_id": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table With Filter').ActivityRunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "error_message": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table With Filter').Error.message",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "execution_end_time": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table With Filter').ExecutionEndTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "execution_start_time": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table With Filter').ExecutionStartTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "filter_alias": {
                              "value": {
                                "value": "@item().filter_alias",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "filter_condition": {
                              "value": {
                                "value": "@item().filter_value",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "input_parameters": {
                              "value": {
                                "value": "{\n    \"DF_FIELD_ALGORITHM_ASSIGNMENT\": \"@{activity('Lookup Masking Parameters').output.firstRow.FieldAlgorithmAssignments}\",\n    \"DF_COLUMNS_TO_MASK\": \"@{activity('Lookup Masking Parameters').output.firstRow.ColumnsToMask}\",\n    \"DF_BODY_TYPE_MAPPING\": \"@{activity('Lookup Masking Parameters').output.firstRow.DataFactoryTypeMapping}\",\n    \"DF_FAIL_ON_NONCONFORMANT_DATA\": \"@{pipeline().parameters.P_FAIL_ON_NONCONFORMANT_DATA}\",\n    \"DF_TRIM_LENGTHS\": \"@{activity('Lookup Masking Parameters').output.firstRow.TrimLengths}\",\n    \"DF_FIELD_DATE_FORMAT\": \"@{activity('Lookup Masking Parameters').output.firstRow.DateFormatAssignments}\"\n}\n",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "is_masking_activity": {
                              "value": "true",
                              "type": "Boolean"
                            },
                            "pipeline_name": {
                              "value": {
                                "value": "@pipeline().Pipeline",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "pipeline_run_id": {
                              "value": {
                                "value": "@pipeline().RunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "pipeline_success": {
                              "value": "false",
                              "type": "Boolean"
                            },
                            "sink_database": {
                              "value": {
                                "value": "@item().sink_database",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "sink_schema": {
                              "value": {
                                "value": "@item().sink_schema",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_table": {
                              "value": {
                                "value": "@item().sink_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_database": {
                              "value": {
                                "value": "@item().source_database",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_metadata": {
                              "value": {
                                "value": "@activity('Get Source Metadata Mask').output.firstRow.source_metadata",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_schema": {
                              "value": {
                                "value": "@item().source_schema",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_table": {
                              "value": {
                                "value": "@item().source_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            }
                          }
                        },
                        "linkedServiceName": {
                          "referenceName": "[parameters('Metadata Datastore')]",
                          "type": "LinkedServiceReference"
                        }
                      },
                      {
                        "name": "Fail After Updating Masked With Filter",
                        "type": "Fail",
                        "dependsOn": [
                          {
                            "activity": "Update Masked Status With Filter Failed",
                            "dependencyConditions": [
                              "Succeeded"
                            ]
                          }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                          "message": {
                            "value": "@concat('Failed to mask ', item().source_database, ':', item().source_schema, ' with extension ', item().identified_table)",
                            "type": "Expression"
                          },
                          "errorCode": "500"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "Lookup Masking Parameters",
                  "type": "Lookup",
                  "dependsOn": [],
                  "policy": {
                    "timeout": "0.12:00:00",
                    "retry": 0,
                    "retryIntervalInSeconds": 30,
                    "secureOutput": false,
                    "secureInput": false
                  },
                  "userProperties": [],
                  "typeProperties": {
                    "source": {
                      "type": "AzureSqlSource",
                      "sqlReaderStoredProcedureName": {
                        "value": "@{variables('METADATA_SCHEMA')}.@{variables('METADATA_MASKING_PARAMS_PROCEDURE_NAME')}",
                        "type": "Expression"
                      },
                      "storedProcedureParameters": {
                        "dataset": {
                          "type": "String",
                          "value": {
                            "value": "@variables('DATASET')",
                            "type": "Expression"
                          }
                        },
                        "specified_database": {
                          "type": "String",
                          "value": {
                            "value": "@pipeline().parameters.P_SOURCE_CONTAINER",
                            "type": "Expression"
                          }
                        },
                        "specified_schema": {
                          "type": "String",
                          "value": {
                            "value": "@variables('SPECIFIED_SCHEMA')",
                            "type": "Expression"
                          }
                        },
                        "identified_table": {
                          "type": "String",
                          "value": {
                            "value": "@item().source_table",
                            "type": "Expression"
                          }
                        },
                        "column_width_estimate": {
                          "type": "Int32",
                          "value": {
                            "value": "@variables('TARGET_BATCH_SIZE')",
                            "type": "Expression"
                          }
                        },
                        "filter_alias": {
                          "type": "String",
                          "value": {
                            "value": "@item().filter_alias",
                            "type": "Expression"
                          }
                        }
                      },
                      "queryTimeout": "02:00:00",
                      "partitionOption": "None"
                    },
                    "dataset": {
                      "referenceName": "dcsazure_ADLS_to_ADLS_delimited_metadata_mask_ds",
                      "type": "DatasetReference",
                      "parameters": {
                        "DS_METADATA_SCHEMA": {
                          "value": "@variables('METADATA_SCHEMA')",
                          "type": "Expression"
                        },
                        "DS_METADATA_TABLE": {
                          "value": "@variables('METADATA_RULESET_TABLE')",
                          "type": "Expression"
                        }
                      }
                    }
                  }
                }
              ]
            }
          },
          {
            "name": "Select Tables Without Required Masking",
            "description": "Select tables with a data mapping, and no assigned algorithms.",
            "type": "Lookup",
            "dependsOn": [
              {
                "activity": "For Each Directory To Purge",
                "dependencyConditions": [
                  "Succeeded"
                ]
              }
            ],
            "policy": {
              "timeout": "0.12:00:00",
              "retry": 0,
              "retryIntervalInSeconds": 30,
              "secureOutput": false,
              "secureInput": false
            },
            "userProperties": [],
            "typeProperties": {
              "source": {
                "type": "AzureSqlSource",
                "sqlReaderQuery": {
                  "value": "SELECT DISTINCT\n    source_database,\n    source_schema,\n    REVERSE(SUBSTRING(REVERSE(source_schema), CHARINDEX('/', REVERSE(source_schema)), LEN(source_schema))) AS source_directory,\n    REVERSE(SUBSTRING(REVERSE(source_schema),0, CHARINDEX('/', REVERSE(source_schema)))) AS source_prefix,\n    source_table,\n    sink_database,\n    sink_schema,\n    REVERSE(SUBSTRING(REVERSE(sink_schema), CHARINDEX('/', REVERSE(sink_schema)), LEN(sink_schema))) AS sink_directory,\n    REVERSE(SUBSTRING(REVERSE(source_schema),0, CHARINDEX('/', REVERSE(source_schema)))) AS sink_prefix,\n    sink_table\nFROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_RULESET_TABLE')} rs\nJOIN @{variables('METADATA_SCHEMA')}.@{variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')} am\nON (am.source_database = rs.specified_database AND am.source_schema = rs.specified_schema AND am.source_table = rs.identified_table)\nWHERE\n    rs.dataset = '@{variables('DATASET')}'\n    AND am.source_dataset = '@{variables('DATASET')}'\n    AND am.sink_dataset = '@{variables('DATASET')}'\n    AND am.source_database = '@{pipeline().parameters.P_SOURCE_CONTAINER}'\n    AND am.sink_database = '@{pipeline().parameters.P_SINK_CONTAINER}'\n    AND am.source_schema LIKE '@{pipeline().parameters.P_SOURCE_DIRECTORY}%'\n    AND am.sink_schema LIKE '@{pipeline().parameters.P_SINK_DIRECTORY}%'\nEXCEPT\nSELECT DISTINCT\n    source_database,\n    source_schema,\n    REVERSE(SUBSTRING(REVERSE(source_schema), CHARINDEX('/', REVERSE(source_schema)), LEN(source_schema))) AS source_directory,\n    REVERSE(SUBSTRING(REVERSE(source_schema),0, CHARINDEX('/', REVERSE(source_schema)))) AS source_prefix,\n    source_table,\n    sink_database,\n    sink_schema,\n    REVERSE(SUBSTRING(REVERSE(sink_schema), CHARINDEX('/', REVERSE(sink_schema)), LEN(sink_schema))) AS sink_directory,\n    REVERSE(SUBSTRING(REVERSE(source_schema),0, CHARINDEX('/', REVERSE(source_schema)))) AS sink_prefix,\n    sink_table\nFROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_RULESET_TABLE')} rs\nJOIN @{variables('METADATA_SCHEMA')}.@{variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')} am\nON (am.source_database = rs.specified_database AND am.source_schema = rs.specified_schema AND am.source_table = rs.identified_table)\nWHERE\n    rs.dataset = '@{variables('DATASET')}'\n    AND rs.assigned_algorithm IS NOT NULL\n    AND rs.assigned_algorithm != ''\n    AND am.source_dataset = '@{variables('DATASET')}'\n    AND am.sink_dataset = '@{variables('DATASET')}'\n    AND am.source_database = '@{pipeline().parameters.P_SOURCE_CONTAINER}'\n    AND am.sink_database = '@{pipeline().parameters.P_SINK_CONTAINER}'\n    AND am.source_schema LIKE '@{pipeline().parameters.P_SOURCE_DIRECTORY}%'\n    AND am.sink_schema LIKE '@{pipeline().parameters.P_SINK_DIRECTORY}%';",
                  "type": "Expression"
                },
                "queryTimeout": "02:00:00",
                "partitionOption": "None"
              },
              "dataset": {
                "referenceName": "dcsazure_ADLS_to_ADLS_delimited_metadata_mask_ds",
                "type": "DatasetReference",
                "parameters": {
                  "DS_METADATA_SCHEMA": {
                    "value": "@variables('METADATA_SCHEMA')",
                    "type": "Expression"
                  },
                  "DS_METADATA_TABLE": {
                    "value": "@variables('METADATA_RULESET_TABLE')",
                    "type": "Expression"
                  }
                }
              },
              "firstRowOnly": false
            }
          },
          {
            "name": "Filter If Copy Unmasked Enabled",
            "type": "Filter",
            "dependsOn": [
              {
                "activity": "Select Tables Without Required Masking",
                "dependencyConditions": [
                  "Succeeded"
                ]
              }
            ],
            "userProperties": [],
            "typeProperties": {
              "items": {
                "value": "@activity('Select Tables Without Required Masking').output.value",
                "type": "Expression"
              },
              "condition": {
                "value": "@pipeline().parameters.P_COPY_UNMASKED_TABLES",
                "type": "Expression"
              }
            }
          },
          {
            "name": "For Each Table With No Masking",
            "type": "ForEach",
            "dependsOn": [
              {
                "activity": "Filter If Copy Unmasked Enabled",
                "dependencyConditions": [
                  "Succeeded"
                ]
              }
            ],
            "userProperties": [],
            "typeProperties": {
              "items": {
                "value": "@activity('Filter If Copy Unmasked Enabled').output.value",
                "type": "Expression"
              },
              "activities": [
                {
                  "name": "If Copy Via Dataflow",
                  "description": "Determine if we should copy using a dataflow activity or a copy activity",
                  "type": "IfCondition",
                  "dependsOn": [
                    {
                      "activity": "Get Source Metadata No Masking",
                      "dependencyConditions": [
                        "Succeeded"
                      ]
                    }
                  ],
                  "userProperties": [],
                  "typeProperties": {
                    "expression": {
                      "value": "@pipeline().parameters.P_COPY_USE_DATAFLOW",
                      "type": "Expression"
                    },
                    "ifFalseActivities": [
                      {
                        "name": "Copy Unmasked Data",
                        "type": "Copy",
                        "dependsOn": [],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "source": {
                            "type": "DelimitedTextSource",
                            "storeSettings": {
                              "type": "AzureBlobFSReadSettings",
                              "recursive": true,
                              "wildcardFolderPath": {
                                "value": "@item().source_directory",
                                "type": "Expression"
                              },
                              "wildcardFileName": {
                                "value": "@concat(item().source_prefix, '*', item().source_table)",
                                "type": "Expression"
                              },
                              "enablePartitionDiscovery": false
                            },
                            "formatSettings": {
                              "type": "DelimitedTextReadSettings"
                            }
                          },
                          "sink": {
                            "type": "DelimitedTextSink",
                            "storeSettings": {
                              "type": "AzureBlobFSWriteSettings",
                              "copyBehavior": "PreserveHierarchy"
                            },
                            "formatSettings": {
                              "type": "DelimitedTextWriteSettings",
                              "quoteAllText": true,
                              "fileExtension": ""
                            }
                          },
                          "enableStaging": false,
                          "translator": {
                            "type": "TabularTranslator",
                            "typeConversion": true,
                            "typeConversionSettings": {
                              "allowDataTruncation": true,
                              "treatBooleanAsNumber": false
                            }
                          }
                        },
                        "inputs": [
                          {
                            "referenceName": "dcsazure_ADLS_to_ADLS_delimited_container_and_directory_mask_ds",
                            "type": "DatasetReference",
                            "parameters": {
                              "DS_CONTAINER": {
                                "value": "@item().source_database",
                                "type": "Expression"
                              },
                              "DS_DIRECTORY": {
                                "value": "@item().source_directory",
                                "type": "Expression"
                              }
                            }
                          }
                        ],
                        "outputs": [
                          {
                            "referenceName": "dcsazure_ADLS_to_ADLS_delimited_container_and_directory_mask_ds",
                            "type": "DatasetReference",
                            "parameters": {
                              "DS_CONTAINER": {
                                "value": "@item().sink_database",
                                "type": "Expression"
                              },
                              "DS_DIRECTORY": {
                                "value": "@item().sink_directory",
                                "type": "Expression"
                              }
                            }
                          }
                        ]
                      },
                      {
                        "name": "Fail After Updating Copy State",
                        "type": "Fail",
                        "dependsOn": [
                          {
                            "activity": "Update Copy State Failed",
                            "dependencyConditions": [
                              "Succeeded"
                            ]
                          }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                          "message": {
                            "value": "Failed to copy @{item().source_database}: @{item().source_schema} with extension @{item().identified_table}",
                            "type": "Expression"
                          },
                          "errorCode": "500"
                        }
                      },
                      {
                        "name": "Update Copy State",
                        "type": "SqlServerStoredProcedure",
                        "dependsOn": [
                          {
                            "activity": "Copy Unmasked Data",
                            "dependencyConditions": [
                              "Succeeded"
                            ]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "storedProcedureName": {
                            "value": "@{variables('METADATA_SCHEMA')}.@{variables('METADATA_EVENT_PROCEDURE_NAME')}",
                            "type": "Expression"
                          },
                          "storedProcedureParameters": {
                            "activity_run_id": {
                              "value": {
                                "value": "@activity('Copy Unmasked Data').ActivityRunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "error_message": {
                              "value": null,
                              "type": "String"
                            },
                            "execution_end_time": {
                              "value": {
                                "value": "@activity('Copy Unmasked Data').ExecutionEndTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "execution_start_time": {
                              "value": {
                                "value": "@activity('Copy Unmasked Data').ExecutionStartTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "filter_alias": {
                              "value": null,
                              "type": "String"
                            },
                            "filter_condition": {
                              "value": null,
                              "type": "String"
                            },
                            "input_parameters": {
                              "value": {
                                "value": "{\n    \"P_USE_COPY_DATAFLOW\": @{pipeline().parameters.P_COPY_USE_DATAFLOW}\n}",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "is_masking_activity": {
                              "value": "false",
                              "type": "Boolean"
                            },
                            "pipeline_name": {
                              "value": {
                                "value": "@pipeline().Pipeline",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "pipeline_run_id": {
                              "value": {
                                "value": "@pipeline().RunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "pipeline_success": {
                              "value": "true",
                              "type": "Boolean"
                            },
                            "sink_database": {
                              "value": {
                                "value": "@item().sink_database",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "sink_schema": {
                              "value": {
                                "value": "@item().sink_schema",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_table": {
                              "value": {
                                "value": "@item().sink_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_database": {
                              "value": {
                                "value": "@item().source_database",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_metadata": {
                              "value": {
                                "value": "@activity('Get Source Metadata No Masking').output.firstRow.source_metadata",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_schema": {
                              "value": {
                                "value": "@item().source_schema",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_table": {
                              "value": {
                                "value": "@item().source_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            }
                          }
                        },
                        "linkedServiceName": {
                          "referenceName": "[parameters('Metadata Datastore')]",
                          "type": "LinkedServiceReference"
                        }
                      },
                      {
                        "name": "Update Copy State Failed",
                        "type": "SqlServerStoredProcedure",
                        "dependsOn": [
                          {
                            "activity": "Copy Unmasked Data",
                            "dependencyConditions": [
                              "Failed"
                            ]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "storedProcedureName": {
                            "value": "@{variables('METADATA_SCHEMA')}.@{variables('METADATA_EVENT_PROCEDURE_NAME')}",
                            "type": "Expression"
                          },
                          "storedProcedureParameters": {
                            "activity_run_id": {
                              "value": {
                                "value": "@activity('Copy Unmasked Data').ActivityRunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "error_message": {
                              "value": {
                                "value": "@activity('Copy Unmasked Data').Error.message",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "execution_end_time": {
                              "value": {
                                "value": "@activity('Copy Unmasked Data').ExecutionEndTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "execution_start_time": {
                              "value": {
                                "value": "@activity('Copy Unmasked Data').ExecutionStartTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "filter_alias": {
                              "value": null,
                              "type": "String"
                            },
                            "filter_condition": {
                              "value": null,
                              "type": "String"
                            },
                            "input_parameters": {
                              "value": {
                                "value": "{\n    \"P_USE_COPY_DATAFLOW\": @{pipeline().parameters.P_COPY_USE_DATAFLOW}\n}",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "is_masking_activity": {
                              "value": "false",
                              "type": "Boolean"
                            },
                            "pipeline_name": {
                              "value": {
                                "value": "@pipeline().Pipeline",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "pipeline_run_id": {
                              "value": {
                                "value": "@pipeline().RunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "pipeline_success": {
                              "value": "false",
                              "type": "Boolean"
                            },
                            "sink_database": {
                              "value": {
                                "value": "@item().sink_database",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "sink_schema": {
                              "value": {
                                "value": "@item().sink_schema",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_table": {
                              "value": {
                                "value": "@item().sink_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_database": {
                              "value": {
                                "value": "@item().source_database",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_metadata": {
                              "value": {
                                "value": "@activity('Get Source Metadata No Masking').output.firstRow.source_metadata",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_schema": {
                              "value": {
                                "value": "@item().source_schema",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_table": {
                              "value": {
                                "value": "@item().source_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            }
                          }
                        },
                        "linkedServiceName": {
                          "referenceName": "[parameters('Metadata Datastore')]",
                          "type": "LinkedServiceReference"
                        }
                      }
                    ],
                    "ifTrueActivities": [
                      {
                        "name": "Call Copy Dataflow",
                        "type": "ExecuteDataFlow",
                        "dependsOn": [],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "dataflow": {
                            "referenceName": "dcsazure_ADLS_to_ADLS_delimited_copy_df",
                            "type": "DataFlowReference",
                            "parameters": {
                              "runId": {
                                "value": "'@{pipeline().RunId}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_CONTAINER": {
                                "value": "'@{item().source_database}'",
                                "type": "Expression"
                              },
                              "DF_SINK_CONTAINER": {
                                "value": "'@{item().sink_database}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_DIRECTORY": {
                                "value": "'@{item().source_directory}'",
                                "type": "Expression"
                              },
                              "DF_SINK_DIRECTORY": {
                                "value": "'@{item().sink_directory}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_PREFIX": {
                                "value": "'@{item().source_prefix}'",
                                "type": "Expression"
                              },
                              "DF_COLUMN_DELIMITER": {
                                "value": "'@{json(activity('Get Source Metadata No Masking').output.firstRow.source_metadata).column_delimiter}'",
                                "type": "Expression"
                              },
                              "DF_QUOTE_CHARACTER": {
                                "value": "'@{json(activity('Get Source Metadata No Masking').output.firstRow.source_metadata).quote_character}'",
                                "type": "Expression"
                              },
                              "DF_ESCAPE_CHARACTER": {
                                "value": "'@{json(activity('Get Source Metadata No Masking').output.firstRow.source_metadata).escape_character}'",
                                "type": "Expression"
                              },
                              "DF_NULL_VALUE": {
                                "value": "'@{json(activity('Get Source Metadata No Masking').output.firstRow.source_metadata).null_value}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_SUFFIX": {
                                "value": "'@{item().source_table}'",
                                "type": "Expression"
                              }
                            },
                            "datasetParameters": {
                              "Source": {},
                              "Sink": {}
                            }
                          },
                          "staging": {},
                          "compute": {
                            "coreCount": 8,
                            "computeType": "General"
                          },
                          "traceLevel": "Fine"
                        }
                      },
                      {
                        "name": "Dataflow Update Copy State",
                        "type": "SqlServerStoredProcedure",
                        "dependsOn": [
                          {
                            "activity": "Call Copy Dataflow",
                            "dependencyConditions": [
                              "Succeeded"
                            ]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "storedProcedureName": {
                            "value": "@{variables('METADATA_SCHEMA')}.@{variables('METADATA_EVENT_PROCEDURE_NAME')}",
                            "type": "Expression"
                          },
                          "storedProcedureParameters": {
                            "activity_run_id": {
                              "value": {
                                "value": "@activity('Call Copy Dataflow').ActivityRunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "error_message": {
                              "value": null,
                              "type": "String"
                            },
                            "execution_end_time": {
                              "value": {
                                "value": "@activity('Call Copy Dataflow').ExecutionEndTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "execution_start_time": {
                              "value": {
                                "value": "@activity('Call Copy Dataflow').ExecutionStartTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "filter_alias": {
                              "value": null,
                              "type": "String"
                            },
                            "filter_condition": {
                              "value": null,
                              "type": "String"
                            },
                            "input_parameters": {
                              "value": {
                                "value": "{\n    \"P_USE_COPY_DATAFLOW\": @{pipeline().parameters.P_COPY_USE_DATAFLOW}\n}",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "is_masking_activity": {
                              "value": "false",
                              "type": "Boolean"
                            },
                            "pipeline_name": {
                              "value": {
                                "value": "@pipeline().Pipeline",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "pipeline_run_id": {
                              "value": {
                                "value": "@pipeline().RunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "pipeline_success": {
                              "value": "true",
                              "type": "Boolean"
                            },
                            "sink_database": {
                              "value": {
                                "value": "@item().sink_database",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "sink_schema": {
                              "value": {
                                "value": "@item().sink_schema",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_table": {
                              "value": {
                                "value": "@item().sink_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_database": {
                              "value": {
                                "value": "@item().source_database",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_metadata": {
                              "value": {
                                "value": "@activity('Get Source Metadata No Masking').output.firstRow.source_metadata",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_schema": {
                              "value": {
                                "value": "@item().source_schema",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_table": {
                              "value": {
                                "value": "@item().source_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            }
                          }
                        },
                        "linkedServiceName": {
                          "referenceName": "[parameters('Metadata Datastore')]",
                          "type": "LinkedServiceReference"
                        }
                      },
                      {
                        "name": "Dataflow Update Copy State Failed",
                        "type": "SqlServerStoredProcedure",
                        "dependsOn": [
                          {
                            "activity": "Call Copy Dataflow",
                            "dependencyConditions": [
                              "Failed"
                            ]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "storedProcedureName": {
                            "value": "@{variables('METADATA_SCHEMA')}.@{variables('METADATA_EVENT_PROCEDURE_NAME')}",
                            "type": "Expression"
                          },
                          "storedProcedureParameters": {
                            "activity_run_id": {
                              "value": {
                                "value": "@activity('Call Copy Dataflow').ActivityRunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "error_message": {
                              "value": {
                                "value": "@activity('Call Copy Dataflow').Error.message",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "execution_end_time": {
                              "value": {
                                "value": "@activity('Call Copy Dataflow').ExecutionEndTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "execution_start_time": {
                              "value": {
                                "value": "@activity('Call Copy Dataflow').ExecutionStartTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "filter_alias": {
                              "value": null,
                              "type": "String"
                            },
                            "filter_condition": {
                              "value": null,
                              "type": "String"
                            },
                            "input_parameters": {
                              "value": {
                                "value": "{\n    \"P_USE_COPY_DATAFLOW\": @{pipeline().parameters.P_COPY_USE_DATAFLOW}\n}",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "is_masking_activity": {
                              "value": "false",
                              "type": "Boolean"
                            },
                            "pipeline_name": {
                              "value": {
                                "value": "@pipeline().Pipeline",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "pipeline_run_id": {
                              "value": {
                                "value": "@pipeline().RunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "pipeline_success": {
                              "value": "false",
                              "type": "Boolean"
                            },
                            "sink_database": {
                              "value": {
                                "value": "@item().sink_database",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "sink_schema": {
                              "value": {
                                "value": "@item().sink_schema",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_table": {
                              "value": {
                                "value": "@item().sink_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_database": {
                              "value": {
                                "value": "@item().source_database",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_metadata": {
                              "value": {
                                "value": "@activity('Get Source Metadata No Masking').output.firstRow.source_metadata",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_schema": {
                              "value": {
                                "value": "@item().source_schema",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_table": {
                              "value": {
                                "value": "@item().source_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            }
                          }
                        },
                        "linkedServiceName": {
                          "referenceName": "[parameters('Metadata Datastore')]",
                          "type": "LinkedServiceReference"
                        }
                      },
                      {
                        "name": "Dataflow Fail After Updating Copy State",
                        "type": "Fail",
                        "dependsOn": [
                          {
                            "activity": "Dataflow Update Copy State Failed",
                            "dependencyConditions": [
                              "Succeeded"
                            ]
                          }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                          "message": {
                            "value": "Failed to copy @{item().source_database}: @{item().source_schema} with extension @{item().identified_table}",
                            "type": "Expression"
                          },
                          "errorCode": "500"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "Get Source Metadata No Masking",
                  "type": "Lookup",
                  "dependsOn": [],
                  "policy": {
                    "timeout": "0.12:00:00",
                    "retry": 0,
                    "retryIntervalInSeconds": 30,
                    "secureOutput": false,
                    "secureInput": false
                  },
                  "userProperties": [],
                  "typeProperties": {
                    "source": {
                      "type": "AzureSqlSource",
                      "sqlReaderQuery": {
                        "value": "SELECT TOP 1 source_metadata\nFROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_RULESET_TABLE')}\nWHERE dataset = '@{variables('DATASET')}'\nAND specified_database = '@{item().source_database}'\nAND specified_schema = '@{item().source_schema}'\nAND identified_table = '@{item().source_table}'",
                        "type": "Expression"
                      },
                      "queryTimeout": "02:00:00",
                      "partitionOption": "None"
                    },
                    "dataset": {
                      "referenceName": "dcsazure_ADLS_to_ADLS_delimited_metadata_mask_ds",
                      "type": "DatasetReference",
                      "parameters": {
                        "DS_METADATA_SCHEMA": {
                          "value": "@variables('METADATA_SCHEMA')",
                          "type": "Expression"
                        },
                        "DS_METADATA_TABLE": {
                          "value": "@variables('METADATA_RULESET_TABLE')",
                          "type": "Expression"
                        }
                      }
                    }
                  }
                }
              ]
            }
          },
          {
            "name": "Test Filter Condition",
            "description": "Use data preview on Lookup \"Select Tables That Require Masking\" activity to confirm what filter conditions are to be applied. Leverage data preview on this data flow to confirm your filter is working as expected.",
            "type": "ExecuteDataFlow",
            "state": "Inactive",
            "onInactiveMarkAs": "Succeeded",
            "dependsOn": [],
            "policy": {
              "timeout": "0.12:00:00",
              "retry": 0,
              "retryIntervalInSeconds": 30,
              "secureOutput": false,
              "secureInput": false
            },
            "userProperties": [],
            "typeProperties": {
              "dataflow": {
                "referenceName": "dcsazure_ADLS_to_ADLS_delimited_filter_test_utility_df",
                "type": "DataFlowReference",
                "parameters": {
                  "runId": "''",
                  "DF_SOURCE_CONTAINER": "''",
                  "DF_SINK_CONTAINER": "''",
                  "DF_SOURCE_DIRECTORY": "''",
                  "DF_SINK_DIRECTORY": "''",
                  "DF_SOURCE_PREFIX": "''",
                  "DF_COLUMN_DELIMITER": "','",
                  "DF_QUOTE_CHARACTER": "'\"'",
                  "DF_ESCAPE_CHARACTER": "'\\\\'",
                  "DF_NULL_VALUE": "''",
                  "DF_SOURCE_SUFFIX": "''",
                  "DF_FILTER_CONDITION": "true()"
                },
                "datasetParameters": {
                  "Source": {},
                  "Sink": {}
                }
              },
              "staging": {},
              "compute": {
                "coreCount": 8,
                "computeType": "General"
              },
              "traceLevel": "Fine"
            }
          },
          {
            "name": "Check If We Should Reapply Mapping",
            "type": "IfCondition",
            "dependsOn": [],
            "userProperties": [],
            "typeProperties": {
              "expression": {
                "value": "@pipeline().parameters.P_REAPPLY_MAPPING",
                "type": "Expression"
              },
              "ifTrueActivities": [
                {
                  "name": "Mark Table Mapping Incomplete",
                  "description": "Mark all tables in this database and schema as unmapped so that we can re-apply the mapping to them",
                  "type": "Script",
                  "dependsOn": [],
                  "policy": {
                    "timeout": "0.12:00:00",
                    "retry": 0,
                    "retryIntervalInSeconds": 30,
                    "secureOutput": false,
                    "secureInput": false
                  },
                  "userProperties": [],
                  "linkedServiceName": {
                    "referenceName": "[parameters('Metadata Datastore')]",
                    "type": "LinkedServiceReference"
                  },
                  "typeProperties": {
                    "scripts": [
                      {
                        "type": "Query",
                        "text": {
                          "value": "UPDATE\n    @{variables('METADATA_SCHEMA')}.@{variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')}\nSET\n    mapping_complete = CAST(0 AS BIT),\n    masked_status = NULL\nWHERE\n    source_dataset = '@{variables('DATASET')}'\n    AND source_database = '@{pipeline().parameters.P_SOURCE_CONTAINER}'\n    AND source_schema LIKE '@{pipeline().parameters.P_SOURCE_DIRECTORY}%'\n    AND sink_dataset = '@{variables('DATASET')}'\n    AND sink_database = '@{pipeline().parameters.P_SINK_CONTAINER}'\n    AND sink_schema LIKE '@{pipeline().parameters.P_SINK_DIRECTORY}%'",
                          "type": "Expression"
                        }
                      }
                    ],
                    "scriptBlockExecutionTimeout": "02:00:00"
                  }
                }
              ]
            }
          },
          {
            "name": "Select Directories We Should Purge",
            "type": "Lookup",
            "dependsOn": [
              {
                "activity": "Check If We Should Reapply Mapping",
                "dependencyConditions": [
                  "Succeeded"
                ]
              }
            ],
            "policy": {
              "timeout": "0.12:00:00",
              "retry": 0,
              "retryIntervalInSeconds": 30,
              "secureOutput": false,
              "secureInput": false
            },
            "userProperties": [],
            "typeProperties": {
              "source": {
                "type": "AzureSqlSource",
                "sqlReaderQuery": {
                  "value": "SELECT DISTINCT\n    dm.sink_dataset,\n    dm.sink_database,\n    dm.sink_schema,\n    REVERSE(SUBSTRING(REVERSE(dm.sink_schema), CHARINDEX('/', REVERSE(dm.sink_schema)), LEN(dm.sink_schema))) AS sink_directory\nFROM\n    @{variables('METADATA_SCHEMA')}.@{variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')} dm\nWHERE\n    dm.source_dataset = '@{variables('DATASET')}'\n    AND dm.source_database = '@{pipeline().parameters.P_SOURCE_CONTAINER}'\n    AND dm.source_schema LIKE '@{pipeline().parameters.P_SOURCE_DIRECTORY}%'\n    AND dm.sink_dataset = '@{variables('DATASET')}'\n    AND dm.sink_database = '@{pipeline().parameters.P_SINK_CONTAINER}'\n    AND dm.sink_schema LIKE '@{pipeline().parameters.P_SINK_DIRECTORY}%'\n    AND (dm.mapping_complete IS NULL OR dm.mapping_complete = 0)\n    AND LOWER('@{pipeline().parameters.P_TRUNCATE_SINK_BEFORE_WRITE}') = 'true'",
                  "type": "Expression"
                },
                "queryTimeout": "02:00:00",
                "partitionOption": "None"
              },
              "dataset": {
                "referenceName": "dcsazure_ADLS_to_ADLS_delimited_metadata_mask_ds",
                "type": "DatasetReference",
                "parameters": {
                  "DS_METADATA_SCHEMA": {
                    "value": "@variables('METADATA_SCHEMA')",
                    "type": "Expression"
                  },
                  "DS_METADATA_TABLE": {
                    "value": "@variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')",
                    "type": "Expression"
                  }
                }
              },
              "firstRowOnly": false
            }
          },
          {
            "name": "For Each Directory To Purge",
            "type": "ForEach",
            "dependsOn": [
              {
                "activity": "Select Directories We Should Purge",
                "dependencyConditions": [
                  "Succeeded"
                ]
              }
            ],
            "userProperties": [],
            "typeProperties": {
              "items": {
                "value": "@activity('Select Directories We Should Purge').output.value",
                "type": "Expression"
              },
              "activities": [
                {
                  "name": "Check For Files",
                  "type": "GetMetadata",
                  "dependsOn": [],
                  "policy": {
                    "timeout": "0.12:00:00",
                    "retry": 0,
                    "retryIntervalInSeconds": 30,
                    "secureOutput": false,
                    "secureInput": false
                  },
                  "userProperties": [],
                  "typeProperties": {
                    "dataset": {
                      "referenceName": "dcsazure_ADLS_to_ADLS_delimited_container_and_directory_mask_ds",
                      "type": "DatasetReference",
                      "parameters": {
                        "DS_CONTAINER": {
                          "value": "@item().sink_database",
                          "type": "Expression"
                        },
                        "DS_DIRECTORY": {
                          "value": "@item().sink_directory",
                          "type": "Expression"
                        }
                      }
                    },
                    "fieldList": [
                      "exists"
                    ],
                    "storeSettings": {
                      "type": "AzureBlobFSReadSettings",
                      "recursive": true,
                      "enablePartitionDiscovery": false
                    },
                    "formatSettings": {
                      "type": "DelimitedTextReadSettings"
                    }
                  }
                },
                {
                  "name": "If Sink Directory Exists",
                  "type": "IfCondition",
                  "dependsOn": [
                    {
                      "activity": "Check For Files",
                      "dependencyConditions": [
                        "Succeeded"
                      ]
                    }
                  ],
                  "userProperties": [],
                  "typeProperties": {
                    "expression": {
                      "value": "@activity('Check For Files').output.exists",
                      "type": "Expression"
                    },
                    "ifTrueActivities": [
                      {
                        "name": "Purge Sink Directory",
                        "type": "Delete",
                        "dependsOn": [],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "dataset": {
                            "referenceName": "dcsazure_ADLS_to_ADLS_delimited_container_and_directory_mask_ds",
                            "type": "DatasetReference",
                            "parameters": {
                              "DS_CONTAINER": {
                                "value": "@item().sink_database",
                                "type": "Expression"
                              },
                              "DS_DIRECTORY": {
                                "value": "@item().sink_directory",
                                "type": "Expression"
                              }
                            }
                          },
                          "enableLogging": false,
                          "storeSettings": {
                            "type": "AzureBlobFSReadSettings",
                            "recursive": false,
                            "enablePartitionDiscovery": false
                          }
                        }
                      }
                    ]
                  }
                }
              ]
            }
          },
          {
            "name": "Configure Masked Status",
            "type": "Script",
            "dependsOn": [
              {
                "activity": "Select Tables That Require Masking",
                "dependencyConditions": [
                  "Succeeded"
                ]
              }
            ],
            "policy": {
              "timeout": "0.12:00:00",
              "retry": 0,
              "retryIntervalInSeconds": 30,
              "secureOutput": false,
              "secureInput": false
            },
            "userProperties": [],
            "linkedServiceName": {
              "referenceName": "[parameters('Metadata Datastore')]",
              "type": "LinkedServiceReference"
            },
            "typeProperties": {
              "scripts": [
                {
                  "type": "Query",
                  "text": {
                    "value": "WITH\n    tables_requiring_filters AS (\n        SELECT DISTINCT\n            dataset, specified_database, specified_schema, identified_table\n        FROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_RULESET_TABLE')}\n        WHERE ISJSON(assigned_algorithm) = 1\n            AND dataset = '@{variables('DATASET')}'\n            AND specified_database = '@{pipeline().parameters.P_SOURCE_CONTAINER}'\n            AND specified_schema LIKE '@{pipeline().parameters.P_SOURCE_DIRECTORY}%'\n    ), all_filters AS (\n        SELECT DISTINCT\n            JSON_VALUE(kc.value, '$.alias') as filter_alias,\n            identified_table\n        FROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_RULESET_TABLE')} d\n            CROSS APPLY OPENJSON(d.assigned_algorithm) kc\n        WHERE\n            ISJSON(assigned_algorithm,ARRAY) = 1\n            AND\n            identified_table in (\n                SELECT identified_table FROM tables_requiring_filters\n            )\n    ), sources_and_filters AS (\n        SELECT\n            dataset,\n            specified_database,\n            specified_schema,\n            tables_requiring_filters.identified_table,\n            JSON_OBJECTAGG(filter_alias:CAST(0 as BIT)) AS masked_status\n        FROM tables_requiring_filters\n            INNER JOIN all_filters\n            ON tables_requiring_filters.identified_table = all_filters.identified_table\n        GROUP BY dataset, specified_database, specified_schema, tables_requiring_filters.identified_table\n    )\n    UPDATE @{variables('METADATA_SCHEMA')}.@{variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')}\n    SET masked_status = sf.masked_status\n    FROM sources_and_filters sf\n    INNER JOIN @{variables('METADATA_SCHEMA')}.@{variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')} dm ON\n        dm.source_dataset = sf.dataset AND\n        dm.source_database = sf.specified_database AND\n        dm.source_schema = sf.specified_schema AND\n        dm.source_table = sf.identified_table\n    WHERE\n        dm.masked_status IS NULL\n        AND (dm.mapping_complete IS NULL OR dm.mapping_complete = 0)",
                    "type": "Expression"
                  }
                }
              ],
              "scriptBlockExecutionTimeout": "02:00:00"
            }
          }
        ],
        "policy": {
          "elapsedTimeMetric": {}
        },
        "parameters": {
          "P_COPY_UNMASKED_TABLES": {
            "type": "bool",
            "defaultValue": false
          },
          "P_COPY_USE_DATAFLOW": {
            "type": "bool",
            "defaultValue": false
          },
          "P_FAIL_ON_NONCONFORMANT_DATA": {
            "type": "bool",
            "defaultValue": true
          },
          "P_REAPPLY_MAPPING": {
            "type": "bool",
            "defaultValue": true
          },
          "P_TRUNCATE_SINK_BEFORE_WRITE": {
            "type": "bool",
            "defaultValue": true
          },
          "P_SOURCE_CONTAINER": {
            "type": "string",
            "defaultValue": "staging-container"
          },
          "P_SINK_CONTAINER": {
            "type": "string",
            "defaultValue": "staging-container2"
          },
          "P_SOURCE_DIRECTORY": {
            "type": "string"
          },
          "P_SINK_DIRECTORY": {
            "type": "string"
          }
        },
        "variables": {
          "METADATA_SCHEMA": {
            "type": "String",
            "defaultValue": "dbo"
          },
          "METADATA_RULESET_TABLE": {
            "type": "String",
            "defaultValue": "discovered_ruleset"
          },
          "METADATA_SOURCE_TO_SINK_MAPPING_TABLE": {
            "type": "String",
            "defaultValue": "adf_data_mapping"
          },
          "METADATA_ADF_TYPE_MAPPING_TABLE": {
            "type": "String",
            "defaultValue": "adf_type_mapping"
          },
          "TARGET_BATCH_SIZE": {
            "type": "Integer",
            "defaultValue": 50000
          },
          "DATASET": {
            "type": "String",
            "defaultValue": "ADLS-DELIMITED"
          },
          "CONDITIONAL_MASKING_RESERVED_CHARACTER": {
            "type": "String",
            "defaultValue": "%"
          },
          "METADATA_EVENT_PROCEDURE_NAME": {
            "type": "String",
            "defaultValue": "insert_adf_masking_event"
          },
          "SPECIFIED_SCHEMA": {
            "type": "String",
            "defaultValue": "/"
          },
          "METADATA_MASKING_PARAMS_PROCEDURE_NAME": {
            "type": "String",
            "defaultValue": "generate_masking_parameters"
          }
        },
        "folder": {
          "name": "dcsazure_ADLS_to_ADLS_delimited"
        },
        "annotations": [],
        "lastPublishTime": "2025-09-03T18:22:34Z"
      },
      "dependsOn": [
        "[concat(variables('factoryId'), '/datasets/dcsazure_ADLS_to_ADLS_delimited_metadata_mask_ds')]",
        "[concat(variables('factoryId'), '/dataflows/dcsazure_ADLS_to_ADLS_delimited_filter_test_utility_df')]",
        "[concat(variables('factoryId'), '/datasets/dcsazure_ADLS_to_ADLS_delimited_container_and_directory_mask_ds')]",
        "[concat(variables('factoryId'), '/dataflows/dcsazure_ADLS_to_ADLS_delimited_unfiltered_mask_df')]",
        "[concat(variables('factoryId'), '/dataflows/dcsazure_ADLS_to_ADLS_delimited_filtered_mask_df')]",
        "[concat(variables('factoryId'), '/dataflows/dcsazure_ADLS_to_ADLS_delimited_copy_df')]"
      ]
    },
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_ADLS_to_ADLS_delimited_metadata_mask_ds')]",
      "type": "Microsoft.DataFactory/factories/datasets",
      "apiVersion": "2018-06-01",
      "properties": {
        "linkedServiceName": {
          "referenceName": "[parameters('Metadata Datastore')]",
          "type": "LinkedServiceReference"
        },
        "parameters": {
          "DS_METADATA_SCHEMA": {
            "type": "string"
          },
          "DS_METADATA_TABLE": {
            "type": "string"
          }
        },
        "folder": {
          "name": "dcsazure_ADLS_to_ADLS_delimited"
        },
        "annotations": [],
        "type": "AzureSqlTable",
        "schema": [
          {
            "name": "dataset",
            "type": "varchar"
          },
          {
            "name": "specified_database",
            "type": "varchar"
          },
          {
            "name": "specified_schema",
            "type": "varchar"
          },
          {
            "name": "identified_table",
            "type": "varchar"
          },
          {
            "name": "identified_column",
            "type": "varchar"
          },
          {
            "name": "identified_column_type",
            "type": "varchar"
          },
          {
            "name": "identified_column_max_length",
            "type": "int",
            "precision": 10
          },
          {
            "name": "ordinal_position",
            "type": "int",
            "precision": 10
          },
          {
            "name": "row_count",
            "type": "bigint",
            "precision": 19
          },
          {
            "name": "metadata",
            "type": "nvarchar"
          },
          {
            "name": "profiled_domain",
            "type": "varchar"
          },
          {
            "name": "profiled_algorithm",
            "type": "varchar"
          },
          {
            "name": "confidence_score",
            "type": "decimal",
            "precision": 6,
            "scale": 5
          },
          {
            "name": "rows_profiled",
            "type": "bigint",
            "precision": 19
          },
          {
            "name": "assigned_algorithm",
            "type": "varchar"
          },
          {
            "name": "last_profiled_updated_timestamp",
            "type": "datetime",
            "precision": 23,
            "scale": 3
          }
        ],
        "typeProperties": {
          "schema": {
            "value": "@dataset().DS_METADATA_SCHEMA",
            "type": "Expression"
          },
          "table": {
            "value": "@dataset().DS_METADATA_TABLE",
            "type": "Expression"
          }
        }
      },
      "dependsOn": []
    },
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_ADLS_to_ADLS_delimited_filter_test_utility_df')]",
      "type": "Microsoft.DataFactory/factories/dataflows",
      "apiVersion": "2018-06-01",
      "properties": {
        "folder": {
          "name": "dcsazure_ADLS_to_ADLS_delimited"
        },
        "type": "MappingDataFlow",
        "typeProperties": {
          "sources": [
            {
              "linkedService": {
                "referenceName": "[parameters('AzureDataLakeStorage_Source')]",
                "type": "LinkedServiceReference"
              },
              "name": "Source",
              "description": "Select source data in source container DF_SOURCE_CONTAINER, and wildcard that is constructed based on DF_SOURCE_DIRECTORY, DF_SOURCE_PREFIX, and DF_SOURCE_TABLE using an inline dataset, with DF_COLUMN_DELIMITER, DF_QUOTE_CHARACTER, DF_ESCAPE_CHARACTER, and DF_NULL_VALUE as specified in the parameters, and storing the file name in DELPHIX_COMPLIANCE_SERVICE_FILE_NAME"
            }
          ],
          "sinks": [
            {
              "linkedService": {
                "referenceName": "[parameters('AzureDataLakeStorage_Sink')]",
                "type": "LinkedServiceReference"
              },
              "name": "Sink",
              "description": "Sink results of masking to data store by sinking all columns but DELPHIX_COMPLIANCE_SERVICE_BATCH_ID, DELPHIX_COMPLIANCE_SERVICE_SORT_ID, and DELPHIX_COMPLIANCE_SERVICE_FILE_NAME to the data sink, naming the file as DELPHIX_COMPLIANCE_SERVICE_SINK_FILE_NAME, and using the same metadata settings as were used in the source with DF_COLUMN_DELIMITER, DF_QUOTE_CHARACTER, DF_ESCAPE_CHARACTER, and DF_NULL_VALUE"
            }
          ],
          "transformations": [
            {
              "name": "CreateSinkFileName",
              "description": "Create column DELPHIX_COMPLIANCE_SERVICE_SINK_FILE_NAME by replacing DF_SOURCE_DIRECTORY with DF_SINK_DIRECTORY in the value in DELPHIX_COMPLIANCE_SERVICE_FILE_NAME"
            },
            {
              "name": "FilterToAppropriateRows",
              "description": "Filter base table based on supplied filter"
            }
          ],
          "scriptLines": [
            "parameters{",
            "     runId as string (''),",
            "     DF_SOURCE_CONTAINER as string (''),",
            "     DF_SINK_CONTAINER as string (''),",
            "     DF_SOURCE_DIRECTORY as string (''),",
            "     DF_SINK_DIRECTORY as string (''),",
            "     DF_SOURCE_PREFIX as string (''),",
            "     DF_COLUMN_DELIMITER as string (','),",
            "     DF_QUOTE_CHARACTER as string ('\"'),",
            "     DF_ESCAPE_CHARACTER as string ('\\\\'),",
            "     DF_NULL_VALUE as string (''),",
            "     DF_SOURCE_SUFFIX as string (''),",
            "     DF_FILTER_CONDITION as boolean (true())",
            "}",
            "source(useSchema: false,",
            "     allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     ignoreNoFilesFound: false,",
            "     rowUrlColumn: 'DELPHIX_COMPLIANCE_SERVICES_FILE_NAME',",
            "     format: 'delimited',",
            "     fileSystem: ($DF_SOURCE_CONTAINER),",
            "     columnDelimiter: ($DF_COLUMN_DELIMITER),",
            "     escapeChar: ($DF_ESCAPE_CHARACTER),",
            "     quoteChar: ($DF_QUOTE_CHARACTER),",
            "     nullValue: ($DF_NULL_VALUE),",
            "     columnNamesAsHeader: true,",
            "     multiLineRow: true,",
            "     wildcardPaths:[(concat($DF_SOURCE_DIRECTORY,iif(length($DF_SOURCE_PREFIX) == 0,iif(equals('NO_EXT',$DF_SOURCE_SUFFIX),'*',concat('*',$DF_SOURCE_SUFFIX)),iif(equals('NO_EXT',$DF_SOURCE_SUFFIX),concat($DF_SOURCE_PREFIX,'*'),concat($DF_SOURCE_PREFIX,'*',$DF_SOURCE_SUFFIX)))))]) ~> Source",
            "FilterToAppropriateRows derive(DELPHIX_COMPLIANCE_SERVICES_SINK_FILE_NAME = replace(DELPHIX_COMPLIANCE_SERVICES_FILE_NAME, $DF_SOURCE_DIRECTORY, $DF_SINK_DIRECTORY)) ~> CreateSinkFileName",
            "Source filter($DF_FILTER_CONDITION) ~> FilterToAppropriateRows",
            "CreateSinkFileName sink(allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'delimited',",
            "     fileSystem: ($DF_SINK_DATABASE),",
            "     folderPath: ($DF_SINK_DIRECTORY),",
            "     columnDelimiter: ($DF_COLUMN_DELIMITER),",
            "     escapeChar: ($DF_ESCAPE_CHARACTER),",
            "     quoteChar: ($DF_QUOTE_CHARACTER),",
            "     nullValue: ($DF_NULL_VALUE),",
            "     columnNamesAsHeader: true,",
            "     rowUrlColumn:'DELPHIX_COMPLIANCE_SERVICES_SINK_FILE_NAME',",
            "     umask: 0022,",
            "     preCommands: [],",
            "     postCommands: [],",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true,",
            "     mapColumn(",
            "          each(match(name!=\"DELPHIX_COMPLIANCE_SERVICES_FILE_NAME\"&&name!=\"DELPHIX_COMPLIANCE_SERVICES_SINK_FILE_NAME\"))",
            "     )) ~> Sink"
          ]
        }
      },
      "dependsOn": []
    },
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_ADLS_to_ADLS_delimited_container_and_directory_mask_ds')]",
      "type": "Microsoft.DataFactory/factories/datasets",
      "apiVersion": "2018-06-01",
      "properties": {
        "linkedServiceName": {
          "referenceName": "[parameters('AzureDataLakeStorage_Source')]",
          "type": "LinkedServiceReference"
        },
        "parameters": {
          "DS_CONTAINER": {
            "type": "string"
          },
          "DS_DIRECTORY": {
            "type": "string"
          }
        },
        "folder": {
          "name": "dcsazure_ADLS_to_ADLS_delimited"
        },
        "annotations": [],
        "type": "DelimitedText",
        "typeProperties": {
          "location": {
            "type": "AzureBlobFSLocation",
            "folderPath": {
              "value": "@dataset().DS_DIRECTORY",
              "type": "Expression"
            },
            "fileSystem": {
              "value": "@dataset().DS_CONTAINER",
              "type": "Expression"
            }
          },
          "columnDelimiter": ",",
          "escapeChar": "\\",
          "firstRowAsHeader": false,
          "quoteChar": "\""
        },
        "schema": [
          {
            "type": "String"
          }
        ]
      },
      "dependsOn": []
    },
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_ADLS_to_ADLS_delimited_unfiltered_mask_df')]",
      "type": "Microsoft.DataFactory/factories/dataflows",
      "apiVersion": "2018-06-01",
      "properties": {
        "folder": {
          "name": "dcsazure_ADLS_to_ADLS_delimited"
        },
        "type": "MappingDataFlow",
        "typeProperties": {
          "sources": [
            {
              "linkedService": {
                "referenceName": "[parameters('AzureDataLakeStorage_Source')]",
                "type": "LinkedServiceReference"
              },
              "name": "Source",
              "description": "Select source data in source container DF_SOURCE_CONTAINER, and wildcard that is constructed based on DF_SOURCE_DIRECTORY, DF_SOURCE_PREFIX, and DF_SOURCE_TABLE using an inline dataset, with DF_COLUMN_DELIMITER, DF_QUOTE_CHARACTER, DF_ESCAPE_CHARACTER, and DF_NULL_VALUE as specified in the parameters, and storing the file name in DELPHIX_COMPLIANCE_SERVICE_FILE_NAME"
            }
          ],
          "sinks": [
            {
              "linkedService": {
                "referenceName": "[parameters('AzureDataLakeStorage_Sink')]",
                "type": "LinkedServiceReference"
              },
              "name": "Sink",
              "description": "Sink results of masking to data store by sinking all columns but DELPHIX_COMPLIANCE_SERVICE_BATCH_ID, DELPHIX_COMPLIANCE_SERVICE_SORT_ID, and DELPHIX_COMPLIANCE_SERVICE_FILE_NAME to the data sink, naming the file as DELPHIX_COMPLIANCE_SERVICE_SINK_FILE_NAME, and using the same metadata settings as were used in the source with DF_COLUMN_DELIMITER, DF_QUOTE_CHARACTER, DF_ESCAPE_CHARACTER, and DF_NULL_VALUE"
            }
          ],
          "transformations": [
            {
              "name": "DCSForAzureAPI",
              "linkedService": {
                "referenceName": "[parameters('ProdDCSForAzureService')]",
                "type": "LinkedServiceReference"
              }
            },
            {
              "name": "AddSortKey",
              "description": "Create column DELPHIX_COMPLIANCE_SERVICE_SORT_ID that consists of SHA of the data across all columns in the table - every row will have this value and it cannot be null"
            },
            {
              "name": "SortBySortKey",
              "description": "Sort the table by the value in DELPHIX_COMPLIANCE_SERVICE_SORT_ID, as we need the table to be in a particular order before we apply a surrogate key"
            },
            {
              "name": "CreateSurrogateKey",
              "description": "Add a DELPHIX_COMPLIANCE_SERVICE_BATCH_ID column that increments by 1 and starts at 1 after applying the sorting"
            },
            {
              "name": "WrapValuesInArray",
              "description": "For each column we wish to mask, convert the value into an array, this is needed to preserve null values as null when using collect, as null values become [], and encode the column names to handle body type mapping changes"
            },
            {
              "name": "SelectColumnsUnmasked",
              "description": "Select only columns that don't require masking"
            },
            {
              "name": "AggregateColumnsByBatch",
              "description": "For each column we wish to mask, aggregate to a list using collect, grouped by DELPHIX_COMPLIANCE_SERVICE_BATCH_ID batches by using DF_TARGET_BATCH_SIZE and the number of columns being masked, name the group as DELPHIX_COMPLIANCE_SERVICE_BATCH_GROUP"
            },
            {
              "name": "FlattenValuesOutOfArray",
              "description": "For each column we wish to mask, flatten the value out of the array, in the case where the value was previously [], it becomes null"
            },
            {
              "name": "AssertNoFailures",
              "description": "Confirm that we received a 200 response status from the API request"
            },
            {
              "name": "FlattenAggregateData",
              "description": "Unroll the API response body into decoded named columns"
            },
            {
              "name": "JoinMaskedAndUnmaskedData",
              "description": "Inner join on SelectColumnsUnmasked and FlattenAggregateData based on matching DELPHIX_COMPLIANCE_SERVICE_BATCH_ID"
            },
            {
              "name": "CreateSinkFileName",
              "description": "Create column DELPHIX_COMPLIANCE_SERVICE_SINK_FILE_NAME by replacing DF_SOURCE_DIRECTORY with DF_SINK_DIRECTORY in the value in DELPHIX_COMPLIANCE_SERVICE_FILE_NAME"
            },
            {
              "name": "CreateAlterRow",
              "description": "Add an alter row condition so that all rows will be inserted into the existing table with the correct column order"
            },
            {
              "name": "CombineRows",
              "description": "Union the output of RemoveAmbiguousColumn with the empty CreateAlterRow table, and performing the union by name"
            },
            {
              "name": "RemoveAmbiguousColumn",
              "description": "Since both FlattenAggregateData and SelectColumnsUnmasked have a column DELPHIX_COMPLIANCE_SERVICE_BATCH_ID, we need to remove that column, so select all columns whose name isn't DELPHIX_COMPLIANCE_SERVICE_BATCH_ID"
            },
            {
              "name": "RemoveAllData",
              "description": "To preserve the order of the columns, we will remove all rows from the table by filtering on false()"
            }
          ],
          "scriptLines": [
            "parameters{",
            "     runId as string (''),",
            "     DF_SOURCE_CONTAINER as string (''),",
            "     DF_SINK_CONTAINER as string (''),",
            "     DF_SOURCE_DIRECTORY as string (''),",
            "     DF_SINK_DIRECTORY as string (''),",
            "     DF_SOURCE_PREFIX as string (''),",
            "     DF_SOURCE_TABLE as string (''),",
            "     DF_SINK_TABLE as string (''),",
            "     DF_COLUMN_DELIMITER as string (''),",
            "     DF_QUOTE_CHARACTER as string (''),",
            "     DF_ESCAPE_CHARACTER as string (''),",
            "     DF_NULL_VALUE as string (''),",
            "     DF_FIELD_ALGORITHM_ASSIGNMENT as string ('{}'),",
            "     DF_COLUMNS_TO_MASK as string[] ([\"\"]),",
            "     DF_BODY_TYPE_MAPPING as string ('(timestamp as date, status as string, message as string, trace_id as string, items as (DELPHIX_COMPLIANCE_SERVICE_BATCH_ID as long)[])'),",
            "     DF_TRIM_LENGTHS as integer[] ([-1]),",
            "     DF_FAIL_ON_NONCONFORMANT_DATA as boolean (true()),",
            "     DF_TARGET_BATCH_SIZE as integer (50000),",
            "     DF_FIELD_DATE_FORMAT as string ('{}')",
            "}",
            "source(useSchema: false,",
            "     allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     ignoreNoFilesFound: false,",
            "     rowUrlColumn: 'DELPHIX_COMPLIANCE_SERVICE_FILE_NAME',",
            "     format: 'delimited',",
            "     fileSystem: ($DF_SOURCE_CONTAINER),",
            "     columnDelimiter: ($DF_COLUMN_DELIMITER),",
            "     escapeChar: ($DF_ESCAPE_CHARACTER),",
            "     quoteChar: ($DF_QUOTE_CHARACTER),",
            "     nullValue: ($DF_NULL_VALUE),",
            "     columnNamesAsHeader: true,",
            "     multiLineRow: true,",
            "     wildcardPaths:[(concat($DF_SOURCE_DIRECTORY,iif(length($DF_SOURCE_PREFIX) == 0,iif(equals('NO_EXT',$DF_SOURCE_TABLE),'*',concat('*',$DF_SOURCE_TABLE)),iif(equals('NO_EXT',$DF_SOURCE_TABLE),concat($DF_SOURCE_PREFIX,'*'),concat($DF_SOURCE_PREFIX,'*',$DF_SOURCE_TABLE)))))],",
            "     partitionBy('roundRobin', 32)) ~> Source",
            "FlattenValuesOutOfArray call(mapColumn(",
            "          each(match(name!='DELPHIX_COMPLIANCE_SERVICE_BATCH_GROUP'))",
            "     ),",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true,",
            "     output(",
            "          headers as [string,string],",
            "          body as (timestamp as date, status as string, message as string, trace_id as string, items as (DELPHIX_COMPLIANCE_SERVICE_BATCH_ID as long)[]),",
            "          status as string",
            "     ),",
            "     allowSchemaDrift: true,",
            "     format: 'rest',",
            "     store: 'restservice',",
            "     timeout: 300,",
            "     requestInterval: 0,",
            "     headers = ['Run-Id' -> $runId, 'Field-Algorithm-Assignment' -> $DF_FIELD_ALGORITHM_ASSIGNMENT, 'Fail-On-Non-Conformant-Data' -> iif($DF_FAIL_ON_NONCONFORMANT_DATA,'true','false'), 'Field-Date-Format' -> $DF_FIELD_DATE_FORMAT],",
            "     httpMethod: 'POST',",
            "     entity: 'v1/masking/batchMaskByColumn',",
            "     headerColumnName: 'headers',",
            "     bodyColumnName: 'body',",
            "     statusColumnName: 'status',",
            "     addResponseCode: true,",
            "     requestFormat: ['type' -> 'json'],",
            "     responseFormat: ['type' -> 'json', 'documentForm' -> 'documentPerLine'],",
            "     columnTypeMap: ['body'->'$DF_BODY_TYPE_MAPPING']) ~> DCSForAzureAPI",
            "Source derive(DELPHIX_COMPLIANCE_SERVICE_SORT_ID = sha2(256, columns())) ~> AddSortKey",
            "AddSortKey sort(asc(DELPHIX_COMPLIANCE_SERVICE_SORT_ID, false)) ~> SortBySortKey",
            "SortBySortKey keyGenerate(output(DELPHIX_COMPLIANCE_SERVICE_BATCH_ID as long),",
            "     startAt: 1L,",
            "     stepValue: 1L) ~> CreateSurrogateKey",
            "CreateSurrogateKey derive(each(match(contains($DF_COLUMNS_TO_MASK,#item==name)), concat('x',hex(encode($$))) = array($$))) ~> WrapValuesInArray",
            "CreateSurrogateKey select(mapColumn(",
            "          each(match(!contains($DF_COLUMNS_TO_MASK,#item==name)))",
            "     ),",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true) ~> SelectColumnsUnmasked",
            "WrapValuesInArray aggregate(groupBy(DELPHIX_COMPLIANCE_SERVICE_BATCH_GROUP = toInteger(ceil(DELPHIX_COMPLIANCE_SERVICE_BATCH_ID/($DF_TARGET_BATCH_SIZE/size($DF_COLUMNS_TO_MASK))))),",
            "     each(match((startsWith(name,'x')&&not(contains($DF_COLUMNS_TO_MASK,#item==name)))||(name==\"DELPHIX_COMPLIANCE_SERVICE_BATCH_ID\")), $$ = collect($$))) ~> AggregateColumnsByBatch",
            "AggregateColumnsByBatch derive(each(match(startsWith(name,'x')||(name==\"DELPHIX_COMPLIANCE_SERVICE_BATCH_ID\")), $$ = flatten($$))) ~> FlattenValuesOutOfArray",
            "DCSForAzureAPI assert(expectTrue(toInteger(regexExtract(status, '(\\\\d+)', 1)) == 200, false, 'Failed_request', null, iif(isNull(body.message), status, concatWS(', ', 'timestamp: ' + toString(body.timestamp), 'status: ' + body.status, 'message: ' + body.message, 'trace_id: ' + body.trace_id))),",
            "     abort: true) ~> AssertNoFailures",
            "AssertNoFailures foldDown(unroll(body.items),",
            "     mapColumn(",
            "          every(body.items,match(name=='DELPHIX_COMPLIANCE_SERVICE_BATCH_ID')),",
            "          every(body.items,match(startsWith(name,'x')),",
            "               decode(unhex(replace($$,'x',''))) = $$)",
            "     ),",
            "     skipDuplicateMapInputs: false,",
            "     skipDuplicateMapOutputs: false) ~> FlattenAggregateData",
            "SelectColumnsUnmasked, FlattenAggregateData join(SelectColumnsUnmasked@DELPHIX_COMPLIANCE_SERVICE_BATCH_ID == FlattenAggregateData@DELPHIX_COMPLIANCE_SERVICE_BATCH_ID,",
            "     joinType:'inner',",
            "     matchType:'exact',",
            "     ignoreSpaces: false,",
            "     broadcast: 'off')~> JoinMaskedAndUnmaskedData",
            "CombineRows derive(DELPHIX_COMPLIANCE_SERVICE_SINK_FILE_NAME = replace(DELPHIX_COMPLIANCE_SERVICE_FILE_NAME, $DF_SOURCE_DIRECTORY, $DF_SINK_DIRECTORY)) ~> CreateSinkFileName",
            "RemoveAllData alterRow(insertIf(true())) ~> CreateAlterRow",
            "CreateAlterRow, RemoveAmbiguousColumn union(byName: true)~> CombineRows",
            "JoinMaskedAndUnmaskedData select(mapColumn(",
            "          each(match(name!=\"DELPHIX_COMPLIANCE_SERVICE_BATCH_ID\"))",
            "     ),",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true) ~> RemoveAmbiguousColumn",
            "CreateSurrogateKey filter(false()) ~> RemoveAllData",
            "CreateSinkFileName sink(allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'delimited',",
            "     fileSystem: ($DF_SINK_CONTAINER),",
            "     folderPath: ($DF_SINK_DIRECTORY),",
            "     columnDelimiter: ($DF_COLUMN_DELIMITER),",
            "     escapeChar: ($DF_ESCAPE_CHARACTER),",
            "     quoteChar: ($DF_QUOTE_CHARACTER),",
            "     nullValue: ($DF_NULL_VALUE),",
            "     columnNamesAsHeader: true,",
            "     rowUrlColumn:'DELPHIX_COMPLIANCE_SERVICE_SINK_FILE_NAME',",
            "     umask: 0022,",
            "     preCommands: [],",
            "     postCommands: [],",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true,",
            "     mapColumn(",
            "          each(match(name!=\"DELPHIX_COMPLIANCE_SERVICE_BATCH_ID\"&&name!=\"DELPHIX_COMPLIANCE_SERVICE_SORT_ID\"&&name!=\"DELPHIX_COMPLIANCE_SERVICE_FILE_NAME\"))",
            "     )) ~> Sink"
          ]
        }
      },
      "dependsOn": []
    },
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_ADLS_to_ADLS_delimited_filtered_mask_df')]",
      "type": "Microsoft.DataFactory/factories/dataflows",
      "apiVersion": "2018-06-01",
      "properties": {
        "description": "Perform masking on a subset of the data that matches the specified filter",
        "folder": {
          "name": "dcsazure_ADLS_to_ADLS_delimited"
        },
        "type": "MappingDataFlow",
        "typeProperties": {
          "sources": [
            {
              "linkedService": {
                "referenceName": "[parameters('AzureDataLakeStorage_Source')]",
                "type": "LinkedServiceReference"
              },
              "name": "Source",
              "description": "Select source data in source container DF_SOURCE_CONTAINER, and wildcard that is constructed based on DF_SOURCE_DIRECTORY, DF_SOURCE_PREFIX, and DF_SOURCE_TABLE using an inline dataset, with DF_COLUMN_DELIMITER, DF_QUOTE_CHARACTER, DF_ESCAPE_CHARACTER, and DF_NULL_VALUE as specified in the parameters, and storing the file name in DELPHIX_COMPLIANCE_SERVICE_FILE_NAME"
            }
          ],
          "sinks": [
            {
              "linkedService": {
                "referenceName": "[parameters('AzureDataLakeStorage_Sink')]",
                "type": "LinkedServiceReference"
              },
              "name": "Sink",
              "description": "Sink results of masking to data store by sinking all columns but DELPHIX_COMPLIANCE_SERVICE_BATCH_ID, DELPHIX_COMPLIANCE_SERVICE_SORT_ID, and DELPHIX_COMPLIANCE_SERVICE_FILE_NAME to the data sink, naming the file as DELPHIX_COMPLIANCE_SERVICE_SINK_FILE_NAME, and using the same metadata settings as were used in the source with DF_COLUMN_DELIMITER, DF_QUOTE_CHARACTER, DF_ESCAPE_CHARACTER, and DF_NULL_VALUE"
            }
          ],
          "transformations": [
            {
              "name": "DCSForAzureAPI",
              "linkedService": {
                "referenceName": "[parameters('ProdDCSForAzureService')]",
                "type": "LinkedServiceReference"
              }
            },
            {
              "name": "AddSortKey",
              "description": "Create column DELPHIX_COMPLIANCE_SERVICE_SORT_ID that consists of SHA of the data across all columns in the table - every row will have this value and it cannot be null"
            },
            {
              "name": "SortBySortKey",
              "description": "Sort the table by the value in DELPHIX_COMPLIANCE_SERVICE_SORT_ID, as we need the table to be in a particular order before we apply a surrogate key"
            },
            {
              "name": "CreateSurrogateKey",
              "description": "Add a DELPHIX_COMPLIANCE_SERVICE_BATCH_ID column that increments by 1 and starts at 1 after applying the sorting"
            },
            {
              "name": "WrapValuesInArray",
              "description": "For each column we wish to mask, convert the value into an array, this is needed to preserve null values as null when using collect, as null values become [], and encode the column names to handle body type mapping changes"
            },
            {
              "name": "SelectColumnsUnmasked",
              "description": "Select only columns that don't require masking"
            },
            {
              "name": "AggregateColumnsByBatch",
              "description": "For each column we wish to mask, aggregate to a list using collect, grouped by DELPHIX_COMPLIANCE_SERVICE_BATCH_ID batches by using DF_TARGET_BATCH_SIZE and the number of columns being masked, name the group as DELPHIX_COMPLIANCE_SERVICE_BATCH_GROUP"
            },
            {
              "name": "FlattenValuesOutOfArray",
              "description": "For each column we wish to mask, flatten the value out of the array, in the case where the value was previously [], it becomes null"
            },
            {
              "name": "AssertNoFailures",
              "description": "Confirm that we received a 200 response status from the API request"
            },
            {
              "name": "FlattenAggregateData",
              "description": "Unroll the API response body into decoded named columns"
            },
            {
              "name": "JoinMaskedAndUnmaskedData",
              "description": "Inner join on SelectColumnsUnmasked and FlattenAggregateData based on matching DELPHIX_COMPLIANCE_SERVICE_BATCH_ID"
            },
            {
              "name": "CreateAlterRow",
              "description": "Add an alter row condition so that all rows will be inserted into the existing table with the correct column order"
            },
            {
              "name": "CombineRows",
              "description": "Union the output of RemoveAmbiguousColumn with the empty CreateAlterRow table, and performing the union by name"
            },
            {
              "name": "RemoveAmbiguousColumn",
              "description": "Since both FlattenAggregateData and SelectColumnsUnmasked have a column DELPHIX_COMPLIANCE_SERVICE_BATCH_ID, we need to remove that column, so select all columns whose name isn't DELPHIX_COMPLIANCE_SERVICE_BATCH_ID"
            },
            {
              "name": "RemoveAllData",
              "description": "To preserve the order of the columns, we will remove all rows from the table by filtering on false()"
            },
            {
              "name": "ApplyTableFilter",
              "description": "Filter base table based on supplied filter"
            }
          ],
          "scriptLines": [
            "parameters{",
            "     runId as string (''),",
            "     DF_SOURCE_CONTAINER as string (''),",
            "     DF_SINK_CONTAINER as string (''),",
            "     DF_SOURCE_DIRECTORY as string (''),",
            "     DF_SINK_DIRECTORY as string (''),",
            "     DF_SOURCE_PREFIX as string (''),",
            "     DF_SOURCE_TABLE as string (''),",
            "     DF_SINK_TABLE as string (''),",
            "     DF_COLUMN_DELIMITER as string (''),",
            "     DF_QUOTE_CHARACTER as string (''),",
            "     DF_ESCAPE_CHARACTER as string (''),",
            "     DF_NULL_VALUE as string (''),",
            "     DF_FIELD_ALGORITHM_ASSIGNMENT as string ('{}'),",
            "     DF_COLUMNS_TO_MASK as string[] ([\"\"]),",
            "     DF_BODY_TYPE_MAPPING as string ('(timestamp as date, status as string, message as string, trace_id as string, items as (DELPHIX_COMPLIANCE_SERVICE_BATCH_ID as long)[])'),",
            "     DF_TRIM_LENGTHS as integer[] ([-1]),",
            "     DF_FAIL_ON_NONCONFORMANT_DATA as boolean (true()),",
            "     DF_TARGET_BATCH_SIZE as integer (50000),",
            "     DF_FIELD_DATE_FORMAT as string ('{}'),",
            "     DF_FILTER_CONDITION as boolean (true())",
            "}",
            "source(useSchema: false,",
            "     allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     ignoreNoFilesFound: false,",
            "     rowUrlColumn: 'DELPHIX_COMPLIANCE_SERVICE_FILE_NAME',",
            "     format: 'delimited',",
            "     fileSystem: ($DF_SOURCE_CONTAINER),",
            "     columnDelimiter: ($DF_COLUMN_DELIMITER),",
            "     escapeChar: ($DF_ESCAPE_CHARACTER),",
            "     quoteChar: ($DF_QUOTE_CHARACTER),",
            "     nullValue: ($DF_NULL_VALUE),",
            "     columnNamesAsHeader: true,",
            "     multiLineRow: true,",
            "     wildcardPaths:[(concat($DF_SOURCE_DIRECTORY,iif(length($DF_SOURCE_PREFIX) == 0,iif(equals('NO_EXT',$DF_SOURCE_TABLE),'*',concat('*',$DF_SOURCE_TABLE)),iif(equals('NO_EXT',$DF_SOURCE_TABLE),concat($DF_SOURCE_PREFIX,'*'),concat($DF_SOURCE_PREFIX,'*',$DF_SOURCE_TABLE)))))],",
            "     partitionBy('roundRobin', 32)) ~> Source",
            "FlattenValuesOutOfArray call(mapColumn(",
            "          each(match(name!='DELPHIX_COMPLIANCE_SERVICE_BATCH_GROUP'))",
            "     ),",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true,",
            "     output(",
            "          headers as [string,string],",
            "          body as (timestamp as date, status as string, message as string, trace_id as string, items as (DELPHIX_COMPLIANCE_SERVICE_BATCH_ID as long)[]),",
            "          status as string",
            "     ),",
            "     allowSchemaDrift: true,",
            "     format: 'rest',",
            "     store: 'restservice',",
            "     timeout: 300,",
            "     requestInterval: 0,",
            "     headers = ['Run-Id' -> $runId, 'Field-Algorithm-Assignment' -> $DF_FIELD_ALGORITHM_ASSIGNMENT, 'Fail-On-Non-Conformant-Data' -> iif($DF_FAIL_ON_NONCONFORMANT_DATA,'true','false'), 'Field-Date-Format' -> $DF_FIELD_DATE_FORMAT],",
            "     httpMethod: 'POST',",
            "     entity: 'v1/masking/batchMaskByColumn',",
            "     headerColumnName: 'headers',",
            "     bodyColumnName: 'body',",
            "     statusColumnName: 'status',",
            "     addResponseCode: true,",
            "     requestFormat: ['type' -> 'json'],",
            "     responseFormat: ['type' -> 'json', 'documentForm' -> 'documentPerLine'],",
            "     columnTypeMap: ['body'->'$DF_BODY_TYPE_MAPPING']) ~> DCSForAzureAPI",
            "ApplyTableFilter derive(DELPHIX_COMPLIANCE_SERVICE_SORT_ID = sha2(256, columns())) ~> AddSortKey",
            "AddSortKey sort(asc(DELPHIX_COMPLIANCE_SERVICE_SORT_ID, false)) ~> SortBySortKey",
            "SortBySortKey keyGenerate(output(DELPHIX_COMPLIANCE_SERVICE_BATCH_ID as long),",
            "     startAt: 1L,",
            "     stepValue: 1L) ~> CreateSurrogateKey",
            "CreateSurrogateKey derive(each(match(contains($DF_COLUMNS_TO_MASK,#item==name)), concat('x',hex(encode($$))) = array($$))) ~> WrapValuesInArray",
            "CreateSurrogateKey select(mapColumn(",
            "          each(match(!contains($DF_COLUMNS_TO_MASK,#item==name)))",
            "     ),",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true) ~> SelectColumnsUnmasked",
            "WrapValuesInArray aggregate(groupBy(DELPHIX_COMPLIANCE_SERVICE_BATCH_GROUP = toInteger(ceil(DELPHIX_COMPLIANCE_SERVICE_BATCH_ID/($DF_TARGET_BATCH_SIZE/size($DF_COLUMNS_TO_MASK))))),",
            "     each(match((startsWith(name,'x')&&not(contains($DF_COLUMNS_TO_MASK,#item==name)))||(name==\"DELPHIX_COMPLIANCE_SERVICE_BATCH_ID\")), $$ = collect($$))) ~> AggregateColumnsByBatch",
            "AggregateColumnsByBatch derive(each(match(startsWith(name,'x')||(name==\"DELPHIX_COMPLIANCE_SERVICE_BATCH_ID\")), $$ = flatten($$))) ~> FlattenValuesOutOfArray",
            "DCSForAzureAPI assert(expectTrue(toInteger(regexExtract(status, '(\\\\d+)', 1)) == 200, false, 'Failed_request', null, iif(isNull(body.message), status, concatWS(', ', 'timestamp: ' + toString(body.timestamp), 'status: ' + body.status, 'message: ' + body.message, 'trace_id: ' + body.trace_id))),",
            "     abort: true) ~> AssertNoFailures",
            "AssertNoFailures foldDown(unroll(body.items),",
            "     mapColumn(",
            "          every(body.items,match(name==\"DELPHIX_COMPLIANCE_SERVICE_BATCH_ID\")),",
            "          every(body.items,match(startsWith(name,'x')),",
            "               decode(unhex(replace($$,'x',''))) = $$)",
            "     ),",
            "     skipDuplicateMapInputs: false,",
            "     skipDuplicateMapOutputs: false) ~> FlattenAggregateData",
            "SelectColumnsUnmasked, FlattenAggregateData join(SelectColumnsUnmasked@DELPHIX_COMPLIANCE_SERVICE_BATCH_ID == FlattenAggregateData@DELPHIX_COMPLIANCE_SERVICE_BATCH_ID,",
            "     joinType:'inner',",
            "     matchType:'exact',",
            "     ignoreSpaces: false,",
            "     broadcast: 'off')~> JoinMaskedAndUnmaskedData",
            "RemoveAllData alterRow(insertIf(true())) ~> CreateAlterRow",
            "CreateAlterRow, RemoveAmbiguousColumn union(byName: true)~> CombineRows",
            "JoinMaskedAndUnmaskedData select(mapColumn(",
            "          each(match(name!=\"DELPHIX_COMPLIANCE_SERVICE_BATCH_ID\"))",
            "     ),",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true) ~> RemoveAmbiguousColumn",
            "CreateSurrogateKey filter(false()) ~> RemoveAllData",
            "Source filter($DF_FILTER_CONDITION) ~> ApplyTableFilter",
            "CombineRows sink(allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'delimited',",
            "     fileSystem: ($DF_SINK_CONTAINER),",
            "     folderPath: ($DF_SINK_DIRECTORY),",
            "     columnDelimiter: ($DF_COLUMN_DELIMITER),",
            "     escapeChar: ($DF_ESCAPE_CHARACTER),",
            "     quoteChar: ($DF_QUOTE_CHARACTER),",
            "     nullValue: ($DF_NULL_VALUE),",
            "     columnNamesAsHeader: true,",
            "     umask: 0022,",
            "     preCommands: [],",
            "     postCommands: [],",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true,",
            "     mapColumn(",
            "          each(match(name!=\"DELPHIX_COMPLIANCE_SERVICE_BATCH_ID\"&&name!=\"DELPHIX_COMPLIANCE_SERVICE_SORT_ID\"&&name!=\"DELPHIX_COMPLIANCE_SERVICE_FILE_NAME\"))",
            "     )) ~> Sink"
          ]
        }
      },
      "dependsOn": []
    },
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_ADLS_to_ADLS_delimited_copy_df')]",
      "type": "Microsoft.DataFactory/factories/dataflows",
      "apiVersion": "2018-06-01",
      "properties": {
        "folder": {
          "name": "dcsazure_ADLS_to_ADLS_delimited"
        },
        "type": "MappingDataFlow",
        "typeProperties": {
          "sources": [
            {
              "linkedService": {
                "referenceName": "[parameters('AzureDataLakeStorage_Source')]",
                "type": "LinkedServiceReference"
              },
              "name": "Source",
              "description": "Select source data in source container DF_SOURCE_CONTAINER, and wildcard that is constructed based on DF_SOURCE_DIRECTORY, DF_SOURCE_PREFIX, and DF_SOURCE_TABLE using an inline dataset, with DF_COLUMN_DELIMITER, DF_QUOTE_CHARACTER, DF_ESCAPE_CHARACTER, and DF_NULL_VALUE as specified in the parameters, and storing the file name in DELPHIX_COMPLIANCE_SERVICE_FILE_NAME"
            }
          ],
          "sinks": [
            {
              "linkedService": {
                "referenceName": "[parameters('AzureDataLakeStorage_Sink')]",
                "type": "LinkedServiceReference"
              },
              "name": "Sink",
              "description": "Sink results of masking to data store by sinking all columns but DELPHIX_COMPLIANCE_SERVICE_BATCH_ID, DELPHIX_COMPLIANCE_SERVICE_SORT_ID, and DELPHIX_COMPLIANCE_SERVICE_FILE_NAME to the data sink, naming the file as DELPHIX_COMPLIANCE_SERVICE_SINK_FILE_NAME, and using the same metadata settings as were used in the source with DF_COLUMN_DELIMITER, DF_QUOTE_CHARACTER, DF_ESCAPE_CHARACTER, and DF_NULL_VALUE"
            }
          ],
          "transformations": [
            {
              "name": "CreateSinkFileName",
              "description": "Create column DELPHIX_COMPLIANCE_SERVICE_SINK_FILE_NAME by replacing DF_SOURCE_DIRECTORY with DF_SINK_DIRECTORY in the value in DELPHIX_COMPLIANCE_SERVICE_FILE_NAME"
            }
          ],
          "scriptLines": [
            "parameters{",
            "     runId as string (''),",
            "     DF_SOURCE_CONTAINER as string (''),",
            "     DF_SINK_CONTAINER as string (''),",
            "     DF_SOURCE_DIRECTORY as string (''),",
            "     DF_SINK_DIRECTORY as string (''),",
            "     DF_SOURCE_PREFIX as string (''),",
            "     DF_COLUMN_DELIMITER as string (','),",
            "     DF_QUOTE_CHARACTER as string ('\"'),",
            "     DF_ESCAPE_CHARACTER as string ('\\\\'),",
            "     DF_NULL_VALUE as string (''),",
            "     DF_SOURCE_SUFFIX as string ('')",
            "}",
            "source(useSchema: false,",
            "     allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     ignoreNoFilesFound: false,",
            "     rowUrlColumn: 'DELPHIX_COMPLIANCE_SERVICES_FILE_NAME',",
            "     format: 'delimited',",
            "     fileSystem: ($DF_SOURCE_CONTAINER),",
            "     columnDelimiter: ($DF_COLUMN_DELIMITER),",
            "     escapeChar: ($DF_ESCAPE_CHARACTER),",
            "     quoteChar: ($DF_QUOTE_CHARACTER),",
            "     nullValue: ($DF_NULL_VALUE),",
            "     columnNamesAsHeader: true,",
            "     multiLineRow: true,",
            "     wildcardPaths:[(concat($DF_SOURCE_DIRECTORY,iif(length($DF_SOURCE_PREFIX) == 0,iif(equals('NO_EXT',$DF_SOURCE_SUFFIX),'*',concat('*',$DF_SOURCE_SUFFIX)),iif(equals('NO_EXT',$DF_SOURCE_SUFFIX),concat($DF_SOURCE_PREFIX,'*'),concat($DF_SOURCE_PREFIX,'*',$DF_SOURCE_SUFFIX)))))]) ~> Source",
            "Source derive(DELPHIX_COMPLIANCE_SERVICES_SINK_FILE_NAME = replace(DELPHIX_COMPLIANCE_SERVICES_FILE_NAME, $DF_SOURCE_DIRECTORY, $DF_SINK_DIRECTORY)) ~> CreateSinkFileName",
            "CreateSinkFileName sink(allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'delimited',",
            "     fileSystem: ($DF_SINK_CONTAINER),",
            "     folderPath: ($DF_SINK_DIRECTORY),",
            "     columnDelimiter: ($DF_COLUMN_DELIMITER),",
            "     escapeChar: ($DF_ESCAPE_CHARACTER),",
            "     quoteChar: ($DF_QUOTE_CHARACTER),",
            "     nullValue: ($DF_NULL_VALUE),",
            "     columnNamesAsHeader: true,",
            "     rowUrlColumn:'DELPHIX_COMPLIANCE_SERVICES_SINK_FILE_NAME',",
            "     umask: 0022,",
            "     preCommands: [],",
            "     postCommands: [],",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true,",
            "     mapColumn(",
            "          each(match(name!=\"DELPHIX_COMPLIANCE_SERVICES_FILE_NAME\"&&name!=\"DELPHIX_COMPLIANCE_SERVICES_SINK_FILE_NAME\"))",
            "     )) ~> Sink"
          ]
        }
      },
      "dependsOn": []
    }
  ]
}
