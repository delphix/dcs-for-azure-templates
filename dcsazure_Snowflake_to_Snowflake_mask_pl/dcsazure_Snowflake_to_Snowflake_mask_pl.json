{
  "$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
  "contentVersion": "1.0.0.0",
  "parameters": {
    "factoryName": {
      "type": "string",
      "metadata": "Data Factory name"
    },
    "Metadata Datastore": {
      "type": "string"
    },
    "BlobStoreStagingArea": {
      "type": "string"
    },
    "Snowflake_Sink_New": {
      "type": "string"
    },
    "Snowflake_Source_New": {
      "type": "string"
    },
    "ProdDCSForAzureService": {
      "type": "string"
    }
  },
  "variables": {
    "factoryId": "[concat('Microsoft.DataFactory/factories/', parameters('factoryName'))]"
  },
  "resources": [
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_Snowflake_to_Snowflake_mask_pl')]",
      "type": "Microsoft.DataFactory/factories/pipelines",
      "apiVersion": "2018-06-01",
      "properties": {
        "activities": [
          {
            "name": "Select Tables That Require Masking",
            "description": "Select tables with a data mapping and assigned algorithms, as well as filters that may be needed for conditional masking.",
            "type": "Lookup",
            "dependsOn": [
              {
                "activity": "For Each Table To Truncate",
                "dependencyConditions": [
                  "Succeeded"
                ]
              }
            ],
            "policy": {
              "timeout": "0.12:00:00",
              "retry": 0,
              "retryIntervalInSeconds": 30,
              "secureOutput": false,
              "secureInput": false
            },
            "userProperties": [],
            "typeProperties": {
              "source": {
                "type": "AzureSqlSource",
                "sqlReaderQuery": {
                  "value": "WITH\ntables_requiring_filters AS\n(\n\tSELECT DISTINCT\n\t\tdataset, specified_database, specified_schema, identified_table\n\tFROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_RULESET_TABLE')}\n\tWHERE ISJSON(assigned_algorithm) = 1\n\tAND dataset = '@{variables('DATASET')}'\n\tAND specified_database = '@{pipeline().parameters.P_SOURCE_DATABASE}'\n\tAND specified_schema = '@{pipeline().parameters.P_SOURCE_SCHEMA}'\n),\ntables_not_requiring_filters AS\n(\n\tSELECT DISTINCT\n\t\tdataset, specified_database, specified_schema, identified_table\n\tFROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_RULESET_TABLE')}\n\tWHERE assigned_algorithm IS NOT NULL\n\tAND assigned_algorithm != ''\n\tAND dataset = '@{variables('DATASET')}'\n\tAND specified_database = '@{pipeline().parameters.P_SOURCE_DATABASE}'\n\tAND specified_schema = '@{pipeline().parameters.P_SOURCE_SCHEMA}'\n\tEXCEPT\n\tSELECT dataset, specified_database, specified_schema, identified_table\n\tFROM tables_requiring_filters\n\tWHERE dataset = '@{variables('DATASET')}'\n\tAND specified_database = '@{pipeline().parameters.P_SOURCE_DATABASE}'\n\tAND specified_schema = '@{pipeline().parameters.P_SOURCE_SCHEMA}'\n),\nall_filters AS\n(\n\tSELECT DISTINCT\n\t\tJSON_VALUE(kc.value, '$.alias') as filter_alias,\n\t\treplace(JSON_VALUE(kc.value, '$.condition'), '@{variables('CONDITIONAL_MASKING_RESERVED_CHARACTER')}', concat('byName(''', d.identified_column, ''') ')) as filter_value,\n\t\td.identified_table\n\tFROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_RULESET_TABLE')} d \n\t\tCROSS APPLY OPENJSON(d.assigned_algorithm) kc\n\tWHERE\n\t\tISJSON(assigned_algorithm,ARRAY) = 1\n\t\tAND\n\t\tidentified_table in (\n\t\t\tSELECT identified_table FROM tables_requiring_filters\n\t\t)\n\t\tAND JSON_VALUE(kc.value,'$.alias') != 'default'\n),\ndefault_filters AS\n(\n\tSELECT DISTINCT\n\t\t'default' as filter_alias,\n\t\tSTRING_AGG(concat('not(', replace(JSON_VALUE(kc.value, '$.condition'), '@{variables('CONDITIONAL_MASKING_RESERVED_CHARACTER')}', concat('byName(''', d.identified_column, ''')')),')'), ' && ') as filter_value,\n\t\tidentified_table\n\tFROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_RULESET_TABLE')} d \n\t\tCROSS APPLY OPENJSON(d.assigned_algorithm) kc\n\tWHERE\n\t\tISJSON(assigned_algorithm,ARRAY) = 1\n\t\tAND\n\t\tidentified_table in (\n\t\t\tSELECT identified_table FROM tables_requiring_filters\n\t\t)\n\t\tAND JSON_VALUE(kc.value,'$.alias') != 'default'\n\tGROUP BY identified_table\n),\nsources_and_filters AS (\n\tSELECT\n\t\tt.dataset,\n\t\tt.specified_database,\n\t\tt.specified_schema,\n\t\tt.identified_table,\n\t\tf.filter_alias,\n\t\tf.filter_value\n\tFROM tables_requiring_filters t JOIN default_filters f\n\tON t.identified_table = f.identified_table\n\tUNION\n\tSELECT\n\t\tt.dataset,\n\t\tt.specified_database,\n\t\tt.specified_schema,\n\t\tt.identified_table,\n\t\tf.filter_alias,\n\t\tf.filter_value\n\tFROM tables_requiring_filters t JOIN all_filters f\n\tON t.identified_table = f.identified_table\n\tUNION\n\tSELECT\n\t\tdataset,\n\t\tspecified_database,\n\t\tspecified_schema,\n\t\tidentified_table,\n\t\t'',\n\t\t''\n\tFROM tables_not_requiring_filters\n)\nSELECT DISTINCT\n\tdm.source_dataset,\n\tdm.source_database,\n\tdm.source_schema,\n\tdm.source_table,\n\tdm.sink_dataset,\n\tdm.sink_database,\n\tdm.sink_schema,\n\tdm.sink_table,\n\trs.filter_alias,\n\trs.filter_value\nFROM\n\tsources_and_filters rs\n\tJOIN @{variables('METADATA_SCHEMA')}.@{variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')} dm\n\tON (\n\t\trs.dataset = dm.source_dataset AND\n\t\trs.specified_database = dm.source_database AND\n\t\trs.specified_schema = dm.source_schema AND\n\t\trs.identified_table = dm.source_table\n\t)\nWHERE\n\tdm.sink_database = '@{pipeline().parameters.P_SINK_DATABASE}' AND\n\tdm.sink_schema = '@{pipeline().parameters.P_SINK_SCHEMA}'\n\tAND (dm.mapping_complete IS NULL OR dm.mapping_complete = 0)\n\tAND (ISJSON(dm.masked_status) = 0  OR dm.masked_status IS NULL)\nUNION\nSELECT DISTINCT\n\tdm.source_dataset,\n\tdm.source_database,\n\tdm.source_schema,\n\tdm.source_table,\n\tdm.sink_dataset,\n\tdm.sink_database,\n\tdm.sink_schema,\n\tdm.sink_table,\n\trs.filter_alias,\n\trs.filter_value\nFROM\n\tsources_and_filters rs\n\tJOIN @{variables('METADATA_SCHEMA')}.@{variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')} dm\n\tCROSS APPLY OPENJSON(dm.masked_status) kc\n\tON (\n\t\trs.dataset = dm.source_dataset AND\n\t\trs.specified_database = dm.source_database AND\n\t\trs.specified_schema = dm.source_schema AND\n\t\trs.identified_table = dm.source_table\n\t)\nWHERE\n\tdm.sink_database = '@{pipeline().parameters.P_SINK_DATABASE}' AND\n\tdm.sink_schema = '@{pipeline().parameters.P_SINK_SCHEMA}'\n\tAND (dm.mapping_complete IS NULL OR dm.mapping_complete = 0)\n\tAND ISJSON(dm.masked_status) = 1\n\tAND kc.[key] = rs.filter_alias\n    AND kc.[value] = 'false'\n\tAND\t(\n\t\t(filter_alias = 'default' AND  \n\t\t\tidentified_table IN (\n\t\t\t\tSELECT DISTINCT\n\t\t\t\t\tidentified_table\n\t\t\tFROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_RULESET_TABLE')} d\n\t\t\t\tCROSS APPLY OPENJSON(d.assigned_algorithm) kc\n\t\t\tWHERE\n\t\t\t\tISJSON(assigned_algorithm,ARRAY) = 1\n\t\t\t\tAND JSON_VALUE(kc.value, '$.alias') = 'default'\n\t\t\t)\n\t\t)\n\t\tOR\n\t\t(filter_alias != 'default')\n\t)\n",
                  "type": "Expression"
                },
                "queryTimeout": "02:00:00",
                "partitionOption": "None"
              },
              "dataset": {
                "referenceName": "dcsazure_Snowflake_to_Snowflake_mask_metadata_ds",
                "type": "DatasetReference",
                "parameters": {
                  "DS_METADATA_SCHEMA": {
                    "value": "@variables('METADATA_SCHEMA')",
                    "type": "Expression"
                  },
                  "DS_METADATA_TABLE": {
                    "value": "@variables('METADATA_RULESET_TABLE')",
                    "type": "Expression"
                  }
                }
              },
              "firstRowOnly": false
            }
          },
          {
            "name": "For Each Table To Mask",
            "type": "ForEach",
            "dependsOn": [
              {
                "activity": "Configure Masked Status",
                "dependencyConditions": [
                  "Succeeded"
                ]
              }
            ],
            "userProperties": [],
            "typeProperties": {
              "items": {
                "value": "@activity('Select Tables That Require Masking').output.value",
                "type": "Expression"
              },
              "isSequential": false,
              "activities": [
                {
                  "name": "Check For Conditional Masking",
                  "description": "Identify whether the table needs to be masked with conditional masking",
                  "type": "IfCondition",
                  "dependsOn": [],
                  "userProperties": [],
                  "typeProperties": {
                    "expression": {
                      "value": "@greater(length(item().filter_alias),0)",
                      "type": "Expression"
                    },
                    "ifFalseActivities": [
                      {
                        "name": "Get Masking Parameters No Filter",
                        "description": "Get parameters needed for masking this table that has no conditional masking",
                        "type": "ExecuteDataFlow",
                        "dependsOn": [],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "dataflow": {
                            "referenceName": "dcsazure_Snowflake_to_Snowflake_unfiltered_mask_params_df",
                            "type": "DataFlowReference",
                            "parameters": {
                              "runId": {
                                "value": "'@{pipeline().RunId}'",
                                "type": "Expression"
                              },
                              "DF_METADATA_SCHEMA": {
                                "value": "'@{variables('METADATA_SCHEMA')}'",
                                "type": "Expression"
                              },
                              "DF_METADATA_RULESET_TABLE": {
                                "value": "'@{variables('METADATA_RULESET_TABLE')}'",
                                "type": "Expression"
                              },
                              "DF_METADATA_ADF_TYPE_MAPPING_TABLE": {
                                "value": "'@{variables('METADATA_ADF_TYPE_MAPPING_TABLE')}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_DATABASE": {
                                "value": "'@{item().source_database}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_SCHEMA": {
                                "value": "'@{item().source_schema}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_TABLE": {
                                "value": "'@{item().source_table}'",
                                "type": "Expression"
                              },
                              "DF_COLUMN_WIDTH_ESTIMATE": {
                                "value": "@variables('COLUMN_WIDTH_ESTIMATE')",
                                "type": "Expression"
                              },
                              "DF_DATASET": {
                                "value": "'@{item().source_dataset}'",
                                "type": "Expression"
                              }
                            },
                            "datasetParameters": {
                              "Ruleset": {},
                              "TypeMapping": {},
                              "MaskingParameterOutput": {}
                            }
                          },
                          "staging": {},
                          "compute": {
                            "coreCount": 8,
                            "computeType": "General"
                          },
                          "traceLevel": "None",
                          "cacheSinks": {}
                        }
                      },
                      {
                        "name": "Perform Masking Per Table No Filter",
                        "type": "ExecuteDataFlow",
                        "dependsOn": [
                          {
                            "activity": "Get Masking Parameters No Filter",
                            "dependencyConditions": [
                              "Succeeded"
                            ]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "dataflow": {
                            "referenceName": "dcsazure_Snowflake_to_Snowflake_unfiltered_mask_df",
                            "type": "DataFlowReference",
                            "parameters": {
                              "runId": {
                                "value": "'@{pipeline().RunId}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_SCHEMA": {
                                "value": "'@{item().source_schema}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_TABLE": {
                                "value": "'@{item().source_table}'",
                                "type": "Expression"
                              },
                              "DF_SINK_SCHEMA": {
                                "value": "'@{item().sink_schema}'",
                                "type": "Expression"
                              },
                              "DF_SINK_TABLE": {
                                "value": "'@{item().sink_table}'",
                                "type": "Expression"
                              },
                              "DF_FIELD_ALGORITHM_ASSIGNMENT": {
                                "value": "'@{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].FieldAlgorithmAssignments}'",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_MASK": {
                                "value": "@activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToMask",
                                "type": "Expression"
                              },
                              "DF_BODY_TYPE_MAPPING": {
                                "value": "@activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].DataFactoryTypeMapping",
                                "type": "Expression"
                              },
                              "DF_NUMBER_OF_BATCHES": {
                                "value": "@activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].NumberOfBatches",
                                "type": "Expression"
                              },
                              "DF_TRIM_LENGTHS": {
                                "value": "@activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].TrimLengths",
                                "type": "Expression"
                              },
                              "DF_FAIL_ON_NONCONFORMANT_DATA": {
                                "value": "@pipeline().parameters.P_FAIL_ON_NONCONFORMANT_DATA",
                                "type": "Expression"
                              },
                              "DF_FIELD_DATE_FORMAT": {
                                "value": "'@{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].DateFormatAssignments}'",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_AS_STRINGS": {
                                "value": "@activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastAsStrings",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_BACK_TO_BINARY": {
                                "value": "@activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToBinary",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_BACK_TO_BOOLEAN": {
                                "value": "@activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToBoolean",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_BACK_TO_DATE": {
                                "value": "@activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToDate",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_BACK_TO_DOUBLE": {
                                "value": "@activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToDouble",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_BACK_TO_FLOAT": {
                                "value": "@activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToFloat",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_BACK_TO_INTEGER": {
                                "value": "@activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToInteger",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_BACK_TO_LONG": {
                                "value": "@activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToLong",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_BACK_TO_TIMESTAMP": {
                                "value": "@activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToTimestamp",
                                "type": "Expression"
                              }
                            },
                            "datasetParameters": {
                              "Source": {},
                              "Sink": {}
                            },
                            "linkedServiceParameters": {
                              "Source": {
                                "linkedService": {
                                  "LS_DATABASE": {
                                    "value": "@pipeline().parameters.P_SOURCE_DATABASE",
                                    "type": "Expression"
                                  },
                                  "LS_WAREHOUSE": {
                                    "value": "@variables('SOURCE_SNOWFLAKE_WAREHOUSE')",
                                    "type": "Expression"
                                  },
                                  "LS_ROLE": {
                                    "value": "@variables('SOURCE_SNOWFLAKE_ROLE')",
                                    "type": "Expression"
                                  }
                                }
                              },
                              "Sink": {
                                "linkedService": {
                                  "LS_DATABASE": {
                                    "value": "@pipeline().parameters.P_SINK_DATABASE",
                                    "type": "Expression"
                                  },
                                  "LS_WAREHOUSE": {
                                    "value": "@variables('SINK_SNOWFLAKE_WAREHOUSE')",
                                    "type": "Expression"
                                  },
                                  "LS_ROLE": {
                                    "value": "@variables('SINK_SNOWFLAKE_ROLE')",
                                    "type": "Expression"
                                  }
                                }
                              }
                            }
                          },
                          "staging": {},
                          "compute": {
                            "coreCount": 8,
                            "computeType": "General"
                          },
                          "traceLevel": "None",
                          "cacheSinks": {}
                        }
                      },
                      {
                        "name": "Fail After Updating Masked State No Filter",
                        "type": "Fail",
                        "dependsOn": [
                          {
                            "activity": "Update Masked State No Filter Failed",
                            "dependencyConditions": [
                              "Succeeded"
                            ]
                          }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                          "message": {
                            "value": "Failed to mask @{item().source_table}",
                            "type": "Expression"
                          },
                          "errorCode": "500"
                        }
                      },
                      {
                        "name": "Update Masked State No Filter",
                        "type": "SqlServerStoredProcedure",
                        "dependsOn": [
                          {
                            "activity": "Perform Masking Per Table No Filter",
                            "dependencyConditions": [
                              "Succeeded"
                            ]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "storedProcedureName": {
                            "value": "@{variables('METADATA_SCHEMA')}.@{variables('METADATA_EVENT_PROCEDURE_NAME')}",
                            "type": "Expression"
                          },
                          "storedProcedureParameters": {
                            "activity_run_id": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table No Filter').ActivityRunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "error_message": {
                              "value": null,
                              "type": "String"
                            },
                            "execution_end_time": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table No Filter').ExecutionEndTime",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "execution_start_time": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table No Filter').ExecutionStartTime",
                                "type": "Expression"
                              },
                              "type": "DateTime"
                            },
                            "filter_alias": {
                              "value": null,
                              "type": "String"
                            },
                            "filter_condition": {
                              "value": null,
                              "type": "String"
                            },
                            "input_parameters": {
                              "value": {
                                "value": "{\n    \"DF_FIELD_ALGORITHM_ASSIGNMENT\": \"@{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].FieldAlgorithmAssignments}\",\n    \"DF_COLUMNS_TO_MASK\": @{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToMask},\n    \"DF_BODY_TYPE_MAPPING\": \"@{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].DataFactoryTypeMapping}\",\n    \"DF_TRIM_LENGTHS\": @{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].TrimLengths},\n    \"DF_FAIL_ON_NONCONFORMANT_DATA\": @{pipeline().parameters.P_FAIL_ON_NONCONFORMANT_DATA},\n    \"DF_FIELD_DATE_FORMAT\": \"@{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].DateFormatAssignments}\",\n    \"DF_NUMBER_OF_BATCHES\":\"@{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].NumberOfBatches}\",\n    \"DF_COLUMNS_TO_CAST_AS_STRINGS\": @{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastAsStrings},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_BINARY\": @{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToBinary},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_BOOLEAN\": @{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToBoolean},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_DATE\": @{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToDate},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_DOUBLE\": @{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToDouble},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_FLOAT\": @{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToFloat},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_INTEGER\": @{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToInteger},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_LONG\": @{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToLong},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_TIMESTAMP\": @{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToTimestamp}\n}",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "is_masking_activity": {
                              "value": "true",
                              "type": "Boolean"
                            },
                            "pipeline_name": {
                              "value": {
                                "value": "@pipeline().Pipeline",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "pipeline_run_id": {
                              "value": {
                                "value": "@pipeline().RunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "pipeline_success": {
                              "value": "true",
                              "type": "Boolean"
                            },
                            "sink_database": {
                              "value": {
                                "value": "@item().sink_database",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "sink_schema": {
                              "value": {
                                "value": "@item().sink_schema",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_table": {
                              "value": {
                                "value": "@item().sink_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_database": {
                              "value": {
                                "value": "@item().source_database",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "source_schema": {
                              "value": {
                                "value": "@item().source_schema",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_table": {
                              "value": {
                                "value": "@item().source_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            }
                          }
                        },
                        "linkedServiceName": {
                          "referenceName": "[parameters('Metadata Datastore')]",
                          "type": "LinkedServiceReference"
                        }
                      },
                      {
                        "name": "Update Masked State No Filter Failed",
                        "type": "SqlServerStoredProcedure",
                        "dependsOn": [
                          {
                            "activity": "Perform Masking Per Table No Filter",
                            "dependencyConditions": [
                              "Failed"
                            ]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "storedProcedureName": {
                            "value": "@{variables('METADATA_SCHEMA')}.@{variables('METADATA_EVENT_PROCEDURE_NAME')}",
                            "type": "Expression"
                          },
                          "storedProcedureParameters": {
                            "activity_run_id": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table No Filter').ActivityRunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "error_message": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table No Filter').Error.message",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "execution_end_time": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table No Filter').ExecutionEndTime",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "execution_start_time": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table No Filter').ExecutionStartTime",
                                "type": "Expression"
                              },
                              "type": "DateTime"
                            },
                            "filter_alias": {
                              "value": null,
                              "type": "String"
                            },
                            "filter_condition": {
                              "value": null,
                              "type": "String"
                            },
                            "input_parameters": {
                              "value": {
                                "value": "{\n    \"DF_FIELD_ALGORITHM_ASSIGNMENT\": \"@{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].FieldAlgorithmAssignments}\",\n    \"DF_COLUMNS_TO_MASK\": @{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToMask},\n    \"DF_BODY_TYPE_MAPPING\": \"@{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].DataFactoryTypeMapping}\",\n    \"DF_TRIM_LENGTHS\": @{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].TrimLengths},\n    \"DF_FAIL_ON_NONCONFORMANT_DATA\": @{pipeline().parameters.P_FAIL_ON_NONCONFORMANT_DATA},\n    \"DF_FIELD_DATE_FORMAT\": \"@{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].DateFormatAssignments}\",\n    \"DF_NUMBER_OF_BATCHES\":\"@{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].NumberOfBatches}\",\n    \"DF_COLUMNS_TO_CAST_AS_STRINGS\": @{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastAsStrings},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_BINARY\": @{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToBinary},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_BOOLEAN\": @{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToBoolean},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_DATE\": @{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToDate},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_DOUBLE\": @{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToDouble},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_FLOAT\": @{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToFloat},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_INTEGER\": @{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToInteger},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_LONG\": @{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToLong},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_TIMESTAMP\": @{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToTimestamp}\n}",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "is_masking_activity": {
                              "value": "true",
                              "type": "Boolean"
                            },
                            "pipeline_name": {
                              "value": {
                                "value": "@pipeline().Pipeline",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "pipeline_run_id": {
                              "value": {
                                "value": "@pipeline().RunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "pipeline_success": {
                              "value": "false",
                              "type": "Boolean"
                            },
                            "sink_database": {
                              "value": {
                                "value": "@item().sink_database",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "sink_schema": {
                              "value": {
                                "value": "@item().sink_schema",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_table": {
                              "value": {
                                "value": "@item().sink_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_database": {
                              "value": {
                                "value": "@item().source_database",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "source_schema": {
                              "value": {
                                "value": "@item().source_schema",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_table": {
                              "value": {
                                "value": "@item().source_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            }
                          }
                        },
                        "linkedServiceName": {
                          "referenceName": "[parameters('Metadata Datastore')]",
                          "type": "LinkedServiceReference"
                        }
                      }
                    ],
                    "ifTrueActivities": [
                      {
                        "name": "Get Masking Parameters With Filter",
                        "description": "Get parameters needed for masking this table with the conditional masking filter",
                        "type": "ExecuteDataFlow",
                        "dependsOn": [],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "dataflow": {
                            "referenceName": "dcsazure_Snowflake_to_Snowflake_filtered_mask_params_df",
                            "type": "DataFlowReference",
                            "parameters": {
                              "runId": {
                                "value": "'@{pipeline().RunId}'",
                                "type": "Expression"
                              },
                              "DF_METADATA_SCHEMA": {
                                "value": "'@{variables('METADATA_SCHEMA')}'",
                                "type": "Expression"
                              },
                              "DF_METADATA_RULESET_TABLE": {
                                "value": "'@{variables('METADATA_RULESET_TABLE')}'",
                                "type": "Expression"
                              },
                              "DF_METADATA_ADF_TYPE_MAPPING_TABLE": {
                                "value": "'@{variables('METADATA_ADF_TYPE_MAPPING_TABLE')}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_DATABASE": {
                                "value": "'@{item().source_database}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_SCHEMA": {
                                "value": "'@{item().source_schema}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_TABLE": {
                                "value": "'@{item().source_table}'",
                                "type": "Expression"
                              },
                              "DF_COLUMN_WIDTH_ESTIMATE": {
                                "value": "@variables('COLUMN_WIDTH_ESTIMATE')",
                                "type": "Expression"
                              },
                              "DF_FILTER_KEY": {
                                "value": "'@{item().filter_alias}'",
                                "type": "Expression"
                              },
                              "DF_DATASET": {
                                "value": "'@{item().source_dataset}'",
                                "type": "Expression"
                              }
                            },
                            "datasetParameters": {
                              "Ruleset": {},
                              "TypeMapping": {},
                              "MaskingParameterOutput": {}
                            }
                          },
                          "staging": {},
                          "compute": {
                            "coreCount": 8,
                            "computeType": "General"
                          },
                          "traceLevel": "None",
                          "cacheSinks": {
                            "firstRowOnly": true
                          }
                        }
                      },
                      {
                        "name": "Perform Masking Per Table With Filter",
                        "description": "Perform masking for the part of this table that satisfies the specified filter",
                        "type": "ExecuteDataFlow",
                        "dependsOn": [
                          {
                            "activity": "Get Masking Parameters With Filter",
                            "dependencyConditions": [
                              "Succeeded"
                            ]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "dataflow": {
                            "referenceName": "dcsazure_Snowflake_to_Snowflake_filtered_mask_df",
                            "type": "DataFlowReference",
                            "parameters": {
                              "runId": {
                                "value": "'@{pipeline().RunId}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_SCHEMA": {
                                "value": "'@{item().source_schema}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_TABLE": {
                                "value": "'@{item().source_table}'",
                                "type": "Expression"
                              },
                              "DF_SINK_SCHEMA": {
                                "value": "'@{item().sink_schema}'",
                                "type": "Expression"
                              },
                              "DF_SINK_TABLE": {
                                "value": "'@{item().sink_table}'",
                                "type": "Expression"
                              },
                              "DF_FIELD_ALGORITHM_ASSIGNMENT": {
                                "value": "'@{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].FieldAlgorithmAssignments}'",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_MASK": {
                                "value": "@activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToMask",
                                "type": "Expression"
                              },
                              "DF_BODY_TYPE_MAPPING": {
                                "value": "@activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].DataFactoryTypeMapping",
                                "type": "Expression"
                              },
                              "DF_TRIM_LENGTHS": {
                                "value": "@activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].TrimLengths",
                                "type": "Expression"
                              },
                              "DF_FAIL_ON_NONCONFORMANT_DATA": {
                                "value": "@pipeline().parameters.P_FAIL_ON_NONCONFORMANT_DATA",
                                "type": "Expression"
                              },
                              "DF_FIELD_DATE_FORMAT": {
                                "value": "'@{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].DateFormatAssignments}'",
                                "type": "Expression"
                              },
                              "DF_FILTER_CONDITION": {
                                "value": "@item().filter_value ",
                                "type": "Expression"
                              },
                              "DF_NUMBER_OF_ROWS_PER_BATCH": {
                                "value": "@variables('TARGET_BATCH_SIZE')",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_AS_STRINGS": {
                                "value": "@activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastAsStrings",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_BACK_TO_BINARY": {
                                "value": "@activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToBinary",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_BACK_TO_BOOLEAN": {
                                "value": "@activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToBoolean",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_BACK_TO_DATE": {
                                "value": "@activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToDate",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_BACK_TO_DOUBLE": {
                                "value": "@activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToDouble",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_BACK_TO_FLOAT": {
                                "value": "@activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToFloat",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_BACK_TO_INTEGER": {
                                "value": "@activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToInteger",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_BACK_TO_LONG": {
                                "value": "@activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToLong",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_BACK_TO_TIMESTAMP": {
                                "value": "@activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToTimestamp",
                                "type": "Expression"
                              }
                            },
                            "datasetParameters": {
                              "Source": {},
                              "Sink": {}
                            },
                            "linkedServiceParameters": {
                              "Source": {
                                "linkedService": {
                                  "LS_DATABASE": {
                                    "value": "@pipeline().parameters.P_SOURCE_DATABASE",
                                    "type": "Expression"
                                  },
                                  "LS_WAREHOUSE": {
                                    "value": "@variables('SOURCE_SNOWFLAKE_WAREHOUSE')",
                                    "type": "Expression"
                                  },
                                  "LS_ROLE": {
                                    "value": "@variables('SOURCE_SNOWFLAKE_ROLE')",
                                    "type": "Expression"
                                  }
                                }
                              },
                              "Sink": {
                                "linkedService": {
                                  "LS_DATABASE": {
                                    "value": "@pipeline().parameters.P_SINK_DATABASE",
                                    "type": "Expression"
                                  },
                                  "LS_WAREHOUSE": {
                                    "value": "@variables('SINK_SNOWFLAKE_WAREHOUSE')",
                                    "type": "Expression"
                                  },
                                  "LS_ROLE": {
                                    "value": "@variables('SINK_SNOWFLAKE_ROLE')",
                                    "type": "Expression"
                                  }
                                }
                              }
                            }
                          },
                          "staging": {},
                          "compute": {
                            "coreCount": 8,
                            "computeType": "General"
                          },
                          "traceLevel": "Fine"
                        }
                      },
                      {
                        "name": "Update Masked State With Filter",
                        "type": "SqlServerStoredProcedure",
                        "dependsOn": [
                          {
                            "activity": "Perform Masking Per Table With Filter",
                            "dependencyConditions": [
                              "Succeeded"
                            ]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "storedProcedureName": {
                            "value": "@{variables('METADATA_SCHEMA')}.@{variables('METADATA_EVENT_PROCEDURE_NAME')}",
                            "type": "Expression"
                          },
                          "storedProcedureParameters": {
                            "activity_run_id": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table With Filter').ActivityRunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "error_message": {
                              "value": null,
                              "type": "String"
                            },
                            "execution_end_time": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table With Filter').ExecutionEndTime",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "execution_start_time": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table With Filter').ExecutionStartTime",
                                "type": "Expression"
                              },
                              "type": "DateTime"
                            },
                            "filter_alias": {
                              "value": {
                                "value": "@item().filter_alias",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "filter_condition": {
                              "value": {
                                "value": "@item().filter_value",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "input_parameters": {
                              "value": {
                                "value": "{\n    \"DF_FIELD_ALGORITHM_ASSIGNMENT\": \"@{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].FieldAlgorithmAssignments}\",\n    \"DF_COLUMNS_TO_MASK\": @{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToMask},\n    \"DF_BODY_TYPE_MAPPING\": \"@{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].DataFactoryTypeMapping}\",\n    \"DF_TRIM_LENGTHS\": @{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].TrimLengths},\n    \"DF_FAIL_ON_NONCONFORMANT_DATA\": @{pipeline().parameters.P_FAIL_ON_NONCONFORMANT_DATA},\n    \"DF_FIELD_DATE_FORMAT\": \"@{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].DateFormatAssignments}\",\n    \"DF_NUMBER_OF_ROWS_PER_BATCH\": @{variables('TARGET_BATCH_SIZE')},\n    \"DF_COLUMNS_TO_CAST_AS_STRINGS\": @{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastAsStrings},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_BINARY\": @{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToBinary},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_BOOLEAN\": @{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToBoolean},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_DATE\": @{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToDate},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_DOUBLE\": @{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToDouble},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_FLOAT\": @{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToFloat},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_INTEGER\": @{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToInteger},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_LONG\": @{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToLong},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_TIMESTAMP\": @{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToTimestamp}\n}",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "is_masking_activity": {
                              "value": "true",
                              "type": "Boolean"
                            },
                            "pipeline_name": {
                              "value": {
                                "value": "@pipeline().Pipeline",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "pipeline_run_id": {
                              "value": {
                                "value": "@pipeline().RunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "pipeline_success": {
                              "value": "true",
                              "type": "Boolean"
                            },
                            "sink_database": {
                              "value": {
                                "value": "@item().sink_database",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "sink_schema": {
                              "value": {
                                "value": "@item().sink_schema",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_table": {
                              "value": {
                                "value": "@item().sink_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_database": {
                              "value": {
                                "value": "@item().source_database",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "source_schema": {
                              "value": {
                                "value": "@item().source_schema",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_table": {
                              "value": {
                                "value": "@item().source_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            }
                          }
                        },
                        "linkedServiceName": {
                          "referenceName": "[parameters('Metadata Datastore')]",
                          "type": "LinkedServiceReference"
                        }
                      },
                      {
                        "name": "Fail After Updating Masked State With Filter",
                        "type": "Fail",
                        "dependsOn": [
                          {
                            "activity": "Update Masked State With Filter Failed",
                            "dependencyConditions": [
                              "Succeeded"
                            ]
                          }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                          "message": {
                            "value": "Failed to mask @{item().source_table} with filter alias @{item().filter_alias}",
                            "type": "Expression"
                          },
                          "errorCode": "500"
                        }
                      },
                      {
                        "name": "Update Masked State With Filter Failed",
                        "type": "SqlServerStoredProcedure",
                        "dependsOn": [
                          {
                            "activity": "Perform Masking Per Table With Filter",
                            "dependencyConditions": [
                              "Failed"
                            ]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "storedProcedureName": {
                            "value": "@{variables('METADATA_SCHEMA')}.@{variables('METADATA_EVENT_PROCEDURE_NAME')}",
                            "type": "Expression"
                          },
                          "storedProcedureParameters": {
                            "activity_run_id": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table With Filter').ActivityRunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "error_message": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table With Filter').Error.message",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "execution_end_time": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table With Filter').ExecutionEndTime",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "execution_start_time": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table With Filter').ExecutionStartTime",
                                "type": "Expression"
                              },
                              "type": "DateTime"
                            },
                            "filter_alias": {
                              "value": {
                                "value": "@item().filter_alias",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "filter_condition": {
                              "value": {
                                "value": "@item().filter_value",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "input_parameters": {
                              "value": {
                                "value": "{\n    \"DF_FIELD_ALGORITHM_ASSIGNMENT\": \"@{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].FieldAlgorithmAssignments}\",\n    \"DF_COLUMNS_TO_MASK\": @{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToMask},\n    \"DF_BODY_TYPE_MAPPING\": \"@{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].DataFactoryTypeMapping}\",\n    \"DF_TRIM_LENGTHS\": @{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].TrimLengths},\n    \"DF_FAIL_ON_NONCONFORMANT_DATA\": @{pipeline().parameters.P_FAIL_ON_NONCONFORMANT_DATA},\n    \"DF_FIELD_DATE_FORMAT\": \"@{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].DateFormatAssignments}\",\n    \"DF_NUMBER_OF_ROWS_PER_BATCH\": @{variables('TARGET_BATCH_SIZE')},\n    \"DF_COLUMNS_TO_CAST_AS_STRINGS\": @{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastAsStrings},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_BINARY\": @{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToBinary},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_BOOLEAN\": @{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToBoolean},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_DATE\": @{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToDate},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_DOUBLE\": @{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToDouble},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_FLOAT\": @{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToFloat},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_INTEGER\": @{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToInteger},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_LONG\": @{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToLong},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_TIMESTAMP\": @{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToCastBackToTimestamp}\n}",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "is_masking_activity": {
                              "value": "true",
                              "type": "Boolean"
                            },
                            "pipeline_name": {
                              "value": {
                                "value": "@pipeline().Pipeline",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "pipeline_run_id": {
                              "value": {
                                "value": "@pipeline().RunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "pipeline_success": {
                              "value": "false",
                              "type": "Boolean"
                            },
                            "sink_database": {
                              "value": {
                                "value": "@item().sink_database",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "sink_schema": {
                              "value": {
                                "value": "@item().sink_schema",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_table": {
                              "value": {
                                "value": "@item().sink_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_database": {
                              "value": {
                                "value": "@item().source_database",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "source_schema": {
                              "value": {
                                "value": "@item().source_schema",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_table": {
                              "value": {
                                "value": "@item().source_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            }
                          }
                        },
                        "linkedServiceName": {
                          "referenceName": "[parameters('Metadata Datastore')]",
                          "type": "LinkedServiceReference"
                        }
                      }
                    ]
                  }
                }
              ]
            }
          },
          {
            "name": "Select Tables Without Required Masking",
            "type": "Lookup",
            "dependsOn": [
              {
                "activity": "For Each Table To Truncate",
                "dependencyConditions": [
                  "Succeeded"
                ]
              }
            ],
            "policy": {
              "timeout": "0.12:00:00",
              "retry": 0,
              "retryIntervalInSeconds": 30,
              "secureOutput": false,
              "secureInput": false
            },
            "userProperties": [],
            "typeProperties": {
              "source": {
                "type": "AzureSqlSource",
                "sqlReaderQuery": {
                  "value": "SELECT DISTINCT\n    source_schema,\n    source_database,\n    source_table,\n    sink_schema,\n    sink_database,\n    sink_table\nFROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')} dm\nWHERE\nUPPER(source_dataset) = UPPER('@{variables('DATASET')}')\nAND UPPER(sink_dataset) = UPPER('@{variables('DATASET')}')\nAND UPPER(source_database) = UPPER('@{pipeline().parameters.P_SOURCE_DATABASE}')\nAND UPPER(sink_database) = UPPER('@{pipeline().parameters.P_SINK_DATABASE}')\nAND UPPER(source_schema) = UPPER('@{pipeline().parameters.P_SOURCE_SCHEMA}')\nAND UPPER(sink_schema) = UPPER('@{pipeline().parameters.P_SINK_SCHEMA}')\nAND (dm.mapping_complete IS NULL OR dm.mapping_complete = 0)\nEXCEPT\nSELECT DISTINCT\n    source_schema,\n    source_database,\n    source_table,\n    sink_schema,\n    sink_database,\n    sink_table\nFROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_RULESET_TABLE')} dd\nJOIN @{variables('METADATA_SCHEMA')}.@{variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')} dm\nON (\n    UPPER(dm.source_database) = UPPER(dd.specified_database)\n    AND UPPER(dm.source_schema) = UPPER(dd.specified_schema)\n    AND UPPER(dm.source_table) = UPPER(dd.identified_table)\n)\nWHERE\n    UPPER(dd.dataset) = UPPER('@{variables('DATASET')}')\n    AND UPPER(dm.source_dataset) = UPPER('@{variables('DATASET')}')\n    AND UPPER(dm.sink_dataset) = UPPER('@{variables('DATASET')}')\n    AND dd.assigned_algorithm IS NOT NULL\n    AND dd.assigned_algorithm != ''\n    AND UPPER(dm.source_database) = UPPER('@{pipeline().parameters.P_SOURCE_DATABASE}')\n    AND UPPER(dm.sink_database) = UPPER('@{pipeline().parameters.P_SINK_DATABASE}')\n    AND UPPER(dm.source_schema) = UPPER('@{pipeline().parameters.P_SOURCE_SCHEMA}')\n    AND UPPER(dm.sink_schema) = UPPER('@{pipeline().parameters.P_SINK_SCHEMA}');",
                  "type": "Expression"
                },
                "queryTimeout": "02:00:00",
                "partitionOption": "None"
              },
              "dataset": {
                "referenceName": "dcsazure_Snowflake_to_Snowflake_mask_metadata_ds",
                "type": "DatasetReference",
                "parameters": {
                  "DS_METADATA_SCHEMA": {
                    "value": "@variables('METADATA_SCHEMA')",
                    "type": "Expression"
                  },
                  "DS_METADATA_TABLE": {
                    "value": "@variables('METADATA_RULESET_TABLE')",
                    "type": "Expression"
                  }
                }
              },
              "firstRowOnly": false
            }
          },
          {
            "name": "Filter If Copy Unmasked Enabled",
            "type": "Filter",
            "dependsOn": [
              {
                "activity": "Select Tables Without Required Masking",
                "dependencyConditions": [
                  "Succeeded"
                ]
              }
            ],
            "userProperties": [],
            "typeProperties": {
              "items": {
                "value": "@activity('Select Tables Without Required Masking').output.value",
                "type": "Expression"
              },
              "condition": {
                "value": "@pipeline().parameters.P_COPY_UNMASKED_TABLES",
                "type": "Expression"
              }
            }
          },
          {
            "name": "For Each Table With No Masking",
            "type": "ForEach",
            "dependsOn": [
              {
                "activity": "Filter If Copy Unmasked Enabled",
                "dependencyConditions": [
                  "Succeeded"
                ]
              }
            ],
            "userProperties": [],
            "typeProperties": {
              "items": {
                "value": "@activity('Filter If Copy Unmasked Enabled').output.value",
                "type": "Expression"
              },
              "isSequential": false,
              "activities": [
                {
                  "name": "If Copy Via Dataflow",
                  "description": "Determine if we should copy using a dataflow activity or a copy activity",
                  "type": "IfCondition",
                  "dependsOn": [],
                  "userProperties": [],
                  "typeProperties": {
                    "expression": {
                      "value": "@pipeline().parameters.P_COPY_USE_DATAFLOW",
                      "type": "Expression"
                    },
                    "ifFalseActivities": [
                      {
                        "name": "Copy Unmasked Data",
                        "type": "Copy",
                        "dependsOn": [],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "source": {
                            "type": "SnowflakeV2Source",
                            "exportSettings": {
                              "type": "SnowflakeExportCopyCommand"
                            }
                          },
                          "sink": {
                            "type": "SnowflakeV2Sink",
                            "importSettings": {
                              "type": "SnowflakeImportCopyCommand"
                            }
                          },
                          "enableStaging": true,
                          "stagingSettings": {
                            "linkedServiceName": {
                              "referenceName": "[parameters('BlobStoreStagingArea')]",
                              "type": "LinkedServiceReference"
                            },
                            "path": {
                              "value": "@variables('STAGING_STORAGE_PATH')",
                              "type": "Expression"
                            }
                          }
                        },
                        "inputs": [
                          {
                            "referenceName": "dcsazure_Snowflake_to_Snowflake_mask_source_ds",
                            "type": "DatasetReference",
                            "parameters": {
                              "DS_SCHEMA": "@item().source_schema",
                              "DS_TABLE": "@item().source_table",
                              "DS_DATABASE": {
                                "value": "@pipeline().parameters.P_SOURCE_DATABASE",
                                "type": "Expression"
                              },
                              "DS_WAREHOUSE": {
                                "value": "@variables('SOURCE_SNOWFLAKE_WAREHOUSE')",
                                "type": "Expression"
                              },
                              "DS_ROLE": {
                                "value": "@variables('SOURCE_SNOWFLAKE_ROLE')",
                                "type": "Expression"
                              }
                            }
                          }
                        ],
                        "outputs": [
                          {
                            "referenceName": "dcsazure_Snowflake_to_Snowflake_mask_sink_ds",
                            "type": "DatasetReference",
                            "parameters": {
                              "DS_SCHEMA": "@item().sink_schema",
                              "DS_TABLE": "@item().sink_table",
                              "DS_DATABASE": {
                                "value": "@pipeline().parameters.P_SOURCE_DATABASE",
                                "type": "Expression"
                              },
                              "DS_WAREHOUSE": {
                                "value": "@variables('SINK_SNOWFLAKE_WAREHOUSE')",
                                "type": "Expression"
                              },
                              "DS_ROLE": {
                                "value": "@variables('SINK_SNOWFLAKE_ROLE')",
                                "type": "Expression"
                              }
                            }
                          }
                        ]
                      },
                      {
                        "name": "Fail After Updating Copy State",
                        "type": "Fail",
                        "dependsOn": [
                          {
                            "activity": "Update Copy State Failed",
                            "dependencyConditions": [
                              "Succeeded"
                            ]
                          }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                          "message": {
                            "value": "Failed to copy @{item().source_table}",
                            "type": "Expression"
                          },
                          "errorCode": "500"
                        }
                      },
                      {
                        "name": "Update Copy State",
                        "type": "SqlServerStoredProcedure",
                        "dependsOn": [
                          {
                            "activity": "Copy Unmasked Data",
                            "dependencyConditions": [
                              "Succeeded"
                            ]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "storedProcedureName": {
                            "value": "@{variables('METADATA_SCHEMA')}.@{variables('METADATA_EVENT_PROCEDURE_NAME')}",
                            "type": "Expression"
                          },
                          "storedProcedureParameters": {
                            "activity_run_id": {
                              "value": {
                                "value": "@activity('Copy Unmasked Data').ActivityRunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "error_message": {
                              "value": null,
                              "type": "String"
                            },
                            "execution_end_time": {
                              "value": {
                                "value": "@activity('Copy Unmasked Data').ExecutionEndTime",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "execution_start_time": {
                              "value": {
                                "value": "@activity('Copy Unmasked Data').ExecutionStartTime",
                                "type": "Expression"
                              },
                              "type": "DateTime"
                            },
                            "filter_alias": {
                              "value": null,
                              "type": "String"
                            },
                            "filter_condition": {
                              "value": null,
                              "type": "String"
                            },
                            "input_parameters": {
                              "value": {
                                "value": "{\n    \"P_USE_COPY_DATAFLOW\": @{pipeline().parameters.P_COPY_USE_DATAFLOW}\n}",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "is_masking_activity": {
                              "value": "false",
                              "type": "Boolean"
                            },
                            "pipeline_name": {
                              "value": {
                                "value": "@pipeline().Pipeline",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "pipeline_run_id": {
                              "value": {
                                "value": "@pipeline().RunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "pipeline_success": {
                              "value": "true",
                              "type": "Boolean"
                            },
                            "sink_database": {
                              "value": {
                                "value": "@item().sink_database",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "sink_schema": {
                              "value": {
                                "value": "@item().sink_schema",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_table": {
                              "value": {
                                "value": "@item().sink_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_database": {
                              "value": {
                                "value": "@item().source_database",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "source_schema": {
                              "value": {
                                "value": "@item().source_schema",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_table": {
                              "value": {
                                "value": "@item().source_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            }
                          }
                        },
                        "linkedServiceName": {
                          "referenceName": "[parameters('Metadata Datastore')]",
                          "type": "LinkedServiceReference"
                        }
                      },
                      {
                        "name": "Update Copy State Failed",
                        "type": "SqlServerStoredProcedure",
                        "dependsOn": [
                          {
                            "activity": "Copy Unmasked Data",
                            "dependencyConditions": [
                              "Failed"
                            ]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "storedProcedureName": {
                            "value": "@{variables('METADATA_SCHEMA')}.@{variables('METADATA_EVENT_PROCEDURE_NAME')}",
                            "type": "Expression"
                          },
                          "storedProcedureParameters": {
                            "activity_run_id": {
                              "value": {
                                "value": "@activity('Copy Unmasked Data').ActivityRunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "error_message": {
                              "value": {
                                "value": "@activity('Copy Unmasked Data').Error.message",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "execution_end_time": {
                              "value": {
                                "value": "@activity('Copy Unmasked Data').ExecutionEndTime",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "execution_start_time": {
                              "value": {
                                "value": "@activity('Copy Unmasked Data').ExecutionStartTime",
                                "type": "Expression"
                              },
                              "type": "DateTime"
                            },
                            "filter_alias": {
                              "value": null,
                              "type": "String"
                            },
                            "filter_condition": {
                              "value": null,
                              "type": "String"
                            },
                            "input_parameters": {
                              "value": {
                                "value": "{\n    \"P_USE_COPY_DATAFLOW\": @{pipeline().parameters.P_COPY_USE_DATAFLOW}\n}",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "is_masking_activity": {
                              "value": "false",
                              "type": "Boolean"
                            },
                            "pipeline_name": {
                              "value": {
                                "value": "@pipeline().Pipeline",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "pipeline_run_id": {
                              "value": {
                                "value": "@pipeline().RunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "pipeline_success": {
                              "value": "false",
                              "type": "Boolean"
                            },
                            "sink_database": {
                              "value": {
                                "value": "@item().sink_database",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "sink_schema": {
                              "value": {
                                "value": "@item().sink_schema",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_table": {
                              "value": {
                                "value": "@item().sink_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_database": {
                              "value": {
                                "value": "@item().source_database",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "source_schema": {
                              "value": {
                                "value": "@item().source_schema",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_table": {
                              "value": {
                                "value": "@item().source_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            }
                          }
                        },
                        "linkedServiceName": {
                          "referenceName": "[parameters('Metadata Datastore')]",
                          "type": "LinkedServiceReference"
                        }
                      }
                    ],
                    "ifTrueActivities": [
                      {
                        "name": "Call Copy Dataflow",
                        "type": "ExecuteDataFlow",
                        "dependsOn": [],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "dataflow": {
                            "referenceName": "dcsazure_Snowflake_to_Snowflake_copy_df",
                            "type": "DataFlowReference",
                            "parameters": {
                              "runId": {
                                "value": "'@{pipeline().RunId}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_SCHEMA": {
                                "value": "'@{item().source_schema}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_TABLE": {
                                "value": "'@{item().source_table}'",
                                "type": "Expression"
                              },
                              "DF_SINK_SCHEMA": {
                                "value": "'@{item().sink_schema}'",
                                "type": "Expression"
                              },
                              "DF_SINK_TABLE": {
                                "value": "'@{item().sink_table}'",
                                "type": "Expression"
                              }
                            },
                            "datasetParameters": {
                              "SourceData": {},
                              "SinkData": {}
                            },
                            "linkedServiceParameters": {
                              "SourceData": {
                                "linkedService": {
                                  "LS_DATABASE": {
                                    "value": "@pipeline().parameters.P_SOURCE_DATABASE",
                                    "type": "Expression"
                                  },
                                  "LS_WAREHOUSE": {
                                    "value": "@variables('SOURCE_SNOWFLAKE_WAREHOUSE')",
                                    "type": "Expression"
                                  },
                                  "LS_ROLE": {
                                    "value": "@variables('SOURCE_SNOWFLAKE_ROLE')",
                                    "type": "Expression"
                                  }
                                }
                              },
                              "SinkData": {
                                "linkedService": {
                                  "LS_DATABASE": {
                                    "value": "@pipeline().parameters.P_SINK_DATABASE",
                                    "type": "Expression"
                                  },
                                  "LS_WAREHOUSE": {
                                    "value": "@variables('SINK_SNOWFLAKE_WAREHOUSE')",
                                    "type": "Expression"
                                  },
                                  "LS_ROLE": {
                                    "value": "@variables('SINK_SNOWFLAKE_ROLE')",
                                    "type": "Expression"
                                  }
                                }
                              }
                            }
                          },
                          "staging": {},
                          "compute": {
                            "coreCount": 8,
                            "computeType": "General"
                          },
                          "traceLevel": "None",
                          "cacheSinks": {}
                        }
                      },
                      {
                        "name": "Datflow Update Copy State",
                        "type": "SqlServerStoredProcedure",
                        "dependsOn": [
                          {
                            "activity": "Call Copy Dataflow",
                            "dependencyConditions": [
                              "Succeeded"
                            ]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "storedProcedureName": {
                            "value": "@{variables('METADATA_SCHEMA')}.@{variables('METADATA_EVENT_PROCEDURE_NAME')}",
                            "type": "Expression"
                          },
                          "storedProcedureParameters": {
                            "activity_run_id": {
                              "value": {
                                "value": "@activity('Call Copy Dataflow').ActivityRunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "error_message": {
                              "value": null,
                              "type": "String"
                            },
                            "execution_end_time": {
                              "value": {
                                "value": "@activity('Call Copy Dataflow').ExecutionEndTime",
                                "type": "Expression"
                              },
                              "type": "Datetime"
                            },
                            "execution_start_time": {
                              "value": {
                                "value": "@activity('Call Copy Dataflow').ExecutionStartTime",
                                "type": "Expression"
                              },
                              "type": "DateTime"
                            },
                            "filter_alias": {
                              "value": null,
                              "type": "String"
                            },
                            "filter_condition": {
                              "value": null,
                              "type": "String"
                            },
                            "input_parameters": {
                              "value": {
                                "value": "{\n    \"P_USE_COPY_DATAFLOW\": @{pipeline().parameters.P_COPY_USE_DATAFLOW}\n}",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "is_masking_activity": {
                              "value": "false",
                              "type": "Boolean"
                            },
                            "pipeline_name": {
                              "value": {
                                "value": "@pipeline().Pipeline",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "pipeline_run_id": {
                              "value": {
                                "value": "@pipeline().RunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "pipeline_success": {
                              "value": "true",
                              "type": "Boolean"
                            },
                            "sink_database": {
                              "value": {
                                "value": "@item().sink_database",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "sink_schema": {
                              "value": {
                                "value": "@item().sink_schema",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_table": {
                              "value": {
                                "value": "@item().sink_Table",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_database": {
                              "value": {
                                "value": "@item().source_database",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "source_schema": {
                              "value": {
                                "value": "@item().source_schema",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_table": {
                              "value": {
                                "value": "@item().source_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            }
                          }
                        },
                        "linkedServiceName": {
                          "referenceName": "[parameters('Metadata Datastore')]",
                          "type": "LinkedServiceReference"
                        }
                      },
                      {
                        "name": "Datflow Update Copy State Failed",
                        "type": "SqlServerStoredProcedure",
                        "dependsOn": [
                          {
                            "activity": "Call Copy Dataflow",
                            "dependencyConditions": [
                              "Failed"
                            ]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "storedProcedureName": {
                            "value": "@{variables('METADATA_SCHEMA')}.@{variables('METADATA_EVENT_PROCEDURE_NAME')}",
                            "type": "Expression"
                          },
                          "storedProcedureParameters": {
                            "activity_run_id": {
                              "value": {
                                "value": "@activity('Call Copy Dataflow').ActivityRunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "error_message": {
                              "value": {
                                "value": "@activity('Call Copy Dataflow').Error.message",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "execution_end_time": {
                              "value": {
                                "value": "@activity('Call Copy Dataflow').ExecutionEndTime",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "execution_start_time": {
                              "value": {
                                "value": "@activity('Call Copy Dataflow').ExecutionStartTime",
                                "type": "Expression"
                              },
                              "type": "DateTime"
                            },
                            "filter_alias": {
                              "value": null,
                              "type": "String"
                            },
                            "filter_condition": {
                              "value": null,
                              "type": "String"
                            },
                            "input_parameters": {
                              "value": {
                                "value": "{\n    \"P_USE_COPY_DATAFLOW\": @{pipeline().parameters.P_COPY_USE_DATAFLOW}\n}",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "is_masking_activity": {
                              "value": "false",
                              "type": "Boolean"
                            },
                            "pipeline_name": {
                              "value": {
                                "value": "@pipeline().Pipeline",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "pipeline_run_id": {
                              "value": {
                                "value": "@pipeline().RunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "pipeline_success": {
                              "value": "false",
                              "type": "Boolean"
                            },
                            "sink_database": {
                              "value": {
                                "value": "@item().sink_database",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "sink_schema": {
                              "value": {
                                "value": "@item().sink_schema",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_table": {
                              "value": {
                                "value": "@item().sink_Table",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_database": {
                              "value": {
                                "value": "@item().source_database",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "source_schema": {
                              "value": {
                                "value": "@item().source_schema",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_table": {
                              "value": {
                                "value": "@item().source_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            }
                          }
                        },
                        "linkedServiceName": {
                          "referenceName": "[parameters('Metadata Datastore')]",
                          "type": "LinkedServiceReference"
                        }
                      },
                      {
                        "name": "Fail After Datflow Updating Copy State",
                        "type": "Fail",
                        "dependsOn": [
                          {
                            "activity": "Datflow Update Copy State Failed",
                            "dependencyConditions": [
                              "Succeeded"
                            ]
                          }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                          "message": {
                            "value": "Failed to copy @{item().source_table}",
                            "type": "Expression"
                          },
                          "errorCode": "500"
                        }
                      }
                    ]
                  }
                }
              ]
            }
          },
          {
            "name": "Test Filter Conditions",
            "description": "Use data preview on Lookup \"Select Tables That Require Masking\" activity to confirm what filter conditions are to be applied. Leverage data preview on this data flow to confirm your filter is working as expected.",
            "type": "ExecuteDataFlow",
            "state": "Inactive",
            "onInactiveMarkAs": "Succeeded",
            "dependsOn": [],
            "policy": {
              "timeout": "0.12:00:00",
              "retry": 0,
              "retryIntervalInSeconds": 30,
              "secureOutput": false,
              "secureInput": false
            },
            "userProperties": [],
            "typeProperties": {
              "dataflow": {
                "referenceName": "dcsazure_Snowflake_to_Snowflake_filter_test_utility_df",
                "type": "DataFlowReference",
                "parameters": {
                  "runId": "''",
                  "DF_SOURCE_SCHEMA": "''",
                  "DF_SOURCE_TABLE": "''",
                  "DF_SINK_SCHEMA": "''",
                  "DF_SINK_TABLE": "''",
                  "DF_FILTER_CONDITION": "true()"
                },
                "datasetParameters": {
                  "SourceData": {},
                  "SinkData": {}
                }
              },
              "staging": {},
              "compute": {
                "coreCount": 8,
                "computeType": "General"
              },
              "traceLevel": "Fine"
            }
          },
          {
            "name": "Check If We Should Reapply Mapping",
            "type": "IfCondition",
            "dependsOn": [],
            "userProperties": [],
            "typeProperties": {
              "expression": {
                "value": "@pipeline().parameters.P_REAPPLY_MAPPING",
                "type": "Expression"
              },
              "ifTrueActivities": [
                {
                  "name": "Mark Table Mapping Incomplete",
                  "description": "Mark all tables in this database and schema as unmapped so that we can re-apply the mapping to them",
                  "type": "Script",
                  "dependsOn": [],
                  "policy": {
                    "timeout": "0.12:00:00",
                    "retry": 0,
                    "retryIntervalInSeconds": 30,
                    "secureOutput": false,
                    "secureInput": false
                  },
                  "userProperties": [],
                  "linkedServiceName": {
                    "referenceName": "[parameters('Metadata Datastore')]",
                    "type": "LinkedServiceReference"
                  },
                  "typeProperties": {
                    "scripts": [
                      {
                        "type": "Query",
                        "text": {
                          "value": "UPDATE\n    @{variables('METADATA_SCHEMA')}.@{variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')}\nSET\n    mapping_complete = CAST(0 AS BIT),\n    masked_status = NULL\nWHERE\n    UPPER(source_dataset) = UPPER('@{variables('DATASET')}')\n    AND UPPER(source_database) = UPPER('@{pipeline().parameters.P_SOURCE_DATABASE}')\n    AND UPPER(source_schema) = UPPER('@{pipeline().parameters.P_SOURCE_SCHEMA}')",
                          "type": "Expression"
                        }
                      }
                    ],
                    "scriptBlockExecutionTimeout": "02:00:00"
                  }
                }
              ]
            }
          },
          {
            "name": "Configure Masked Status",
            "type": "Script",
            "dependsOn": [
              {
                "activity": "Select Tables That Require Masking",
                "dependencyConditions": [
                  "Succeeded"
                ]
              }
            ],
            "policy": {
              "timeout": "0.12:00:00",
              "retry": 0,
              "retryIntervalInSeconds": 30,
              "secureOutput": false,
              "secureInput": false
            },
            "userProperties": [],
            "linkedServiceName": {
              "referenceName": "[parameters('Metadata Datastore')]",
              "type": "LinkedServiceReference"
            },
            "typeProperties": {
              "scripts": [
                {
                  "type": "Query",
                  "text": {
                    "value": "WITH\n    tables_requiring_filters AS\n    (\n    \tSELECT DISTINCT\n    \t\tdataset, specified_database, specified_schema, identified_table\n    \tFROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_RULESET_TABLE')}\n    \tWHERE ISJSON(assigned_algorithm) = 1\n    \t    AND dataset = '@{variables('DATASET')}'\n    \t    AND specified_database = '@{pipeline().parameters.P_SOURCE_DATABASE}'\n    \t    AND specified_schema = '@{pipeline().parameters.P_SOURCE_SCHEMA}'\n    ),\n    all_filters AS\n    (\n    \tSELECT DISTINCT\n    \t\tJSON_VALUE(kc.value, '$.alias') as filter_alias,\n    \t\tidentified_table\n    \tFROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_RULESET_TABLE')} d\n    \t\tCROSS APPLY OPENJSON(d.assigned_algorithm) kc\n    \tWHERE\n    \t\tISJSON(assigned_algorithm,ARRAY) = 1\n    \t\tAND\n    \t\tidentified_table in (\n    \t\t\tSELECT identified_table FROM tables_requiring_filters\n    \t\t)\n    ),\n    sources_and_filters AS (\n    \tSELECT\n    \t\tdataset,\n    \t\tspecified_database,\n    \t\tspecified_schema,\n    \t\ttables_requiring_filters.identified_table,\n    \t\tJSON_OBJECTAGG(filter_alias:CAST(0 as BIT)) AS masked_status\n    \tFROM tables_requiring_filters\n    \t    INNER JOIN all_filters\n    \t    ON tables_requiring_filters.identified_table = all_filters.identified_table\n    \tGROUP BY dataset, specified_database, specified_schema, tables_requiring_filters.identified_table\n    )\n    UPDATE @{variables('METADATA_SCHEMA')}.@{variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')}\n    SET masked_status = sf.masked_status\n\tFROM sources_and_filters sf\n\tINNER JOIN @{variables('METADATA_SCHEMA')}.@{variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')} dm ON\n        dm.source_dataset = sf.dataset AND\n        dm.source_database = sf.specified_database AND\n        dm.source_schema = sf.specified_schema AND\n        dm.source_table = sf.identified_table\n\tWHERE\n\t\tdm.masked_status IS NULL\n        AND (dm.mapping_complete IS NULL OR dm.mapping_complete = 0)",
                    "type": "Expression"
                  }
                }
              ],
              "scriptBlockExecutionTimeout": "02:00:00"
            }
          },
          {
            "name": "Select Tables We Should Truncate",
            "type": "Lookup",
            "dependsOn": [
              {
                "activity": "Check If We Should Reapply Mapping",
                "dependencyConditions": [
                  "Succeeded"
                ]
              }
            ],
            "policy": {
              "timeout": "0.12:00:00",
              "retry": 0,
              "retryIntervalInSeconds": 30,
              "secureOutput": false,
              "secureInput": false
            },
            "userProperties": [],
            "typeProperties": {
              "source": {
                "type": "AzureSqlSource",
                "sqlReaderQuery": {
                  "value": "SELECT DISTINCT\n\tdm.sink_dataset,\n\tdm.sink_database,\n\tdm.sink_schema,\n\tdm.sink_table\nFROM\n    @{variables('METADATA_SCHEMA')}.@{variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')} dm\nWHERE\n\tdm.source_dataset = '@{variables('DATASET')}'\n\tAND dm.source_database = '@{pipeline().parameters.P_SOURCE_DATABASE}'\n\tAND dm.source_schema = '@{pipeline().parameters.P_SOURCE_SCHEMA}'\n\tAND dm.sink_dataset = '@{variables('DATASET')}'\n\tAND dm.sink_database = '@{pipeline().parameters.P_SINK_DATABASE}'\n\tAND dm.sink_schema = '@{pipeline().parameters.P_SINK_SCHEMA}'\n\tAND (dm.mapping_complete IS NULL OR dm.mapping_complete = 0)\n    AND LOWER('@{pipeline().parameters.P_TRUNCATE_SINK_BEFORE_WRITE}') = 'true'",
                  "type": "Expression"
                },
                "queryTimeout": "02:00:00",
                "partitionOption": "None"
              },
              "dataset": {
                "referenceName": "dcsazure_Snowflake_to_Snowflake_mask_metadata_ds",
                "type": "DatasetReference",
                "parameters": {
                  "DS_METADATA_SCHEMA": {
                    "value": "@variables('METADATA_SCHEMA')",
                    "type": "Expression"
                  },
                  "DS_METADATA_TABLE": {
                    "value": "@variables('METADATA_RULESET_TABLE')",
                    "type": "Expression"
                  }
                }
              },
              "firstRowOnly": false
            }
          },
          {
            "name": "For Each Table To Truncate",
            "type": "ForEach",
            "dependsOn": [
              {
                "activity": "Select Tables We Should Truncate",
                "dependencyConditions": [
                  "Succeeded"
                ]
              }
            ],
            "userProperties": [],
            "typeProperties": {
              "items": {
                "value": "@activity('Select Tables We Should Truncate').output.value",
                "type": "Expression"
              },
              "activities": [
                {
                  "name": "Truncate Selected Table",
                  "type": "Script",
                  "dependsOn": [],
                  "policy": {
                    "timeout": "0.12:00:00",
                    "retry": 0,
                    "retryIntervalInSeconds": 30,
                    "secureOutput": false,
                    "secureInput": false
                  },
                  "userProperties": [],
                  "linkedServiceName": {
                    "referenceName": "[parameters('Snowflake_Sink_New')]",
                    "type": "LinkedServiceReference",
                    "parameters": {
                      "LS_DATABASE": {
                        "value": "@pipeline().parameters.P_SINK_DATABASE",
                        "type": "Expression"
                      },
                      "LS_WAREHOUSE": {
                        "value": "@variables('SINK_SNOWFLAKE_WAREHOUSE')",
                        "type": "Expression"
                      },
                      "LS_ROLE": {
                        "value": "@variables('SINK_SNOWFLAKE_ROLE')",
                        "type": "Expression"
                      }
                    }
                  },
                  "typeProperties": {
                    "scripts": [
                      {
                        "type": "Query",
                        "text": {
                          "value": "TRUNCATE TABLE @{item().sink_database}.@{item().sink_schema}.\"@{item().sink_table}\"",
                          "type": "Expression"
                        }
                      }
                    ],
                    "scriptBlockExecutionTimeout": "02:00:00"
                  }
                }
              ]
            }
          }
        ],
        "policy": {
          "elapsedTimeMetric": {}
        },
        "parameters": {
          "P_COPY_UNMASKED_TABLES": {
            "type": "bool",
            "defaultValue": false
          },
          "P_COPY_USE_DATAFLOW": {
            "type": "bool",
            "defaultValue": false
          },
          "P_FAIL_ON_NONCONFORMANT_DATA": {
            "type": "bool",
            "defaultValue": true
          },
          "P_TRUNCATE_SINK_BEFORE_WRITE": {
            "type": "bool",
            "defaultValue": true
          },
          "P_REAPPLY_MAPPING": {
            "type": "bool",
            "defaultValue": true
          },
          "P_SOURCE_DATABASE": {
            "type": "string"
          },
          "P_SINK_DATABASE": {
            "type": "string"
          },
          "P_SOURCE_SCHEMA": {
            "type": "string"
          },
          "P_SINK_SCHEMA": {
            "type": "string"
          }
        },
        "variables": {
          "METADATA_SCHEMA": {
            "type": "String",
            "defaultValue": "dbo"
          },
          "METADATA_RULESET_TABLE": {
            "type": "String",
            "defaultValue": "discovered_ruleset"
          },
          "METADATA_SOURCE_TO_SINK_MAPPING_TABLE": {
            "type": "String",
            "defaultValue": "adf_data_mapping"
          },
          "METADATA_ADF_TYPE_MAPPING_TABLE": {
            "type": "String",
            "defaultValue": "adf_type_mapping"
          },
          "STAGING_STORAGE_PATH": {
            "type": "String",
            "defaultValue": "staging-container"
          },
          "DATASET": {
            "type": "String",
            "defaultValue": "SNOWFLAKE"
          },
          "CONDITIONAL_MASKING_RESERVED_CHARACTER": {
            "type": "String",
            "defaultValue": "%"
          },
          "TARGET_BATCH_SIZE": {
            "type": "Integer",
            "defaultValue": 2000
          },
          "METADATA_EVENT_PROCEDURE_NAME": {
            "type": "String",
            "defaultValue": "insert_adf_masking_event"
          },
          "SOURCE_SNOWFLAKE_WAREHOUSE": {
            "type": "String",
            "defaultValue": "DEFAULT"
          },
          "SOURCE_SNOWFLAKE_ROLE": {
            "type": "String",
            "defaultValue": "SYSADMIN"
          },
          "SINK_SNOWFLAKE_WAREHOUSE": {
            "type": "String",
            "defaultValue": "DEFAULT"
          },
          "SINK_SNOWFLAKE_ROLE": {
            "type": "String",
            "defaultValue": "SYSADMIN"
          },
          "COLUMN_WIDTH_ESTIMATE": {
            "type": "Integer",
            "defaultValue": 1000
          }
        },
        "folder": {
          "name": "dcsazure_Snowflake_to_Snowflake"
        },
        "annotations": [],
        "lastPublishTime": "2025-01-07T00:54:27Z"
      },
      "dependsOn": [
        "[concat(variables('factoryId'), '/datasets/dcsazure_Snowflake_to_Snowflake_mask_metadata_ds')]",
        "[concat(variables('factoryId'), '/dataflows/dcsazure_Snowflake_to_Snowflake_filter_test_utility_df')]",
        "[concat(variables('factoryId'), '/dataflows/dcsazure_Snowflake_to_Snowflake_unfiltered_mask_params_df')]",
        "[concat(variables('factoryId'), '/dataflows/dcsazure_Snowflake_to_Snowflake_unfiltered_mask_df')]",
        "[concat(variables('factoryId'), '/dataflows/dcsazure_Snowflake_to_Snowflake_filtered_mask_params_df')]",
        "[concat(variables('factoryId'), '/dataflows/dcsazure_Snowflake_to_Snowflake_filtered_mask_df')]",
        "[concat(variables('factoryId'), '/datasets/dcsazure_Snowflake_to_Snowflake_mask_source_ds')]",
        "[concat(variables('factoryId'), '/datasets/dcsazure_Snowflake_to_Snowflake_mask_sink_ds')]",
        "[concat(variables('factoryId'), '/dataflows/dcsazure_Snowflake_to_Snowflake_copy_df')]"
      ]
    },
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_Snowflake_to_Snowflake_mask_metadata_ds')]",
      "type": "Microsoft.DataFactory/factories/datasets",
      "apiVersion": "2018-06-01",
      "properties": {
        "linkedServiceName": {
          "referenceName": "[parameters('Metadata Datastore')]",
          "type": "LinkedServiceReference"
        },
        "parameters": {
          "DS_METADATA_SCHEMA": {
            "type": "string"
          },
          "DS_METADATA_TABLE": {
            "type": "string"
          }
        },
        "folder": {
          "name": "dcsazure_Snowflake_to_Snowflake"
        },
        "annotations": [],
        "type": "AzureSqlTable",
        "schema": [
          {
            "name": "source_database",
            "type": "varchar"
          },
          {
            "name": "source_schema",
            "type": "varchar"
          },
          {
            "name": "source_table",
            "type": "varchar"
          },
          {
            "name": "source_column",
            "type": "varchar"
          },
          {
            "name": "destination_database",
            "type": "varchar"
          },
          {
            "name": "destination_schema",
            "type": "varchar"
          },
          {
            "name": "destination_table",
            "type": "varchar"
          }
        ],
        "typeProperties": {
          "schema": {
            "value": "@dataset().DS_METADATA_SCHEMA",
            "type": "Expression"
          },
          "table": {
            "value": "@dataset().DS_METADATA_TABLE",
            "type": "Expression"
          }
        }
      },
      "dependsOn": []
    },
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_Snowflake_to_Snowflake_filter_test_utility_df')]",
      "type": "Microsoft.DataFactory/factories/dataflows",
      "apiVersion": "2018-06-01",
      "properties": {
        "folder": {
          "name": "dcsazure_Snowflake_to_Snowflake"
        },
        "type": "MappingDataFlow",
        "typeProperties": {
          "sources": [
            {
              "linkedService": {
                "referenceName": "[parameters('Snowflake_Source_New')]",
                "type": "LinkedServiceReference"
              },
              "name": "SourceData",
              "description": "Using an inline data set, specify the source as DF_SOURCE_SCHEMA.DF_SOURCE_TABLE"
            }
          ],
          "sinks": [
            {
              "linkedService": {
                "referenceName": "[parameters('Snowflake_Sink_New')]",
                "type": "LinkedServiceReference"
              },
              "name": "SinkData",
              "description": "Using an inline data set, specify the sink as DF_SINK_SCHEMA.DF_SINK_TABLE"
            }
          ],
          "transformations": [
            {
              "name": "FilterToAppropriateRows",
              "description": "Filter base table based on supplied filter"
            }
          ],
          "scriptLines": [
            "parameters{",
            "     runId as string (''),",
            "     DF_SOURCE_SCHEMA as string (''),",
            "     DF_SOURCE_TABLE as string (''),",
            "     DF_SINK_SCHEMA as string (''),",
            "     DF_SINK_TABLE as string (''),",
            "     DF_FILTER_CONDITION as boolean (true())",
            "}",
            "source(allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'table',",
            "     tableName: ($DF_SOURCE_TABLE),",
            "     schemaName: ($DF_SOURCE_SCHEMA),",
            "     store: 'snowflake',",
            "     store: 'snowflakeV2',",
            "     partitionBy('roundRobin', 32)) ~> SourceData",
            "SourceData filter($DF_FILTER_CONDITION) ~> FilterToAppropriateRows",
            "FilterToAppropriateRows sink(allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'table',",
            "     tableName: ($DF_SINK_TABLE),",
            "     schemaName: ($DF_SINK_SCHEMA),",
            "     deletable: false,",
            "     insertable: true,",
            "     updateable: false,",
            "     upsertable: false,",
            "     store: 'snowflake',",
            "     store: 'snowflakeV2',",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true,",
            "     stageInsert: true) ~> SinkData"
          ]
        }
      },
      "dependsOn": []
    },
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_Snowflake_to_Snowflake_unfiltered_mask_params_df')]",
      "type": "Microsoft.DataFactory/factories/dataflows",
      "apiVersion": "2018-06-01",
      "properties": {
        "folder": {
          "name": "dcsazure_Snowflake_to_Snowflake"
        },
        "type": "MappingDataFlow",
        "typeProperties": {
          "sources": [
            {
              "linkedService": {
                "referenceName": "[parameters('Metadata Datastore')]",
                "type": "LinkedServiceReference"
              },
              "name": "Ruleset",
              "description": "Get the ruleset table from the metadata store at DF_METADATA_SCHEMA.DF_METADATA_RULESET_TABLE"
            },
            {
              "linkedService": {
                "referenceName": "[parameters('Metadata Datastore')]",
                "type": "LinkedServiceReference"
              },
              "name": "TypeMapping",
              "description": "Get the type mapping table from the metadata store at DF_METADATA_STORE.DF_METADATA_ADF_TYPE_MAPPING_TABLE"
            }
          ],
          "sinks": [
            {
              "name": "MaskingParameterOutput",
              "description": "Sink results of computing masking parameters to activity output cache"
            }
          ],
          "transformations": [
            {
              "name": "FilterToSingleTable",
              "description": "Filter ruleset table down to the table in question by specifying dataset, specified_database, specified_schema, identified_table, and assigned_algorithm - making sure they match the dataset associated with each version of the dataflow, DF_SOURCE_DATABASE, DF_SOURCE_SCHEMA, DF_SOURCE_TABLE, and not empty or null (respectively). This filters the ruleset down to only the rules that need to be applied for masking this particular table"
            },
            {
              "name": "RulesetWithTypes",
              "description": "Join the ruleset table with the type mapping table based on the type of the column and the translation of that type to an ADF type"
            },
            {
              "name": "RulesetWithAlgorithmTypeMapping",
              "description": "Generate several columns:\n\n    output_row that always contains 1 (used later for Aggregate and Join operations)\n    adf_type_conversion that contains a string like <column_name> as <adf_type>\n    column_width_estimate that contains an integer that uses DF_COLUMN_WIDTH_ESTIMATE as the width for any column where identified_column_max_length is not positive, and identified_column_max_length plus some padding otherwise"
            },
            {
              "name": "GenerateMaskParameters",
              "description": "Grouped by output_row produce the following aggregates\n\n    FieldAlgorithmAssignments - a JSON string that maps a column name to its assigned algorithm\n    ColumnsToMask - a list of the column names that have an algorithm assigned\n    DataFactoryTypeMapping - a string that can be used by ADF to parse the output of a call to the Delphix masking endpoint, leveraging the adf_type_conversion column derived previously\n    NumberOfBatches - an integer value determined by computing the number of batches leveraging the max row_count as specified in the ruleset table, and the sum of column_width_estimate column derived previously\n    TrimLengths - a list of the actual widths of the columns so that will be used by the masking data flow to trim output before sinking"
            },
            {
              "name": "ModifyNumberOfBatches",
              "description": "Modifies the number of batches to be at least 1"
            },
            {
              "name": "FilterToDataSourceType",
              "description": "Filter type mapping table down to only the dataset in question"
            },
            {
              "name": "ParseMetadata",
              "description": "Parse the content from the metadata column that contains JSON, specifically handling parsing of known keys (i.e. date_format)"
            },
            {
              "name": "StringCastingWithAdfType",
              "description": "Join columns that need to be cast to string and the type mapping table, so we can determine casting requirements"
            },
            {
              "name": "CreateColumnsToCastBackTo",
              "description": "Aggregating column names by adf_type to produce ColumnsToCastBackTo,\nwhich consists of a list of columns, separated by \",\" so that when they are aggregated via collect later the list of items is an array of quote-wrapped column names"
            },
            {
              "name": "CreateColumnsToCastBackParameters",
              "description": "Take the correct value of 'ColumnsToCastBackTo' based on the 'adf_type', one for each of the types we need to cast back to: Binary, Boolean, Date, Double, Float, Integer, Long, Timestamp"
            },
            {
              "name": "FilterToRowsWithStringCasting",
              "description": "Filtering rows where 'treat_as_string' is true"
            },
            {
              "name": "CreateColumnsToCastAsStrings",
              "description": "Aggregating column names to produce ColumnsToCastAsStrings"
            },
            {
              "name": "CombineAllStringCastingParameters",
              "description": "Combine tables to have ColumnsToCastAsStrings and ColumnsToCastBackTo* parameters"
            },
            {
              "name": "AggregateColumnsToCastBackParameters",
              "description": "Create ColumnsToCastBackTo* by collecting on the previously computed columns"
            },
            {
              "name": "DateFormatString",
              "description": "Derive columns as necessary for handling the parsed data (i.e. consume parsed_metadata.date_format and put it in a column date_format_string), and add an output_row column that always contains 1 (used later for Aggregate and Join operations)"
            },
            {
              "name": "DateFormatHeader",
              "description": "Create DateFormatAssignment, grouped by output_row (which is always 1), generating a JSON string that maps a column to its specified date format"
            },
            {
              "name": "AllMaskingParameters",
              "description": "Perform an inner join on output_row with the computed casting parameters and date format headers - combining all masking parameters into the same output stream"
            },
            {
              "name": "DateFormatHeaderHandlingNulls",
              "description": "Update column DateFormatAssignments to coalesce DateFormatAssignments, and NoFormatHeader (i.e. if DateFormatAssignments is null, take NoFormatHeader, which won't be null)"
            },
            {
              "name": "RemoveUnnecessaryColumns",
              "description": "Remove redundant columns after joining date format and string casting parameters"
            },
            {
              "name": "SplitOnDateFormat",
              "description": "Split the data into two streams, data that contains a specified date\nformat, and data that does not"
            },
            {
              "name": "NoFormatHeader",
              "description": "Create NoFormatHeader, that generates a JSON string containing an empty map when all values are null, grouped by output_row (which is always 1)"
            },
            {
              "name": "JoinDateHeaders",
              "description": "Full outer join both DateFormatHeader and NoFormatHeader where output_row = output_row"
            },
            {
              "name": "StringCastingHandling",
              "description": "Derive columns for handling string casting"
            },
            {
              "name": "JoinDateFormatAndStringCastingParameters",
              "description": "Combine date format and string casting related parameters into a single table"
            },
            {
              "name": "ComputeCastingDefaultsIfMissing",
              "description": "For all casting parameters that are currently null, set them instead to the empty list"
            }
          ],
          "scriptLines": [
            "parameters{",
            "     runId as string (''),",
            "     DF_METADATA_SCHEMA as string ('dbo'),",
            "     DF_METADATA_RULESET_TABLE as string ('discovered_ruleset'),",
            "     DF_METADATA_ADF_TYPE_MAPPING_TABLE as string ('adf_type_mapping'),",
            "     DF_SOURCE_DATABASE as string (''),",
            "     DF_SOURCE_SCHEMA as string (''),",
            "     DF_SOURCE_TABLE as string (''),",
            "     DF_COLUMN_WIDTH_ESTIMATE as integer (1000),",
            "     DF_DATASET as string ('SNOWFLAKE')",
            "}",
            "source(output(",
            "          dataset as string,",
            "          specified_database as string,",
            "          specified_schema as string,",
            "          identified_table as string,",
            "          identified_column as string,",
            "          identified_column_type as string,",
            "          identified_column_max_length as integer,",
            "          ordinal_position as integer,",
            "          row_count as long,",
            "          source_metadata as string,",
            "          profiled_domain as string,",
            "          profiled_algorithm as string,",
            "          confidence_score as decimal(6,5),",
            "          rows_profiled as long,",
            "          assigned_algorithm as string,",
            "          last_profiled_updated_timestamp as timestamp,",
            "          discovery_complete as boolean,",
            "          latest_event as string,",
            "          algorithm_metadata as string",
            "     ),",
            "     allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'table',",
            "     store: 'sqlserver',",
            "     schemaName: ($DF_METADATA_SCHEMA),",
            "     tableName: ($DF_METADATA_RULESET_TABLE),",
            "     isolationLevel: 'READ_UNCOMMITTED') ~> Ruleset",
            "source(output(",
            "          dataset as string,",
            "          dataset_type as string,",
            "          adf_type as string",
            "     ),",
            "     allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'table',",
            "     store: 'sqlserver',",
            "     schemaName: ($DF_METADATA_SCHEMA),",
            "     tableName: ($DF_METADATA_ADF_TYPE_MAPPING_TABLE),",
            "     isolationLevel: 'READ_UNCOMMITTED') ~> TypeMapping",
            "Ruleset filter(equalsIgnoreCase(dataset, $DF_DATASET)",
            "&& equalsIgnoreCase(specified_database, $DF_SOURCE_DATABASE)",
            "&& equalsIgnoreCase(specified_schema, $DF_SOURCE_SCHEMA)",
            "&& equalsIgnoreCase(identified_table, $DF_SOURCE_TABLE)",
            "&& !equalsIgnoreCase(assigned_algorithm, '')",
            "&& !isNull(assigned_algorithm)) ~> FilterToSingleTable",
            "FilterToSingleTable, FilterToDataSourceType join(identified_column_type == dataset_type,",
            "     joinType:'inner',",
            "     matchType:'exact',",
            "     ignoreSpaces: false,",
            "     broadcast: 'auto')~> RulesetWithTypes",
            "RulesetWithTypes derive(output_row = 1,",
            "          adf_type_conversion = concat(identified_column, ' as ', adf_type),",
            "          column_width_estimate = iif(identified_column_max_length > 0, identified_column_max_length+4, $DF_COLUMN_WIDTH_ESTIMATE)) ~> RulesetWithAlgorithmTypeMapping",
            "RulesetWithAlgorithmTypeMapping aggregate(groupBy(output_row),",
            "     FieldAlgorithmAssignments = regexReplace(reduce(mapAssociation(keyValues(collect(concat('x',hex(encode(identified_column)))), collect(assigned_algorithm)), '\"' + #key + '\":\"' + #value + '\"'), '{', #acc + #item + ',', #result + '}'), ',}', '}'),",
            "          ColumnsToMask = regexReplace(reduce(collect(identified_column), '[',  #acc + '\"' + #item + '\",', #result + ']'), ',]', ']'),",
            "          DataFactoryTypeMapping = concat(\"'\", '(timestamp as date, status as string, message as string, trace_id as string, items as (DELPHIX_COMPLIANCE_SERVICE_BATCH_ID as long, ',",
            "    regexReplace(reduce(collect(concat('x',hex(encode(identified_column))) + ' as ' + adf_type), '', #acc + #item + ', ', #result + ')'), ', \\\\)', ')'),",
            "    '[])', \"'\"),",
            "          NumberOfBatches = toInteger(ceil(((max(row_count) * (sum(column_width_estimate) + log10(max(row_count)) +1)) / (2000000 * .9)))),",
            "          TrimLengths = regexReplace(reduce(collect(identified_column_max_length), '[',  #acc + toString(#item) + ',', toString(#result) + ']'), ',]', ']')) ~> GenerateMaskParameters",
            "GenerateMaskParameters derive(NumberOfBatches = iif(NumberOfBatches > 0, NumberOfBatches, 1)) ~> ModifyNumberOfBatches",
            "TypeMapping filter(equalsIgnoreCase(dataset, $DF_DATASET)) ~> FilterToDataSourceType",
            "FilterToSingleTable parse(parsed_metadata = algorithm_metadata ? (date_format as string,",
            "          treat_as_string as boolean),",
            "     format: 'json',",
            "     documentForm: 'singleDocument') ~> ParseMetadata",
            "FilterToRowsWithStringCasting, FilterToDataSourceType join(identified_column_type == dataset_type,",
            "     joinType:'inner',",
            "     matchType:'exact',",
            "     ignoreSpaces: false,",
            "     broadcast: 'auto')~> StringCastingWithAdfType",
            "StringCastingWithAdfType aggregate(groupBy(adf_type),",
            "     ColumnsToCastBackTo = ltrim(rtrim(reduce(collect(identified_column), '',  #acc + '\"' + #item + '\",', #result), '\",'), '\"')) ~> CreateColumnsToCastBackTo",
            "CreateColumnsToCastBackTo derive(ColumnsToCastBackToBinary = iif(adf_type == 'binary', ColumnsToCastBackTo, toString(null())),",
            "          ColumnsToCastBackToBoolean = iif(adf_type == 'boolean', ColumnsToCastBackTo, toString(null())),",
            "          ColumnsToCastBackToDate = iif(adf_type == 'date', ColumnsToCastBackTo, toString(null())),",
            "          ColumnsToCastBackToDouble = iif(adf_type == 'double', ColumnsToCastBackTo, toString(null())),",
            "          ColumnsToCastBackToFloat = iif(adf_type == 'float', ColumnsToCastBackTo, toString(null())),",
            "          ColumnsToCastBackToInteger = iif(adf_type == 'integer', ColumnsToCastBackTo, toString(null())),",
            "          ColumnsToCastBackToLong = iif(adf_type == 'long', ColumnsToCastBackTo, toString(null())),",
            "          ColumnsToCastBackToTimestamp = iif(adf_type == 'timestamp', ColumnsToCastBackTo, toString(null())),",
            "          output_row = 1) ~> CreateColumnsToCastBackParameters",
            "StringCastingHandling filter(not(isNull(treat_as_string)) && treat_as_string) ~> FilterToRowsWithStringCasting",
            "FilterToRowsWithStringCasting aggregate(groupBy(output_row),",
            "     ColumnsToCastAsStrings = regexReplace(reduce(collect(identified_column), '[',  #acc + '\"' + #item + '\",', #result + ']'), ',]', ']')) ~> CreateColumnsToCastAsStrings",
            "CreateColumnsToCastAsStrings, AggregateColumnsToCastBackParameters join(CreateColumnsToCastAsStrings@output_row == AggregateColumnsToCastBackParameters@output_row,",
            "     joinType:'inner',",
            "     matchType:'exact',",
            "     ignoreSpaces: false,",
            "     broadcast: 'auto')~> CombineAllStringCastingParameters",
            "CreateColumnsToCastBackParameters aggregate(groupBy(output_row),",
            "     ColumnsToCastBackToBinary = regexReplace(reduce(collect(ColumnsToCastBackToBinary), '[',  #acc + '\"' + #item + '\",', #result + ']'), ',]', ']'),",
            "          ColumnsToCastBackToBoolean = regexReplace(reduce(collect(ColumnsToCastBackToBoolean), '[',  #acc + '\"' + #item + '\",', #result + ']'), ',]', ']'),",
            "          ColumnsToCastBackToDate = regexReplace(reduce(collect(ColumnsToCastBackToDate), '[',  #acc + '\"' + #item + '\",', #result + ']'), ',]', ']'),",
            "          ColumnsToCastBackToDouble = regexReplace(reduce(collect(ColumnsToCastBackToDouble), '[',  #acc + '\"' + #item + '\",', #result + ']'), ',]', ']'),",
            "          ColumnsToCastBackToFloat = regexReplace(reduce(collect(ColumnsToCastBackToFloat), '[',  #acc + '\"' + #item + '\",', #result + ']'), ',]', ']'),",
            "          ColumnsToCastBackToInteger = regexReplace(reduce(collect(ColumnsToCastBackToInteger), '[',  #acc + '\"' + #item + '\",', #result + ']'), ',]', ']'),",
            "          ColumnsToCastBackToLong = regexReplace(reduce(collect(ColumnsToCastBackToLong), '[',  #acc + '\"' + #item + '\",', #result + ']'), ',]', ']'),",
            "          ColumnsToCastBackToTimestamp = regexReplace(reduce(collect(ColumnsToCastBackToTimestamp), '[',  #acc + '\"' + #item + '\",', #result + ']'), ',]', ']')) ~> AggregateColumnsToCastBackParameters",
            "ParseMetadata derive(output_row = 1,",
            "          date_format_string = parsed_metadata.date_format) ~> DateFormatString",
            "SplitOnDateFormat@ContainsDateFormat aggregate(groupBy(output_row),",
            "     DateFormatAssignments = regexReplace(reduce(mapAssociation(keyValues(collect(concat('x',hex(encode(identified_column)))), collect(date_format_string)), '\"' + #key + '\":\"' + #value + '\"'), '{', #acc + #item + ',', #result + '}'), ',}', '}')) ~> DateFormatHeader",
            "ModifyNumberOfBatches, ComputeCastingDefaultsIfMissing join(GenerateMaskParameters@output_row == RemoveUnnecessaryColumns@output_row,",
            "     joinType:'inner',",
            "     matchType:'exact',",
            "     ignoreSpaces: false,",
            "     broadcast: 'auto')~> AllMaskingParameters",
            "JoinDateHeaders derive(DateFormatAssignments = coalesce(DateFormatAssignments,NoFormatHeader),",
            "          output_row = coalesce(DateFormatHeader@output_row, NoFormatHeader@output_row)) ~> DateFormatHeaderHandlingNulls",
            "JoinDateFormatAndStringCastingParameters select(mapColumn(",
            "          output_row = DateFormatHeaderHandlingNulls@output_row,",
            "          DateFormatAssignments,",
            "          ColumnsToCastAsStrings,",
            "          output_row = AggregateColumnsToCastBackParameters@output_row,",
            "          ColumnsToCastBackToBinary,",
            "          ColumnsToCastBackToBoolean,",
            "          ColumnsToCastBackToDate,",
            "          ColumnsToCastBackToDouble,",
            "          ColumnsToCastBackToFloat,",
            "          ColumnsToCastBackToInteger,",
            "          ColumnsToCastBackToLong,",
            "          ColumnsToCastBackToTimestamp",
            "     ),",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true) ~> RemoveUnnecessaryColumns",
            "DateFormatString split(not(isNull(date_format_string)),",
            "     disjoint: false) ~> SplitOnDateFormat@(ContainsDateFormat, DoesNotContainDateFormat)",
            "SplitOnDateFormat@DoesNotContainDateFormat aggregate(groupBy(output_row),",
            "     NoFormatHeader = reduce(collect(date_format_string), '{', #acc + #item + ',', #result + '}')) ~> NoFormatHeader",
            "DateFormatHeader, NoFormatHeader join(DateFormatHeader@output_row == NoFormatHeader@output_row,",
            "     joinType:'outer',",
            "     matchType:'exact',",
            "     ignoreSpaces: false,",
            "     broadcast: 'auto')~> JoinDateHeaders",
            "ParseMetadata derive(output_row = 1,",
            "          treat_as_string = parsed_metadata.treat_as_string) ~> StringCastingHandling",
            "DateFormatHeaderHandlingNulls, CombineAllStringCastingParameters join(DateFormatHeaderHandlingNulls@output_row == CreateColumnsToCastAsStrings@output_row,",
            "     joinType:'left',",
            "     matchType:'exact',",
            "     ignoreSpaces: false,",
            "     broadcast: 'auto')~> JoinDateFormatAndStringCastingParameters",
            "RemoveUnnecessaryColumns derive(each(match(startsWith(name,'ColumnsToCast')), $$ = coalesce($$, '[]'))) ~> ComputeCastingDefaultsIfMissing",
            "AllMaskingParameters sink(validateSchema: false,",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true,",
            "     store: 'cache',",
            "     format: 'inline',",
            "     output: true,",
            "     saveOrder: 1) ~> MaskingParameterOutput"
          ]
        }
      },
      "dependsOn": []
    },
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_Snowflake_to_Snowflake_unfiltered_mask_df')]",
      "type": "Microsoft.DataFactory/factories/dataflows",
      "apiVersion": "2018-06-01",
      "properties": {
        "description": "Performing masking leveraging typeof",
        "folder": {
          "name": "dcsazure_Snowflake_to_Snowflake"
        },
        "type": "MappingDataFlow",
        "typeProperties": {
          "sources": [
            {
              "linkedService": {
                "referenceName": "[parameters('Snowflake_Source_New')]",
                "type": "LinkedServiceReference"
              },
              "name": "Source",
              "description": "Select source data at DF_SOURCE_SCHEMA.DF_SOURCE_TABLE using an inline dataset"
            }
          ],
          "sinks": [
            {
              "linkedService": {
                "referenceName": "[parameters('Snowflake_Sink_New')]",
                "type": "LinkedServiceReference"
              },
              "name": "Sink",
              "description": "Sink results of masking to data store by sinking the unrolled results of the masking call to the columns of the same name in the data sink"
            }
          ],
          "transformations": [
            {
              "name": "DCSForAzureAPI",
              "linkedService": {
                "referenceName": "[parameters('ProdDCSForAzureService')]",
                "type": "LinkedServiceReference"
              }
            },
            {
              "name": "AddSortKey",
              "description": "Create column DELPHIX_COMPLIANCE_SERVICE_SORT_ID that consists of SHA of the data across all columns in the table - every row will have this value and it cannot be null"
            },
            {
              "name": "SortBySortKey",
              "description": "Sort the table by the value in DELPHIX_COMPLIANCE_SERVICE_SORT_ID, as we need the table to be in a particular order before we apply a surrogate key"
            },
            {
              "name": "CreateSurrogateKey",
              "description": "Add a DELPHIX_COMPLIANCE_SERVICE_BATCH_ID column that increments by 1 and starts at 1 after applying the sorting"
            },
            {
              "name": "WrapValuesInArray",
              "description": "For each column we wish to mask, convert the value into an array, this is needed to preserve null values as null when using collect, as null values become [], and encode the column names to handle body type mapping changes"
            },
            {
              "name": "SelectColumnsUnmasked",
              "description": "Select only columns that don't require masking"
            },
            {
              "name": "AggregateColumnsByBatch",
              "description": "For each column we wish to mask, aggregate to a list using collect, grouped by DELPHIX_COMPLIANCE_SERVICE_BATCH_ID modulo DF_NUMBER_OF_BATCHES - so there will be DF_NUMBER_OF_BATCHES total such aggregations, name the group as DELPHIX_COMPLIANCE_SERVICE_BATCH_GROUP"
            },
            {
              "name": "FlattenValuesOutOfArray",
              "description": "For each column we wish to mask, flatten the value out of the array, in the case where the value was previously [], it becomes null"
            },
            {
              "name": "AssertNoFailures",
              "description": "Confirm that we received a 200 response status from the API request"
            },
            {
              "name": "FlattenAggregateData",
              "description": "Unroll the API response body into decoded named columns"
            },
            {
              "name": "JoinMaskedAndUnmaskedData",
              "description": "Inner join on SelectColumnsUnmasked and TrimMaskedStrings based on matching DELPHIX_COMPLIANCE_SERVICE_BATCH_ID"
            },
            {
              "name": "TrimMaskedStrings",
              "description": "For each column with a string type, trim the string to length based on the value in DF_TRIM_LENGTHS - this is needed as masking a string may produce a longer string that exceeds the column width in the sink"
            },
            {
              "name": "CastRequiredColumnsAsStrings",
              "description": "For columns that require casting to string, cast them to string"
            },
            {
              "name": "CastColumnsBackAsRequired",
              "description": "For columns that need to be cast back to a compatible type, cast them back"
            }
          ],
          "scriptLines": [
            "parameters{",
            "     runId as string (''),",
            "     DF_SOURCE_SCHEMA as string (''),",
            "     DF_SOURCE_TABLE as string (''),",
            "     DF_SINK_SCHEMA as string (''),",
            "     DF_SINK_TABLE as string (''),",
            "     DF_FIELD_ALGORITHM_ASSIGNMENT as string ('{}'),",
            "     DF_COLUMNS_TO_MASK as string[] ([\"\"]),",
            "     DF_BODY_TYPE_MAPPING as string ('(timestamp as date, status as string, message as string, trace_id as string, items as (DELPHIX_COMPLIANCE_SERVICE_BATCH_ID as long)[])'),",
            "     DF_NUMBER_OF_BATCHES as integer (100),",
            "     DF_TRIM_LENGTHS as integer[] ([1000]),",
            "     DF_FAIL_ON_NONCONFORMANT_DATA as boolean (true()),",
            "     DF_FIELD_DATE_FORMAT as string ('{}'),",
            "     DF_COLUMNS_TO_CAST_AS_STRINGS as string[] ([\"\"]),",
            "     DF_COLUMNS_TO_CAST_BACK_TO_BINARY as string[] ([\"\"]),",
            "     DF_COLUMNS_TO_CAST_BACK_TO_BOOLEAN as string[] ([\"\"]),",
            "     DF_COLUMNS_TO_CAST_BACK_TO_DATE as string[] ([\"\"]),",
            "     DF_COLUMNS_TO_CAST_BACK_TO_DOUBLE as string[] ([\"\"]),",
            "     DF_COLUMNS_TO_CAST_BACK_TO_FLOAT as string[] ([\"\"]),",
            "     DF_COLUMNS_TO_CAST_BACK_TO_INTEGER as string[] ([\"\"]),",
            "     DF_COLUMNS_TO_CAST_BACK_TO_LONG as string[] ([\"\"]),",
            "     DF_COLUMNS_TO_CAST_BACK_TO_TIMESTAMP as string[] ([\"\"])",
            "}",
            "source(allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'table',",
            "     tableName: ($DF_SOURCE_TABLE),",
            "     schemaName: ($DF_SOURCE_SCHEMA),",
            "     store: 'snowflake',",
            "     store: 'snowflakeV2',",
            "     partitionBy('roundRobin', 32)) ~> Source",
            "FlattenValuesOutOfArray call(mapColumn(",
            "          each(match(name!='DELPHIX_COMPLIANCE_SERVICE_BATCH_GROUP'))",
            "     ),",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true,",
            "     output(",
            "          headers as [string,string],",
            "          body as (timestamp as date, status as string, message as string, trace_id as string, items as (DELPHIX_COMPLIANCE_SERVICE_BATCH_ID as long)[]),",
            "          status as string",
            "     ),",
            "     allowSchemaDrift: true,",
            "     format: 'rest',",
            "     store: 'restservice',",
            "     timeout: 300,",
            "     requestInterval: 0,",
            "     headers = ['Run-Id' -> $runId, 'Field-Algorithm-Assignment' -> $DF_FIELD_ALGORITHM_ASSIGNMENT, 'Fail-On-Non-Conformant-Data' -> iif($DF_FAIL_ON_NONCONFORMANT_DATA,'true','false'), 'Field-Date-Format' -> $DF_FIELD_DATE_FORMAT],",
            "     httpMethod: 'POST',",
            "     entity: '/v1/masking/batchMaskByColumn',",
            "     headerColumnName: 'headers',",
            "     bodyColumnName: 'body',",
            "     statusColumnName: 'status',",
            "     addResponseCode: true,",
            "     requestFormat: ['type' -> 'json'],",
            "     responseFormat: ['type' -> 'json', 'documentForm' -> 'documentPerLine'],",
            "     columnTypeMap: ['body'->'$DF_BODY_TYPE_MAPPING']) ~> DCSForAzureAPI",
            "Source derive(DELPHIX_COMPLIANCE_SERVICE_SORT_ID = sha2(256, columns())) ~> AddSortKey",
            "AddSortKey sort(asc(DELPHIX_COMPLIANCE_SERVICE_SORT_ID, false)) ~> SortBySortKey",
            "SortBySortKey keyGenerate(output(DELPHIX_COMPLIANCE_SERVICE_BATCH_ID as long),",
            "     startAt: 1L,",
            "     stepValue: 1L) ~> CreateSurrogateKey",
            "CastRequiredColumnsAsStrings derive(each(match(contains($DF_COLUMNS_TO_MASK,#item==name)), concat('x',hex(encode($$))) = array($$))) ~> WrapValuesInArray",
            "CreateSurrogateKey select(mapColumn(",
            "          each(match(!contains($DF_COLUMNS_TO_MASK,#item==name)))",
            "     ),",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true) ~> SelectColumnsUnmasked",
            "WrapValuesInArray aggregate(groupBy(DELPHIX_COMPLIANCE_SERVICE_BATCH_GROUP = DELPHIX_COMPLIANCE_SERVICE_BATCH_ID%$DF_NUMBER_OF_BATCHES),",
            "     each(match((startsWith(name,'x')&&not(contains($DF_COLUMNS_TO_MASK,#item==name)))||(name==\"DELPHIX_COMPLIANCE_SERVICE_BATCH_ID\")), $$ = collect($$))) ~> AggregateColumnsByBatch",
            "AggregateColumnsByBatch derive(each(match(startsWith(name,'x')||(name==\"DELPHIX_COMPLIANCE_SERVICE_BATCH_ID\")), $$ = flatten($$))) ~> FlattenValuesOutOfArray",
            "DCSForAzureAPI assert(expectTrue(toInteger(regexExtract(status, '(\\\\d+)', 1)) == 200, false, 'Failed_request', null, iif(isNull(body.message), status, concatWS(', ', 'timestamp: ' + toString(body.timestamp), 'status: ' + body.status, 'message: ' + body.message, 'trace_id: ' + body.trace_id))),",
            "     abort: true) ~> AssertNoFailures",
            "AssertNoFailures foldDown(unroll(body.items),",
            "     mapColumn(",
            "          every(body.items,match(name==\"DELPHIX_COMPLIANCE_SERVICE_BATCH_ID\")),",
            "          every(body.items,match(startsWith(name,'x')),",
            "               decode(unhex(replace($$,'x',''))) = $$)",
            "     ),",
            "     skipDuplicateMapInputs: false,",
            "     skipDuplicateMapOutputs: false) ~> FlattenAggregateData",
            "SelectColumnsUnmasked, TrimMaskedStrings join(SelectColumnsUnmasked@DELPHIX_COMPLIANCE_SERVICE_BATCH_ID == FlattenAggregateData@DELPHIX_COMPLIANCE_SERVICE_BATCH_ID,",
            "     joinType:'inner',",
            "     matchType:'exact',",
            "     ignoreSpaces: false,",
            "     broadcast: 'off')~> JoinMaskedAndUnmaskedData",
            "CastColumnsBackAsRequired derive(each(match(type=='string'), $$ = substring($$, 1, $DF_TRIM_LENGTHS[toInteger($# - 1)]))) ~> TrimMaskedStrings",
            "CreateSurrogateKey derive(each(match(contains($DF_COLUMNS_TO_CAST_AS_STRINGS,#item==name)), $$ = toString($$))) ~> CastRequiredColumnsAsStrings",
            "FlattenAggregateData derive(each(match(contains($DF_COLUMNS_TO_CAST_BACK_TO_BINARY,#item==name)), $$ = toBinary($$)),",
            "          each(match(contains($DF_COLUMNS_TO_CAST_BACK_TO_BOOLEAN,#item==name)), $$ = toBoolean($$)),",
            "          each(match(contains($DF_COLUMNS_TO_CAST_BACK_TO_DATE,#item==name)), $$ = toDate(toString($$))),",
            "          each(match(contains($DF_COLUMNS_TO_CAST_BACK_TO_DOUBLE,#item==name)), $$ = toDouble($$)),",
            "          each(match(contains($DF_COLUMNS_TO_CAST_BACK_TO_FLOAT,#item==name)), $$ = toFloat($$)),",
            "          each(match(contains($DF_COLUMNS_TO_CAST_BACK_TO_INTEGER,#item==name)), $$ = toInteger($$)),",
            "          each(match(contains($DF_COLUMNS_TO_CAST_BACK_TO_LONG,#item==name)), $$ = toLong($$)),",
            "          each(match(contains($DF_COLUMNS_TO_CAST_BACK_TO_TIMESTAMP,#item==name)), $$ = toTimestamp(toString($$)))) ~> CastColumnsBackAsRequired",
            "JoinMaskedAndUnmaskedData sink(allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'table',",
            "     tableName: ($DF_SINK_TABLE),",
            "     schemaName: ($DF_SINK_SCHEMA),",
            "     deletable: false,",
            "     insertable: true,",
            "     updateable: false,",
            "     upsertable: false,",
            "     store: 'snowflake',",
            "     store: 'snowflakeV2',",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true,",
            "     stageInsert: true,",
            "     mapColumn(",
            "          each(match(name!=\"DELPHIX_COMPLIANCE_SERVICE_BATCH_ID\"&&name!=\"DELPHIX_COMPLIANCE_SERVICE_SORT_ID\"))",
            "     )) ~> Sink"
          ]
        }
      },
      "dependsOn": []
    },
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_Snowflake_to_Snowflake_filtered_mask_params_df')]",
      "type": "Microsoft.DataFactory/factories/dataflows",
      "apiVersion": "2018-06-01",
      "properties": {
        "folder": {
          "name": "dcsazure_Snowflake_to_Snowflake"
        },
        "type": "MappingDataFlow",
        "typeProperties": {
          "sources": [
            {
              "linkedService": {
                "referenceName": "[parameters('Metadata Datastore')]",
                "type": "LinkedServiceReference"
              },
              "name": "Ruleset",
              "description": "Get the ruleset table from the metadata store at DF_METADATA_SCHEMA.DF_METADATA_RULESET_TABLE"
            },
            {
              "linkedService": {
                "referenceName": "[parameters('Metadata Datastore')]",
                "type": "LinkedServiceReference"
              },
              "name": "TypeMapping",
              "description": "Get the type mapping table from the metadata store at DF_METADATA_STORE.DF_METADATA_ADF_TYPE_MAPPING_TABLE"
            }
          ],
          "sinks": [
            {
              "name": "MaskingParameterOutput",
              "description": "Sink results of computing masking parameters to activity output cache"
            }
          ],
          "transformations": [
            {
              "name": "FilterToSingleTable",
              "description": "Filter ruleset table down to the table in question by specifying dataset, specified_database, specified_schema, identified_table, and assigned_algorithm - making sure they match the dataset associated with each version of the dataflow, DF_SOURCE_DATABASE, DF_SOURCE_SCHEMA, DF_SOURCE_TABLE, and not empty or null (respectively). This filters the ruleset down to only the rules that need to be applied for masking this particular table"
            },
            {
              "name": "RulesetWithTypes",
              "description": "Join the ruleset table with the type mapping table based on the type of the column and the translation of that type to an ADF type"
            },
            {
              "name": "RulesetWithAlgorithmTypeMapping",
              "description": "Generate several columns:\n\n    output_row that always contains 1 (used later for Aggregate and Join operations)\n    adf_type_conversion that contains a string like <column_name> as <adf_type>\n    column_width_estimate that contains an integer that uses DF_COLUMN_WIDTH_ESTIMATE as the width for any column where identified_column_max_length is not positive, and identified_column_max_length plus some padding otherwise"
            },
            {
              "name": "GenerateMaskParameters",
              "description": "Grouped by output_row produce the following aggregates\n\n    FieldAlgorithmAssignments - a JSON string that maps a column name to its assigned algorithm\n    ColumnsToMask - a list of the column names that have an algorithm assigned\n    DataFactoryTypeMapping - a string that can be used by ADF to parse the output of a call to the Delphix masking endpoint, leveraging the adf_type_conversion column derived previously\n    NumberOfBatches - an integer value determined by computing the number of batches leveraging the max row_count as specified in the ruleset table, and the sum of column_width_estimate column derived previously\n    TrimLengths - a list of the actual widths of the columns so that will be used by the masking data flow to trim output before sinking"
            },
            {
              "name": "FilterToDataSourceType",
              "description": "Filter type mapping table down to only the dataset in question"
            },
            {
              "name": "ParseMetadata",
              "description": "Parse the content from the metadata column that contains JSON, specifically handling parsing of known keys (i.e. date_format)"
            },
            {
              "name": "StringCastingWithAdfType",
              "description": "Join columns that need to be cast to string and the type mapping table, so we can determine casting requirements"
            },
            {
              "name": "CreateColumnsToCastBackTo",
              "description": "Aggregating column names by adf_type to produce ColumnsToCastBackTo,\nwhich consists of a list of columns, separated by \",\" so that when they are aggregated via collect later the list of items is an array of quote-wrapped column names"
            },
            {
              "name": "CreateColumnsToCastBackParameters",
              "description": "Take the correct value of 'ColumnsToCastBackTo' based on the 'adf_type', one for each of the types we need to cast back to: Binary, Boolean, Date, Double, Float, Integer, Long, Timestamp"
            },
            {
              "name": "FilterToRowsWithStringCasting",
              "description": "Filtering rows where 'treat_as_string' is true"
            },
            {
              "name": "CreateColumnsToCastAsStrings",
              "description": "Aggregating column names to produce ColumnsToCastAsStrings"
            },
            {
              "name": "CombineAllStringCastingParameters",
              "description": "Combine tables to have ColumnsToCastAsStrings and ColumnsToCastBackTo* parameters"
            },
            {
              "name": "AggregateColumnsToCastBackParameters",
              "description": "Create ColumnsToCastBackTo* by collecting on the previously computed columns"
            },
            {
              "name": "DateFormatString",
              "description": "Derive columns as necessary for handling the parsed data (i.e. consume parsed_metadata.date_format and put it in a column date_format_string), and add an output_row column that always contains 1 (used later for Aggregate and Join operations)"
            },
            {
              "name": "DateFormatHeader",
              "description": "Create DateFormatAssignment, grouped by output_row (which is always 1), generating a JSON string that maps a column to its specified date format"
            },
            {
              "name": "AllMaskingParameters",
              "description": "Perform an inner join on output_row with the computed casting parameters and date format headers - combining all masking parameters into the same output stream"
            },
            {
              "name": "DateFormatHeaderHandlingNulls",
              "description": "Update column DateFormatAssignments to coalesce DateFormatAssignments, and NoFormatHeader (i.e. if DateFormatAssignments is null, take NoFormatHeader, which won't be null)"
            },
            {
              "name": "RemoveUnnecessaryColumns",
              "description": "Remove redundant columns after joining date format and string casting parameters"
            },
            {
              "name": "SplitOnDateFormat",
              "description": "Split the data into two streams, data that contains a specified date\nformat, and data that does not"
            },
            {
              "name": "NoFormatHeader",
              "description": "Create NoFormatHeader, that generates a JSON string containing an empty map when all values are null, grouped by output_row (which is always 1)"
            },
            {
              "name": "JoinDateHeaders",
              "description": "Full outer join both DateFormatHeader and NoFormatHeader where output_row = output_row"
            },
            {
              "name": "HandleCompositeAlgorithms",
              "description": "Conditionally distributing the data in assigned_algorithm groups, the type of data in assigned_algorithms"
            },
            {
              "name": "SimplifySimpleRulesetTable",
              "description": "Simplify the columns of the ruleset table for algorithms that are always applied"
            },
            {
              "name": "ParseAlgorithm",
              "description": "Parse conditional algorithm assignment"
            },
            {
              "name": "FlattenAlgorithmAssignments",
              "description": "Unroll the conditions from the conditional algorithm assignment"
            },
            {
              "name": "ParseKeyColumn",
              "description": "Parse key column conditions"
            },
            {
              "name": "FlattenKeyConditions",
              "description": "Unroll the aliases and conditions from the key column"
            },
            {
              "name": "JoinConditionalAlgorithms",
              "description": "Join the key column, its conditions, and the algorithms assigned to those conditions"
            },
            {
              "name": "FilterToConditionKey",
              "description": "Filter out rows that don't apply to this condition key, and rows that don't include an assigned algorithm"
            },
            {
              "name": "SimplifyConditionalRulesetTable",
              "description": "Rename columns in the conditional ruleset table to match the simplified ruleset table"
            },
            {
              "name": "UnionAllRules",
              "description": "Combining rows from conditional and non-conditional ruleset tables"
            },
            {
              "name": "FlattenConditionalFormatting",
              "description": "Unroll the conditions from the conditional date_format assignment"
            },
            {
              "name": "FilterUnmatchingAlias",
              "description": "Filter down to only this filer alias, as necessary"
            },
            {
              "name": "StringCastingHandling",
              "description": "Derive columns for handling string casting"
            },
            {
              "name": "JoinDateFormatAndStringCastingParameters",
              "description": "Combine date format and string casting related parameters into a single table"
            },
            {
              "name": "ComputeCastingDefaultsIfMissing",
              "description": "For all casting parameters that are currently null, set them instead to the empty list"
            }
          ],
          "scriptLines": [
            "parameters{",
            "     runId as string (''),",
            "     DF_METADATA_SCHEMA as string ('dbo'),",
            "     DF_METADATA_RULESET_TABLE as string ('discovered_ruleset'),",
            "     DF_METADATA_ADF_TYPE_MAPPING_TABLE as string ('adf_type_mapping'),",
            "     DF_SOURCE_DATABASE as string (''),",
            "     DF_SOURCE_SCHEMA as string (''),",
            "     DF_SOURCE_TABLE as string (''),",
            "     DF_COLUMN_WIDTH_ESTIMATE as integer (1000),",
            "     DF_FILTER_KEY as string (''),",
            "     DF_DATASET as string ('SNOWFLAKE')",
            "}",
            "source(output(",
            "          dataset as string,",
            "          specified_database as string,",
            "          specified_schema as string,",
            "          identified_table as string,",
            "          identified_column as string,",
            "          identified_column_type as string,",
            "          identified_column_max_length as integer,",
            "          ordinal_position as integer,",
            "          row_count as long,",
            "          source_metadata as string,",
            "          profiled_domain as string,",
            "          profiled_algorithm as string,",
            "          confidence_score as decimal(6,5),",
            "          rows_profiled as long,",
            "          assigned_algorithm as string,",
            "          last_profiled_updated_timestamp as timestamp,",
            "          discovery_complete as boolean,",
            "          latest_event as string,",
            "          algorithm_metadata as string",
            "     ),",
            "     allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'table',",
            "     store: 'sqlserver',",
            "     schemaName: ($DF_METADATA_SCHEMA),",
            "     tableName: ($DF_METADATA_RULESET_TABLE),",
            "     isolationLevel: 'READ_UNCOMMITTED') ~> Ruleset",
            "source(output(",
            "          dataset as string,",
            "          dataset_type as string,",
            "          adf_type as string",
            "     ),",
            "     allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'table',",
            "     store: 'sqlserver',",
            "     schemaName: ($DF_METADATA_SCHEMA),",
            "     tableName: ($DF_METADATA_ADF_TYPE_MAPPING_TABLE),",
            "     isolationLevel: 'READ_UNCOMMITTED') ~> TypeMapping",
            "Ruleset filter(equalsIgnoreCase(dataset, $DF_DATASET)",
            "&& equalsIgnoreCase(specified_database, $DF_SOURCE_DATABASE)",
            "&& equalsIgnoreCase(specified_schema, $DF_SOURCE_SCHEMA)",
            "&& equalsIgnoreCase(identified_table, $DF_SOURCE_TABLE)",
            "&& !equalsIgnoreCase(assigned_algorithm, '')",
            "&& !isNull(assigned_algorithm)) ~> FilterToSingleTable",
            "UnionAllRules, FilterToDataSourceType join(identified_column_type <=> dataset_type,",
            "     joinType:'inner',",
            "     matchType:'exact',",
            "     ignoreSpaces: false,",
            "     broadcast: 'left')~> RulesetWithTypes",
            "RulesetWithTypes derive(output_row = 1,",
            "          adf_type_conversion = concat(identified_column, ' as ', adf_type),",
            "          column_width_estimate = iif(identified_column_max_length > 0, identified_column_max_length+4, $DF_COLUMN_WIDTH_ESTIMATE)) ~> RulesetWithAlgorithmTypeMapping",
            "RulesetWithAlgorithmTypeMapping aggregate(groupBy(output_row),",
            "     FieldAlgorithmAssignments = regexReplace(reduce(mapAssociation(keyValues(collect(concat('x',hex(encode(identified_column)))), collect(assigned_algorithm)), '\"' + #key + '\":\"' + #value + '\"'), '{', #acc + #item + ',', #result + '}'), ',}', '}'),",
            "          ColumnsToMask = regexReplace(reduce(collect(identified_column), '[',  #acc + '\"' + #item + '\",', #result + ']'), ',]', ']'),",
            "          DataFactoryTypeMapping = concat(\"'\", '(timestamp as date, status as string, message as string, trace_id as string, items as (DELPHIX_COMPLIANCE_SERVICE_BATCH_ID as long, ',",
            "    regexReplace(reduce(collect(concat('x',hex(encode(identified_column))) + ' as ' + adf_type), '', #acc + #item + ', ', #result + ')'), ', \\\\)', ')'),",
            "    '[])', \"'\"),",
            "          TrimLengths = regexReplace(reduce(collect(identified_column_max_length), '[',  #acc + toString(#item) + ',', toString(#result) + ']'), ',]', ']')) ~> GenerateMaskParameters",
            "TypeMapping filter(equalsIgnoreCase(dataset, $DF_DATASET)) ~> FilterToDataSourceType",
            "FilterToSingleTable parse(parsed_metadata = algorithm_metadata ? (date_format as string,",
            "          treat_as_string as boolean),",
            "          conditional_formatting = algorithm_metadata ? (key_column as string,",
            "          conditions as (alias as string, date_format as string)[]),",
            "     format: 'json',",
            "     documentForm: 'singleDocument') ~> ParseMetadata",
            "FilterToRowsWithStringCasting, FilterToDataSourceType join(identified_column_type == dataset_type,",
            "     joinType:'inner',",
            "     matchType:'exact',",
            "     ignoreSpaces: false,",
            "     broadcast: 'auto')~> StringCastingWithAdfType",
            "StringCastingWithAdfType aggregate(groupBy(adf_type),",
            "     ColumnsToCastBackTo = ltrim(rtrim(reduce(collect(identified_column), '',  #acc + '\"' + #item + '\",', #result), '\",'), '\"')) ~> CreateColumnsToCastBackTo",
            "CreateColumnsToCastBackTo derive(ColumnsToCastBackToBinary = iif(adf_type == 'binary', ColumnsToCastBackTo, toString(null())),",
            "          ColumnsToCastBackToBoolean = iif(adf_type == 'boolean', ColumnsToCastBackTo, toString(null())),",
            "          ColumnsToCastBackToDate = iif(adf_type == 'date', ColumnsToCastBackTo, toString(null())),",
            "          ColumnsToCastBackToDouble = iif(adf_type == 'double', ColumnsToCastBackTo, toString(null())),",
            "          ColumnsToCastBackToFloat = iif(adf_type == 'float', ColumnsToCastBackTo, toString(null())),",
            "          ColumnsToCastBackToInteger = iif(adf_type == 'integer', ColumnsToCastBackTo, toString(null())),",
            "          ColumnsToCastBackToLong = iif(adf_type == 'long', ColumnsToCastBackTo, toString(null())),",
            "          ColumnsToCastBackToTimestamp = iif(adf_type == 'timestamp', ColumnsToCastBackTo, toString(null())),",
            "          output_row = 1) ~> CreateColumnsToCastBackParameters",
            "StringCastingHandling filter(not(isNull(treat_as_string)) && treat_as_string) ~> FilterToRowsWithStringCasting",
            "FilterToRowsWithStringCasting aggregate(groupBy(output_row),",
            "     ColumnsToCastAsStrings = regexReplace(reduce(collect(identified_column), '[',  #acc + '\"' + #item + '\",', #result + ']'), ',]', ']')) ~> CreateColumnsToCastAsStrings",
            "CreateColumnsToCastAsStrings, AggregateColumnsToCastBackParameters join(CreateColumnsToCastAsStrings@output_row == AggregateColumnsToCastBackParameters@output_row,",
            "     joinType:'inner',",
            "     matchType:'exact',",
            "     ignoreSpaces: false,",
            "     broadcast: 'auto')~> CombineAllStringCastingParameters",
            "CreateColumnsToCastBackParameters aggregate(groupBy(output_row),",
            "     ColumnsToCastBackToBinary = regexReplace(reduce(collect(ColumnsToCastBackToBinary), '[',  #acc + '\"' + #item + '\",', #result + ']'), ',]', ']'),",
            "          ColumnsToCastBackToBoolean = regexReplace(reduce(collect(ColumnsToCastBackToBoolean), '[',  #acc + '\"' + #item + '\",', #result + ']'), ',]', ']'),",
            "          ColumnsToCastBackToDate = regexReplace(reduce(collect(ColumnsToCastBackToDate), '[',  #acc + '\"' + #item + '\",', #result + ']'), ',]', ']'),",
            "          ColumnsToCastBackToDouble = regexReplace(reduce(collect(ColumnsToCastBackToDouble), '[',  #acc + '\"' + #item + '\",', #result + ']'), ',]', ']'),",
            "          ColumnsToCastBackToFloat = regexReplace(reduce(collect(ColumnsToCastBackToFloat), '[',  #acc + '\"' + #item + '\",', #result + ']'), ',]', ']'),",
            "          ColumnsToCastBackToInteger = regexReplace(reduce(collect(ColumnsToCastBackToInteger), '[',  #acc + '\"' + #item + '\",', #result + ']'), ',]', ']'),",
            "          ColumnsToCastBackToLong = regexReplace(reduce(collect(ColumnsToCastBackToLong), '[',  #acc + '\"' + #item + '\",', #result + ']'), ',]', ']'),",
            "          ColumnsToCastBackToTimestamp = regexReplace(reduce(collect(ColumnsToCastBackToTimestamp), '[',  #acc + '\"' + #item + '\",', #result + ']'), ',]', ']')) ~> AggregateColumnsToCastBackParameters",
            "FilterUnmatchingAlias derive(output_row = 1,",
            "          date_format_string = coalesce(conditional_date_format, parsed_metadata.date_format)) ~> DateFormatString",
            "SplitOnDateFormat@ContainsDateFormat aggregate(groupBy(output_row),",
            "     DateFormatAssignments = regexReplace(reduce(mapAssociation(keyValues(collect(concat('x',hex(encode(identified_column)))), collect(date_format_string)), '\"' + #key + '\":\"' + #value + '\"'), '{', #acc + #item + ',', #result + '}'), ',}', '}')) ~> DateFormatHeader",
            "GenerateMaskParameters, ComputeCastingDefaultsIfMissing join(GenerateMaskParameters@output_row == RemoveUnnecessaryColumns@output_row,",
            "     joinType:'inner',",
            "     matchType:'exact',",
            "     ignoreSpaces: false,",
            "     broadcast: 'auto')~> AllMaskingParameters",
            "JoinDateHeaders derive(DateFormatAssignments = coalesce(DateFormatAssignments,NoFormatHeader),",
            "          output_row = coalesce(DateFormatHeader@output_row, NoFormatHeader@output_row)) ~> DateFormatHeaderHandlingNulls",
            "JoinDateFormatAndStringCastingParameters select(mapColumn(",
            "          output_row = DateFormatHeaderHandlingNulls@output_row,",
            "          DateFormatAssignments,",
            "          output_row = CreateColumnsToCastAsStrings@output_row,",
            "          ColumnsToCastAsStrings,",
            "          output_row = AggregateColumnsToCastBackParameters@output_row,",
            "          ColumnsToCastBackToBinary,",
            "          ColumnsToCastBackToBoolean,",
            "          ColumnsToCastBackToDate,",
            "          ColumnsToCastBackToDouble,",
            "          ColumnsToCastBackToFloat,",
            "          ColumnsToCastBackToInteger,",
            "          ColumnsToCastBackToLong,",
            "          ColumnsToCastBackToTimestamp",
            "     ),",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true) ~> RemoveUnnecessaryColumns",
            "DateFormatString split(not(isNull(date_format_string)),",
            "     disjoint: false) ~> SplitOnDateFormat@(ContainsDateFormat, DoesNotContainDateFormat)",
            "SplitOnDateFormat@DoesNotContainDateFormat aggregate(groupBy(output_row),",
            "     NoFormatHeader = reduce(collect(date_format_string), '{', #acc + #item + ',', #result + '}')) ~> NoFormatHeader",
            "DateFormatHeader, NoFormatHeader join(DateFormatHeader@output_row == NoFormatHeader@output_row,",
            "     joinType:'outer',",
            "     matchType:'exact',",
            "     ignoreSpaces: false,",
            "     broadcast: 'auto')~> JoinDateHeaders",
            "FilterToSingleTable split(like(assigned_algorithm, '[%]'),",
            "     like(assigned_algorithm, '{%}'),",
            "     disjoint: false) ~> HandleCompositeAlgorithms@(KeyColumn, CompositeAlgorithm, StandardAlgorithm)",
            "HandleCompositeAlgorithms@StandardAlgorithm select(mapColumn(",
            "          dataset,",
            "          specified_database,",
            "          specified_schema,",
            "          identified_table,",
            "          identified_column,",
            "          identified_column_type,",
            "          identified_column_max_length,",
            "          row_count,",
            "          assigned_algorithm",
            "     ),",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true) ~> SimplifySimpleRulesetTable",
            "HandleCompositeAlgorithms@CompositeAlgorithm parse(conditional_algorithm = assigned_algorithm ? (key_column as string,",
            "          conditions as (alias as string, algorithm as string)[]),",
            "     format: 'json',",
            "     documentForm: 'singleDocument') ~> ParseAlgorithm",
            "ParseAlgorithm foldDown(unroll(conditional_algorithm.conditions),",
            "     mapColumn(",
            "          dataset,",
            "          specified_database,",
            "          specified_schema,",
            "          identified_table,",
            "          identified_column,",
            "          identified_column_type,",
            "          identified_column_max_length,",
            "          row_count,",
            "          key_column = conditional_algorithm.key_column,",
            "          alias = conditional_algorithm.conditions.alias,",
            "          algorithm = conditional_algorithm.conditions.algorithm",
            "     ),",
            "     skipDuplicateMapInputs: false,",
            "     skipDuplicateMapOutputs: false) ~> FlattenAlgorithmAssignments",
            "HandleCompositeAlgorithms@KeyColumn parse(conditions_set = assigned_algorithm ? (alias as string, condition as string)[],",
            "     format: 'json',",
            "     documentForm: 'singleDocument') ~> ParseKeyColumn",
            "ParseKeyColumn foldDown(unroll(conditions_set),",
            "     mapColumn(",
            "          dataset,",
            "          specified_database,",
            "          specified_schema,",
            "          identified_table,",
            "          identified_column,",
            "          identified_column_type,",
            "          identified_column_max_length,",
            "          row_count,",
            "          alias = conditions_set.alias,",
            "          condition = conditions_set.condition",
            "     ),",
            "     skipDuplicateMapInputs: false,",
            "     skipDuplicateMapOutputs: false) ~> FlattenKeyConditions",
            "FlattenKeyConditions, FlattenAlgorithmAssignments join(FlattenKeyConditions@identified_column == key_column",
            "     && FlattenKeyConditions@alias == FlattenAlgorithmAssignments@alias,",
            "     joinType:'inner',",
            "     matchType:'exact',",
            "     ignoreSpaces: false,",
            "     broadcast: 'auto')~> JoinConditionalAlgorithms",
            "JoinConditionalAlgorithms filter(equalsIgnoreCase(FlattenAlgorithmAssignments@alias, $DF_FILTER_KEY) && not(isNull(algorithm)) && algorithm != '') ~> FilterToConditionKey",
            "FilterToConditionKey select(mapColumn(",
            "          condition,",
            "          dataset = FlattenAlgorithmAssignments@dataset,",
            "          specified_database = FlattenAlgorithmAssignments@specified_database,",
            "          specified_schema = FlattenAlgorithmAssignments@specified_schema,",
            "          identified_table = FlattenAlgorithmAssignments@identified_table,",
            "          identified_column = FlattenAlgorithmAssignments@identified_column,",
            "          identified_column_type = FlattenAlgorithmAssignments@identified_column_type,",
            "          identified_column_max_length = FlattenAlgorithmAssignments@identified_column_max_length,",
            "          row_count = FlattenAlgorithmAssignments@row_count,",
            "          key_column,",
            "          assigned_algorithm = algorithm",
            "     ),",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true) ~> SimplifyConditionalRulesetTable",
            "SimplifyConditionalRulesetTable, SimplifySimpleRulesetTable union(byName: true)~> UnionAllRules",
            "ParseMetadata foldDown(unroll(conditional_formatting.conditions),",
            "     mapColumn(",
            "          dataset,",
            "          specified_database,",
            "          specified_schema,",
            "          identified_table,",
            "          identified_column,",
            "          identified_column_type,",
            "          identified_column_max_length,",
            "          ordinal_position,",
            "          row_count,",
            "          algorithm_metadata,",
            "          profiled_domain,",
            "          profiled_algorithm,",
            "          confidence_score,",
            "          rows_profiled,",
            "          assigned_algorithm,",
            "          last_profiled_updated_timestamp,",
            "          parsed_metadata,",
            "          conditional_formatting_key_column = conditional_formatting.key_column,",
            "          alias = conditional_formatting.conditions.alias,",
            "          conditional_date_format = conditional_formatting.conditions.date_format",
            "     ),",
            "     skipDuplicateMapInputs: false,",
            "     skipDuplicateMapOutputs: false) ~> FlattenConditionalFormatting",
            "FlattenConditionalFormatting filter(alias == $DF_FILTER_KEY || isNull(alias)) ~> FilterUnmatchingAlias",
            "ParseMetadata derive(output_row = 1,",
            "          treat_as_string = parsed_metadata.treat_as_string) ~> StringCastingHandling",
            "DateFormatHeaderHandlingNulls, CombineAllStringCastingParameters join(DateFormatHeaderHandlingNulls@output_row == CreateColumnsToCastAsStrings@output_row,",
            "     joinType:'left',",
            "     matchType:'exact',",
            "     ignoreSpaces: false,",
            "     broadcast: 'auto')~> JoinDateFormatAndStringCastingParameters",
            "RemoveUnnecessaryColumns derive(each(match(startsWith(name,'ColumnsToCast')), $$ = coalesce($$, '[]'))) ~> ComputeCastingDefaultsIfMissing",
            "AllMaskingParameters sink(validateSchema: false,",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true,",
            "     store: 'cache',",
            "     format: 'inline',",
            "     output: true,",
            "     saveOrder: 1) ~> MaskingParameterOutput"
          ]
        }
      },
      "dependsOn": []
    },
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_Snowflake_to_Snowflake_filtered_mask_df')]",
      "type": "Microsoft.DataFactory/factories/dataflows",
      "apiVersion": "2018-06-01",
      "properties": {
        "description": "Perform masking on a subset of the data that matches the specified filter",
        "folder": {
          "name": "dcsazure_Snowflake_to_Snowflake"
        },
        "type": "MappingDataFlow",
        "typeProperties": {
          "sources": [
            {
              "linkedService": {
                "referenceName": "[parameters('Snowflake_Source_New')]",
                "type": "LinkedServiceReference"
              },
              "name": "Source",
              "description": "Select source data at DF_SOURCE_SCHEMA.DF_SOURCE_TABLE using an inline dataset"
            }
          ],
          "sinks": [
            {
              "linkedService": {
                "referenceName": "[parameters('Snowflake_Sink_New')]",
                "type": "LinkedServiceReference"
              },
              "name": "Sink",
              "description": "Sink results of masking to data store by sinking the unrolled results of the masking call to the columns of the same name in the data sink"
            }
          ],
          "transformations": [
            {
              "name": "DCSForAzureAPI",
              "linkedService": {
                "referenceName": "[parameters('ProdDCSForAzureService')]",
                "type": "LinkedServiceReference"
              }
            },
            {
              "name": "AddSortKey",
              "description": "Create column DELPHIX_COMPLIANCE_SERVICE_SORT_ID that consists of SHA of the data across all columns in the table - every row will have this value and it cannot be null"
            },
            {
              "name": "SortBySortKey",
              "description": "Sort the table by the value in DELPHIX_COMPLIANCE_SERVICE_SORT_ID, as we need the table to be in a particular order before we apply a surrogate key"
            },
            {
              "name": "CreateSurrogateKey",
              "description": "Add a DELPHIX_COMPLIANCE_SERVICE_BATCH_ID column that increments by 1 and starts at 1 after applying the sorting"
            },
            {
              "name": "WrapValuesInArray",
              "description": "For each column we wish to mask, convert the value into an array, this is needed to preserve null values as null when using collect, as null values become [], and encode the column names to handle body type mapping changes"
            },
            {
              "name": "SelectColumnsUnmasked",
              "description": "Select only columns that don't require masking"
            },
            {
              "name": "AggregateColumnsByBatch",
              "description": "For each column we wish to mask, aggregate to a list using collect, grouped by DELPHIX_COMPLIANCE_SERVICE_BATCH_ID with integer division by DF_NUMBER_OF_ROWS_PER_BATCH - so there will be a targeted number of total rows in each aggregation, name the group as DELPHIX_COMPLIANCE_SERVICE_BATCH_GROUP"
            },
            {
              "name": "FlattenValuesOutOfArray",
              "description": "For each column we wish to mask, flatten the value out of the array, in the case where the value was previously [], it becomes null"
            },
            {
              "name": "AssertNoFailures",
              "description": "Confirm that we received a 200 response status from the API request"
            },
            {
              "name": "FlattenAggregateData",
              "description": "Unroll the API response body into decoded named columns"
            },
            {
              "name": "JoinMaskedAndUnmaskedData",
              "description": "Inner join on SelectColumnsUnmasked and TrimMaskedStrings based on matching DELPHIX_COMPLIANCE_SERVICE_BATCH_ID"
            },
            {
              "name": "TrimMaskedStrings",
              "description": "For each column with a string type, trim the string to length based on the value in DF_TRIM_LENGTHS - this is needed as masking a string may produce a longer string that exceeds the column width in the sink"
            },
            {
              "name": "ApplyTableFilter",
              "description": "Filter base table based on supplied filter"
            },
            {
              "name": "CastRequiredColumnsAsStrings",
              "description": "For columns that require casting to string, cast them to string"
            },
            {
              "name": "CastColumnsBackAsRequired",
              "description": "For columns that need to be cast back to a compatible type, cast them back"
            }
          ],
          "scriptLines": [
            "parameters{",
            "     runId as string (''),",
            "     DF_SOURCE_SCHEMA as string (''),",
            "     DF_SOURCE_TABLE as string (''),",
            "     DF_SINK_SCHEMA as string (''),",
            "     DF_SINK_TABLE as string (''),",
            "     DF_FIELD_ALGORITHM_ASSIGNMENT as string ('{}'),",
            "     DF_COLUMNS_TO_MASK as string[] ([\"\"]),",
            "     DF_BODY_TYPE_MAPPING as string ('(timestamp as date, status as string, message as string, trace_id as string, items as (DELPHIX_COMPLIANCE_SERVICE_BATCH_ID as long)[])'),",
            "     DF_TRIM_LENGTHS as integer[] ([1000]),",
            "     DF_FAIL_ON_NONCONFORMANT_DATA as boolean (true()),",
            "     DF_FIELD_DATE_FORMAT as string ('{}'),",
            "     DF_FILTER_CONDITION as boolean (true()),",
            "     DF_NUMBER_OF_ROWS_PER_BATCH as integer (1000),",
            "     DF_COLUMNS_TO_CAST_AS_STRINGS as string[] ([\"\"]),",
            "     DF_COLUMNS_TO_CAST_BACK_TO_BINARY as string[] ([\"\"]),",
            "     DF_COLUMNS_TO_CAST_BACK_TO_BOOLEAN as string[] ([\"\"]),",
            "     DF_COLUMNS_TO_CAST_BACK_TO_DATE as string[] ([\"\"]),",
            "     DF_COLUMNS_TO_CAST_BACK_TO_DOUBLE as string[] ([\"\"]),",
            "     DF_COLUMNS_TO_CAST_BACK_TO_FLOAT as string[] ([\"\"]),",
            "     DF_COLUMNS_TO_CAST_BACK_TO_INTEGER as string[] ([\"\"]),",
            "     DF_COLUMNS_TO_CAST_BACK_TO_LONG as string[] ([\"\"]),",
            "     DF_COLUMNS_TO_CAST_BACK_TO_TIMESTAMP as string[] ([\"\"])",
            "}",
            "source(allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'table',",
            "     tableName: ($DF_SOURCE_TABLE),",
            "     schemaName: ($DF_SOURCE_SCHEMA),",
            "     store: 'snowflake',",
            "     store: 'snowflakeV2',",
            "     partitionBy('roundRobin', 32)) ~> Source",
            "FlattenValuesOutOfArray call(mapColumn(",
            "          each(match(name!='DELPHIX_COMPLIANCE_SERVICE_BATCH_GROUP'))",
            "     ),",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true,",
            "     output(",
            "          headers as [string,string],",
            "          body as (timestamp as date, status as string, message as string, trace_id as string, items as (DELPHIX_COMPLIANCE_SERVICE_BATCH_ID as long)[]),",
            "          status as string",
            "     ),",
            "     allowSchemaDrift: true,",
            "     format: 'rest',",
            "     store: 'restservice',",
            "     timeout: 300,",
            "     requestInterval: 0,",
            "     headers = ['Run-Id' -> $runId, 'Field-Algorithm-Assignment' -> $DF_FIELD_ALGORITHM_ASSIGNMENT, 'Fail-On-Non-Conformant-Data' -> iif($DF_FAIL_ON_NONCONFORMANT_DATA,'true','false'), 'Field-Date-Format' -> $DF_FIELD_DATE_FORMAT],",
            "     httpMethod: 'POST',",
            "     entity: '/v1/masking/batchMaskByColumn',",
            "     headerColumnName: 'headers',",
            "     bodyColumnName: 'body',",
            "     statusColumnName: 'status',",
            "     addResponseCode: true,",
            "     requestFormat: ['type' -> 'json'],",
            "     responseFormat: ['type' -> 'json', 'documentForm' -> 'documentPerLine'],",
            "     columnTypeMap: ['body'->'$DF_BODY_TYPE_MAPPING']) ~> DCSForAzureAPI",
            "ApplyTableFilter derive(DELPHIX_COMPLIANCE_SERVICE_SORT_ID = sha2(256, columns())) ~> AddSortKey",
            "AddSortKey sort(asc(DELPHIX_COMPLIANCE_SERVICE_SORT_ID, false)) ~> SortBySortKey",
            "SortBySortKey keyGenerate(output(DELPHIX_COMPLIANCE_SERVICE_BATCH_ID as long),",
            "     startAt: 1L,",
            "     stepValue: 1L) ~> CreateSurrogateKey",
            "CastRequiredColumnsAsStrings derive(each(match(contains($DF_COLUMNS_TO_MASK,#item==name)), concat('x',hex(encode($$))) = array($$))) ~> WrapValuesInArray",
            "CreateSurrogateKey select(mapColumn(",
            "          each(match(!contains($DF_COLUMNS_TO_MASK,#item==name)))",
            "     ),",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true) ~> SelectColumnsUnmasked",
            "WrapValuesInArray aggregate(groupBy(DELPHIX_COMPLIANCE_SERVICE_BATCH_GROUP = toInteger(ceil(DELPHIX_COMPLIANCE_SERVICE_BATCH_ID/$DF_NUMBER_OF_ROWS_PER_BATCH))),",
            "     each(match((startsWith(name,'x')&&not(contains($DF_COLUMNS_TO_MASK,#item==name)))||(name==\"DELPHIX_COMPLIANCE_SERVICE_BATCH_ID\")), $$ = collect($$))) ~> AggregateColumnsByBatch",
            "AggregateColumnsByBatch derive(each(match(startsWith(name,'x')||(name==\"DELPHIX_COMPLIANCE_SERVICE_BATCH_ID\")), $$ = flatten($$))) ~> FlattenValuesOutOfArray",
            "DCSForAzureAPI assert(expectTrue(toInteger(regexExtract(status, '(\\\\d+)', 1)) == 200, false, 'Failed_request', null, iif(isNull(body.message), status, concatWS(', ', 'timestamp: ' + toString(body.timestamp), 'status: ' + body.status, 'message: ' + body.message, 'trace_id: ' + body.trace_id))),",
            "     abort: true) ~> AssertNoFailures",
            "AssertNoFailures foldDown(unroll(body.items),",
            "     mapColumn(",
            "          every(body.items,match(name==\"DELPHIX_COMPLIANCE_SERVICE_BATCH_ID\")),",
            "          every(body.items,match(startsWith(name,'x')),",
            "               decode(unhex(replace($$,'x',''))) = $$)",
            "     ),",
            "     skipDuplicateMapInputs: false,",
            "     skipDuplicateMapOutputs: false) ~> FlattenAggregateData",
            "SelectColumnsUnmasked, TrimMaskedStrings join(SelectColumnsUnmasked@DELPHIX_COMPLIANCE_SERVICE_BATCH_ID == FlattenAggregateData@DELPHIX_COMPLIANCE_SERVICE_BATCH_ID,",
            "     joinType:'inner',",
            "     matchType:'exact',",
            "     ignoreSpaces: false,",
            "     broadcast: 'off')~> JoinMaskedAndUnmaskedData",
            "CastColumnsBackAsRequired derive(each(match(type=='string'), $$ = substring($$, 1, $DF_TRIM_LENGTHS[toInteger($# - 1)]))) ~> TrimMaskedStrings",
            "Source filter($DF_FILTER_CONDITION) ~> ApplyTableFilter",
            "CreateSurrogateKey derive(each(match(contains($DF_COLUMNS_TO_CAST_AS_STRINGS,#item==name)), $$ = toString($$))) ~> CastRequiredColumnsAsStrings",
            "FlattenAggregateData derive(each(match(contains($DF_COLUMNS_TO_CAST_BACK_TO_BINARY,#item==name)), $$ = toBinary($$)),",
            "          each(match(contains($DF_COLUMNS_TO_CAST_BACK_TO_BOOLEAN,#item==name)), $$ = toBoolean($$)),",
            "          each(match(contains($DF_COLUMNS_TO_CAST_BACK_TO_DATE,#item==name)), $$ = toDate(toString($$))),",
            "          each(match(contains($DF_COLUMNS_TO_CAST_BACK_TO_DOUBLE,#item==name)), $$ = toDouble($$)),",
            "          each(match(contains($DF_COLUMNS_TO_CAST_BACK_TO_FLOAT,#item==name)), $$ = toFloat($$)),",
            "          each(match(contains($DF_COLUMNS_TO_CAST_BACK_TO_INTEGER,#item==name)), $$ = toInteger($$)),",
            "          each(match(contains($DF_COLUMNS_TO_CAST_BACK_TO_LONG,#item==name)), $$ = toLong($$)),",
            "          each(match(contains($DF_COLUMNS_TO_CAST_BACK_TO_TIMESTAMP,#item==name)), $$ = toTimestamp(toString($$)))) ~> CastColumnsBackAsRequired",
            "JoinMaskedAndUnmaskedData sink(allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'table',",
            "     tableName: ($DF_SINK_TABLE),",
            "     schemaName: ($DF_SINK_SCHEMA),",
            "     deletable: false,",
            "     insertable: true,",
            "     updateable: false,",
            "     upsertable: false,",
            "     store: 'snowflake',",
            "     store: 'snowflakeV2',",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true,",
            "     stageInsert: true,",
            "     mapColumn(",
            "          each(match(name!=\"DELPHIX_COMPLIANCE_SERVICE_BATCH_ID\"&&name!=\"DELPHIX_COMPLIANCE_SERVICE_SORT_ID\"))",
            "     )) ~> Sink"
          ]
        }
      },
      "dependsOn": []
    },
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_Snowflake_to_Snowflake_mask_source_ds')]",
      "type": "Microsoft.DataFactory/factories/datasets",
      "apiVersion": "2018-06-01",
      "properties": {
        "linkedServiceName": {
          "referenceName": "[parameters('Snowflake_Source_New')]",
          "type": "LinkedServiceReference",
          "parameters": {
            "LS_DATABASE": {
              "value": "@dataset().DS_DATABASE",
              "type": "Expression"
            },
            "LS_WAREHOUSE": {
              "value": "@dataset().DS_WAREHOUSE",
              "type": "Expression"
            },
            "LS_ROLE": {
              "value": "@dataset().DS_ROLE",
              "type": "Expression"
            }
          }
        },
        "parameters": {
          "DS_SCHEMA": {
            "type": "string"
          },
          "DS_TABLE": {
            "type": "string"
          },
          "DS_DATABASE": {
            "type": "string"
          },
          "DS_WAREHOUSE": {
            "type": "string"
          },
          "DS_ROLE": {
            "type": "string"
          }
        },
        "folder": {
          "name": "dcsazure_Snowflake_to_Snowflake"
        },
        "annotations": [],
        "type": "SnowflakeV2Table",
        "schema": [],
        "typeProperties": {
          "schema": {
            "value": "@dataset().DS_SCHEMA",
            "type": "Expression"
          },
          "table": {
            "value": "@dataset().DS_TABLE",
            "type": "Expression"
          }
        }
      },
      "dependsOn": []
    },
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_Snowflake_to_Snowflake_mask_sink_ds')]",
      "type": "Microsoft.DataFactory/factories/datasets",
      "apiVersion": "2018-06-01",
      "properties": {
        "linkedServiceName": {
          "referenceName": "[parameters('Snowflake_Sink_New')]",
          "type": "LinkedServiceReference",
          "parameters": {
            "LS_DATABASE": {
              "value": "@dataset().DS_DATABASE",
              "type": "Expression"
            },
            "LS_WAREHOUSE": {
              "value": "@dataset().DS_WAREHOUSE",
              "type": "Expression"
            },
            "LS_ROLE": {
              "value": "@dataset().DS_ROLE",
              "type": "Expression"
            }
          }
        },
        "parameters": {
          "DS_SCHEMA": {
            "type": "string"
          },
          "DS_TABLE": {
            "type": "string"
          },
          "DS_DATABASE": {
            "type": "string"
          },
          "DS_WAREHOUSE": {
            "type": "string"
          },
          "DS_ROLE": {
            "type": "string"
          }
        },
        "folder": {
          "name": "dcsazure_Snowflake_to_Snowflake"
        },
        "annotations": [],
        "type": "SnowflakeV2Table",
        "schema": [],
        "typeProperties": {
          "schema": {
            "value": "@dataset().DS_SCHEMA",
            "type": "Expression"
          },
          "table": {
            "value": "@dataset().DS_TABLE",
            "type": "Expression"
          }
        }
      },
      "dependsOn": []
    },
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_Snowflake_to_Snowflake_copy_df')]",
      "type": "Microsoft.DataFactory/factories/dataflows",
      "apiVersion": "2018-06-01",
      "properties": {
        "folder": {
          "name": "dcsazure_Snowflake_to_Snowflake"
        },
        "type": "MappingDataFlow",
        "typeProperties": {
          "sources": [
            {
              "linkedService": {
                "referenceName": "[parameters('Snowflake_Source_New')]",
                "type": "LinkedServiceReference"
              },
              "name": "SourceData",
              "description": "Using an inline data set, specify the source as DF_SOURCE_SCHEMA.DF_SOURCE_TABLE"
            }
          ],
          "sinks": [
            {
              "linkedService": {
                "referenceName": "[parameters('Snowflake_Sink_New')]",
                "type": "LinkedServiceReference"
              },
              "name": "SinkData",
              "description": "Using an inline data set, specify the sink as DF_SINK_SCHEMA.DF_SINK_TABLE"
            }
          ],
          "transformations": [],
          "scriptLines": [
            "parameters{",
            "     runId as string (''),",
            "     DF_SOURCE_SCHEMA as string (''),",
            "     DF_SOURCE_TABLE as string (''),",
            "     DF_SINK_SCHEMA as string (''),",
            "     DF_SINK_TABLE as string ('')",
            "}",
            "source(allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'table',",
            "     tableName: ($DF_SOURCE_TABLE),",
            "     schemaName: ($DF_SOURCE_SCHEMA),",
            "     store: 'snowflake',",
            "     store: 'snowflakeV2',",
            "     partitionBy('roundRobin', 32)) ~> SourceData",
            "SourceData sink(allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'table',",
            "     tableName: ($DF_SINK_TABLE),",
            "     schemaName: ($DF_SINK_SCHEMA),",
            "     deletable: false,",
            "     insertable: true,",
            "     updateable: false,",
            "     upsertable: false,",
            "     store: 'snowflake',",
            "     store: 'snowflakeV2',",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true,",
            "     stageInsert: true) ~> SinkData"
          ]
        }
      },
      "dependsOn": []
    }
  ]
}
