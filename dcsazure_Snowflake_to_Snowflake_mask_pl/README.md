# dcsazure_Snowflake_to_Snowflake_mask_pl
## Delphix Compliance Services (DCS) for Azure - Snowflake to Snowflake Masking Pipeline

This pipeline will perform masking of your Snowflake Instance.

### Prerequisites
1. Configure the hosted metadata database and associated Azure SQL service (version `V2024.01.01.0`+)
1. Configure the DCS for Azure REST service.
1. Configure the Snowflake linked service.
1. Configure the Blob Storage linked service to the container named `staging-container`.

### Importing
There are several linked services that will need to be selected in order to perform the masking of your Snowflake
instance.

These linked services types are needed for the following steps:

`Azure Blob Storage` (staging) - Linked service associated with a blob storage container that can be used to stage data
when performing a data copy from Snowflake. This will be used for the following steps:
* If Copy Via Dataflow (If Condition activity)

`Snowflake` (source) - Linked service associated with unmasked Snowflake data needs to be parameterized for database name, role name and warehouse name. This will be used for the following
steps:
* dcsazure_Snowflake_to_Snowflake_mask_df/SnowflakeSource (dataFlow)
* dcsazure_Snowflake_to_Snowflake_mask_df/SnowflakeSink (dataFlow)
* dcsazure_Snowflake_to_Snowflake_source_ds (Snowflake dataset)
* dcsazure_Snowflake_to_Snowflake_copy_df/SnowflakeSource (dataFlow)
* dcsazure_Snowflake_to_Snowflake_copy_df/SnowflakeSink (dataFlow)

`Azure SQL` (metadata) - Linked service associated with your hosted metadata store. This will be used for the following
steps:
* dcsazure_Snowflake_to_Snowflake_metadata_mask_ds (Azure SQL Database dataset)
* dcsazure_Snowflake_to_Snowflake_mask_params_df/Ruleset (dataFlow)
* dcsazure_Snowflake_to_Snowflake_mask_params_df/TypeMapping (dataFlow)

`REST` (DCS for Azure) - Linked service associated with calling DCS for Azure. This will be used for the following
steps:
* dcsazure_Snowflake_to_Snowflake_mask_df (dataFlow)

### How It Works
* Reset Masking Condition
  * Checks against the `P_RESET_MASKING` parameter to determine if we should mask from scratch or mask from where it left off after last execution
* Select Tables Without Required Masking. This is done by querying the metadata data store.
  * Filter If Copy Unmasked Enabled. This is done by applying a filter based on the value of `P_COPY_UNMASKED_TABLES`
    * For Each Table With No Masking. Provided we have any rows left after applying the filter
      * If Copy Via Dataflow - based on the value of `P_COPY_USE_DATAFLOW`
        * If the data flow is to be used for copy, then call `dcsazure_Snowflake_to_Snowflake_copy_df`
        * If the data flow is not to be used for copy, then use a copy activity
* Select Tables That Require Masking
  * For Each Table To Mask
    * Call the `dcsazure_Snowflake_to_Snowflake_mask_params_df` data flow to generate masking parameters
    *  Call the `dcsazure_Snowflake_to_Snowflake_mask_df` data flow, passing in parameters as generated by
       the generate masking parameters dataflow

### Variables

If you have configured your database using the metadata store scripts, these variables will not need editing. If you
have customized your metadata store, then these variables may need editing.

* `METADATA_SCHEMA` - This is the schema to be used for in the self-hosted AzureSQL database for storing metadata
  (default `dbo`)
* `METADATA_RULESET_TABLE` - This is the table to be used for storing the discovered ruleset
  (default `discovered_ruleset`)
* `METADATA_SOURCE_TO_SINK_MAPPING_TABLE` - This is the table in the metadata schema that will contain the data
  mapping, defining where unmasked data lives, and where masked data should go (default `adf_data_mapping`)
* `METADATA_ADF_TYPE_MAPPING_TABLE` - This is the table that maps from data types in various datasets to the
  associated datatype required in ADF as needed for the pipeline (default `adf_type_mapping`)
* `STAGING_STORAGE_PATH` - This is a path that specifies where we should stage data as it moves through the pipeline
  and should reference a storage container in a storage account (default `staging-container`)
* `CAPTURE_LOG_PROCEDURE_NAME` - This is the procedure to be used for capturing the logs and marked the profiling and masking flags
  (default `capture_adf_execution_sp`)

### Parameters

* `P_COPY_UNMASKED_TABLES` - Bool - This is a flag to indicate whether we should copy over data that does not have any
  assigned algorithms (default `false`)
* `P_COPY_USE_DATAFLOW` - Bool - This is a flag to indicate whether we should use a copy activity or a copy data flow
  and is only relevant when using `P_COPY_UNMASKED_TABLES` (default `false`)
* `P_FAIL_ON_NONCONFORMING_DATA` - Bool - This enables the pipeline to handle non-conformant data errors without failing
  the pipeline - if set to `true`, unmasked data that did not conform to the format required to apply the specified
  algorithm will appear in the output data; if set to `false`, data that did not conform to the format required to apply
  the specified algorithm will cause the pipeline to fail (default `true`)
* `P_SOURCE_DATABASE` - String - This is the database in Snowflake that contains data we will mask
* `P_SINK_DATABASE` - String - This is the database in Snowflake that contains the location where we should put masked
  data
* `P_SOURCE_SCHEMA` - String - This is the schema within the above source database that we will mask
* `P_SINK_SCHEMA` - String - This is the schema within the above sink database where we will place masked data
* `P_SOURCE_ROLE` - String - This is the role in Snowflake that will be used to access  source Snowflake. This role needs permissions to query source schema.
* `P_SOURCE_WAREHOUSE` - String - This is the warehouse in source Snowflake that will be used to execute the queries
* `P_SINK_ROLE` - String - This is the role in Snowflake that will be used to access sink Snowflake. This role needs permissions to query source schema.
* `P_SINK_WAREHOUSE` - String - This is the warehouse in sink Snowflake that will be used to execute the queries
* `P_RESET_MASKING` - Boolean - This is the flag to control whether to re-mask from start, or from where it left off after last execution. Default value is true, which will re-mask from start.

