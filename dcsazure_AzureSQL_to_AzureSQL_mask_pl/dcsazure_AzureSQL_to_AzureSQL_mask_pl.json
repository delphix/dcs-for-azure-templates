{
  "$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
  "contentVersion": "1.0.0.0",
  "parameters": {
    "factoryName": { "type": "string", "metadata": "Data Factory name" },
    "azuresql_mask_metadata_store_db": { "type": "string" },
    "azuresql_mask_sink_db": { "type": "string" },
    "azuresql_mask_source_db": { "type": "string" },
    "ProdDCSForAzureService": { "type": "string" }
  },
  "variables": {
    "factoryId": "[concat('Microsoft.DataFactory/factories/', parameters('factoryName'))]"
  },
  "resources": [
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_AzureSQL_to_AzureSQL_mask_pl')]",
      "type": "Microsoft.DataFactory/factories/pipelines",
      "apiVersion": "2018-06-01",
      "properties": {
        "activities": [
          {
            "name": "Select Tables That Require Masking",
            "description": "Select tables with a data mapping and assigned algorithms, as well as filters that may be needed for conditional masking.",
            "type": "Lookup",
            "dependsOn": [
              {
                "activity": "For Each Table To Truncate",
                "dependencyConditions": ["Succeeded"]
              }
            ],
            "policy": {
              "timeout": "0.12:00:00",
              "retry": 0,
              "retryIntervalInSeconds": 30,
              "secureOutput": false,
              "secureInput": false
            },
            "userProperties": [],
            "typeProperties": {
              "source": {
                "type": "AzureSqlSource",
                "sqlReaderQuery": {
                  "value": "WITH\ntables_requiring_filters AS\n(\n\tSELECT DISTINCT\n\t\tdataset, specified_database, specified_schema, identified_table\n\tFROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_RULESET_TABLE')}\n\tWHERE ISJSON(assigned_algorithm) = 1\n\tAND dataset = '@{variables('DATASET')}'\n\tAND specified_database = '@{pipeline().parameters.P_SOURCE_DATABASE}'\n\tAND specified_schema = '@{pipeline().parameters.P_SOURCE_SCHEMA}'\n),\ntables_not_requiring_filters AS\n(\n\tSELECT DISTINCT\n\t\tdataset, specified_database, specified_schema, identified_table\n\tFROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_RULESET_TABLE')}\n\tWHERE assigned_algorithm IS NOT NULL\n\tAND assigned_algorithm != ''\n\tAND dataset = '@{variables('DATASET')}'\n\tAND specified_database = '@{pipeline().parameters.P_SOURCE_DATABASE}'\n\tAND specified_schema = '@{pipeline().parameters.P_SOURCE_SCHEMA}'\n\tEXCEPT\n\tSELECT dataset, specified_database, specified_schema, identified_table\n\tFROM tables_requiring_filters\n\tWHERE dataset = '@{variables('DATASET')}'\n\tAND specified_database = '@{pipeline().parameters.P_SOURCE_DATABASE}'\n\tAND specified_schema = '@{pipeline().parameters.P_SOURCE_SCHEMA}'\n),\nall_filters AS\n(\n\tSELECT DISTINCT\n\t\tJSON_VALUE(kc.value, '$.alias') as filter_alias,\n\t\treplace(JSON_VALUE(kc.value, '$.condition'), '@{variables('CONDITIONAL_MASKING_RESERVED_CHARACTER')}', concat('byName(''', d.identified_column, ''') ')) as filter_value,\n\t\td.identified_table\n\tFROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_RULESET_TABLE')} d \n\t\tCROSS APPLY OPENJSON(d.assigned_algorithm) kc\n\tWHERE\n\t\tISJSON(assigned_algorithm,ARRAY) = 1\n\t\tAND\n\t\td.identified_table in (\n\t\t\tSELECT identified_table FROM tables_requiring_filters\n\t\t)\n\t\tAND JSON_VALUE(kc.value,'$.alias') != 'default'\n),\ndefault_filters AS\n(\n\tSELECT DISTINCT\n\t\t'default' as filter_alias,\n\t\tSTRING_AGG(concat('not(', replace(JSON_VALUE(kc.value, '$.condition'), '@{variables('CONDITIONAL_MASKING_RESERVED_CHARACTER')}', concat('byName(''', d.identified_column, ''')')),')'), ' && ') as filter_value,\n\t\td.identified_table\n\tFROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_RULESET_TABLE')} d \n\t\tCROSS APPLY OPENJSON(d.assigned_algorithm) kc\n\tWHERE\n\t\tISJSON(assigned_algorithm,ARRAY) = 1\n\t\tAND\n\t\td.identified_table in (\n\t\t\tSELECT identified_table FROM tables_requiring_filters\n\t\t)\n\t\tAND JSON_VALUE(kc.value,'$.alias') != 'default'\n\tGROUP BY d.identified_table\n),\nsources_and_filters AS (\n\tSELECT\n\t\tt.dataset,\n\t\tt.specified_database,\n\t\tt.specified_schema,\n\t\tt.identified_table,\n\t\tf.filter_alias,\n\t\tf.filter_value\n\tFROM tables_requiring_filters t JOIN default_filters f\n\tON t.identified_table = f.identified_table\n\tUNION\n\tSELECT\n\t\tt.dataset,\n\t\tt.specified_database,\n\t\tt.specified_schema,\n\t\tt.identified_table,\n\t\tf.filter_alias,\n\t\tf.filter_value\n\tFROM tables_requiring_filters t JOIN all_filters f\n\tON t.identified_table = f.identified_table\n\tUNION\n\tSELECT\n\t\tdataset,\n\t\tspecified_database,\n\t\tspecified_schema,\n\t\tidentified_table,\n\t\t'',\n\t\t''\n\tFROM tables_not_requiring_filters\n)\nSELECT DISTINCT\n\tdm.source_dataset,\n\tdm.source_database,\n\tdm.source_schema,\n\tdm.source_table,\n\tdm.sink_dataset,\n\tdm.sink_database,\n\tdm.sink_schema,\n\tdm.sink_table,\n\trs.filter_alias,\n\trs.filter_value\nFROM\n\tsources_and_filters rs\n\tJOIN @{variables('METADATA_SCHEMA')}.@{variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')} dm\n\tON (\n\t\trs.dataset = dm.source_dataset AND\n\t\trs.specified_database = dm.source_database AND\n\t\trs.specified_schema = dm.source_schema AND\n\t\trs.identified_table = dm.source_table\n\t)\nWHERE\n\tdm.sink_database = '@{pipeline().parameters.P_SINK_DATABASE}' AND\n\tdm.sink_schema = '@{pipeline().parameters.P_SINK_SCHEMA}'\n\tAND (dm.mapping_complete IS NULL OR dm.mapping_complete = 0)\n\tAND (ISJSON(dm.masked_status) = 0  OR dm.masked_status IS NULL)\nUNION\nSELECT DISTINCT\n\tdm.source_dataset,\n\tdm.source_database,\n\tdm.source_schema,\n\tdm.source_table,\n\tdm.sink_dataset,\n\tdm.sink_database,\n\tdm.sink_schema,\n\tdm.sink_table,\n\trs.filter_alias,\n\trs.filter_value\nFROM\n\tsources_and_filters rs\n\tJOIN @{variables('METADATA_SCHEMA')}.@{variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')} dm\n\tCROSS APPLY OPENJSON(dm.masked_status) kc\n\tON (\n\t\trs.dataset = dm.source_dataset AND\n\t\trs.specified_database = dm.source_database AND\n\t\trs.specified_schema = dm.source_schema AND\n\t\trs.identified_table = dm.source_table\n\t)\nWHERE\n\tdm.sink_database = '@{pipeline().parameters.P_SINK_DATABASE}' AND\n\tdm.sink_schema = '@{pipeline().parameters.P_SINK_SCHEMA}'\n\tAND (dm.mapping_complete IS NULL OR dm.mapping_complete = 0)\n\tAND ISJSON(dm.masked_status) = 1\n\tAND kc.[key] = rs.filter_alias\n\tAND kc.[value] = 'false'\n\tAND (\n\t\t(filter_alias = 'default' AND  \n\t\t\tidentified_table IN (\n\t\t\t\tSELECT DISTINCT\n\t\t\t\t\tidentified_table\n\t\t\tFROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_RULESET_TABLE')} d\n\t\t\t\tCROSS APPLY OPENJSON(d.assigned_algorithm) kc\n\t\t\tWHERE\n\t\t\t\tISJSON(assigned_algorithm,ARRAY) = 1\n\t\t\t\tAND JSON_VALUE(kc.value, '$.alias') = 'default'\n\t\t\t)\n\t\t)\n\t\tOR\n\t\t(filter_alias != 'default')\n\t)\n",
                  "type": "Expression"
                },
                "queryTimeout": "02:00:00",
                "partitionOption": "None"
              },
              "dataset": {
                "referenceName": "dcsazure_AzureSQL_to_AzureSQL_mask_metadata_ds",
                "type": "DatasetReference",
                "parameters": {
                  "DS_METADATA_SCHEMA": {
                    "value": "@variables('METADATA_SCHEMA')",
                    "type": "Expression"
                  },
                  "DS_METADATA_TABLE": {
                    "value": "@variables('METADATA_RULESET_TABLE')",
                    "type": "Expression"
                  }
                }
              },
              "firstRowOnly": false
            }
          },
          {
            "name": "For Each Table To Mask",
            "type": "ForEach",
            "dependsOn": [
              {
                "activity": "Configure Masked Status",
                "dependencyConditions": ["Succeeded"]
              }
            ],
            "userProperties": [],
            "typeProperties": {
              "items": {
                "value": "@activity('Select Tables That Require Masking').output.value",
                "type": "Expression"
              },
              "isSequential": false,
              "activities": [
                {
                  "name": "Check For Conditional Masking",
                  "description": "Identify whether the table needs to be masked with conditional masking",
                  "type": "IfCondition",
                  "dependsOn": [],
                  "userProperties": [],
                  "typeProperties": {
                    "expression": {
                      "value": "@greater(length(item().filter_alias),0)",
                      "type": "Expression"
                    },
                    "ifFalseActivities": [
                      {
                        "name": "Get Masking Parameters No Filter",
                        "description": "Get parameters needed for masking this table that has no conditional masking",
                        "type": "ExecuteDataFlow",
                        "dependsOn": [],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "dataflow": {
                            "referenceName": "dcsazure_AzureSQL_to_AzureSQL_unfiltered_mask_params_df",
                            "type": "DataFlowReference",
                            "parameters": {
                              "runId": {
                                "value": "'@{pipeline().RunId}'",
                                "type": "Expression"
                              },
                              "DF_METADATA_SCHEMA": {
                                "value": "'@{variables('METADATA_SCHEMA')}'",
                                "type": "Expression"
                              },
                              "DF_METADATA_RULESET_TABLE": {
                                "value": "'@{variables('METADATA_RULESET_TABLE')}'",
                                "type": "Expression"
                              },
                              "DF_METADATA_ADF_TYPE_MAPPING_TABLE": {
                                "value": "'@{variables('METADATA_ADF_TYPE_MAPPING_TABLE')}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_DB": {
                                "value": "'@{item().source_database}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_SCHEMA": {
                                "value": "'@{item().source_schema}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_TABLE": {
                                "value": "'@{item().source_table}'",
                                "type": "Expression"
                              },
                              "DF_COLUMN_WIDTH_ESTIMATE": "1000",
                              "DF_DATASET": "'AZURESQL'"
                            },
                            "datasetParameters": {
                              "Ruleset": {},
                              "TypeMapping": {},
                              "MaskingParameterOutput": {}
                            }
                          },
                          "staging": {},
                          "compute": {
                            "coreCount": 8,
                            "computeType": "General"
                          },
                          "traceLevel": "None",
                          "cacheSinks": { "firstRowOnly": true }
                        }
                      },
                      {
                        "name": "Perform Masking Per Table No Filter",
                        "description": "Perform masking for the entire table",
                        "type": "ExecuteDataFlow",
                        "dependsOn": [
                          {
                            "activity": "Get Masking Parameters No Filter",
                            "dependencyConditions": ["Succeeded"]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "dataflow": {
                            "referenceName": "dcsazure_AzureSQL_to_AzureSQL_unfiltered_mask_df",
                            "type": "DataFlowReference",
                            "parameters": {
                              "runId": {
                                "value": "'@{pipeline().RunId}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_SCHEMA": {
                                "value": "'@{item().source_schema}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_TABLE": {
                                "value": "'@{item().source_table}'",
                                "type": "Expression"
                              },
                              "DF_SINK_SCHEMA": {
                                "value": "'@{item().sink_schema}'",
                                "type": "Expression"
                              },
                              "DF_SINK_TABLE": {
                                "value": "'@{item().sink_table}'",
                                "type": "Expression"
                              },
                              "DF_FIELD_ALGORITHM_ASSIGNMENT": {
                                "value": "'@{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].FieldAlgorithmAssignments}'",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_MASK": {
                                "value": "@activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToMask",
                                "type": "Expression"
                              },
                              "DF_BODY_TYPE_MAPPING": {
                                "value": "@activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].DataFactoryTypeMapping",
                                "type": "Expression"
                              },
                              "DF_NUMBER_OF_ROWS_PER_BATCH": {
                                "value": "@variables('TARGET_BATCH_SIZE')",
                                "type": "Expression"
                              },
                              "DF_TRIM_LENGTHS": {
                                "value": "@activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].TrimLengths",
                                "type": "Expression"
                              },
                              "DF_FAIL_ON_NONCONFORMANT_DATA": {
                                "value": "@pipeline().parameters.P_FAIL_ON_NONCONFORMANT_DATA",
                                "type": "Expression"
                              },
                              "DF_FIELD_DATE_FORMAT": {
                                "value": "'@{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].DateFormatAssignments}'",
                                "type": "Expression"
                              }
                            },
                            "datasetParameters": { "Source": {}, "Sink": {} }
                          },
                          "staging": {},
                          "compute": {
                            "coreCount": 8,
                            "computeType": "General"
                          },
                          "traceLevel": "None",
                          "cacheSinks": { "firstRowOnly": true }
                        }
                      },
                      {
                        "name": "Update Masked State No Filter",
                        "type": "SqlServerStoredProcedure",
                        "dependsOn": [
                          {
                            "activity": "Perform Masking Per Table No Filter",
                            "dependencyConditions": ["Succeeded"]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "storedProcedureName": {
                            "value": "@variables('METADATA_EVENT_PROCEDURE_NAME')",
                            "type": "Expression"
                          },
                          "storedProcedureParameters": {
                            "activity_run_id": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table No Filter').ActivityRunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "error_message": {
                              "value": null,
                              "type": "String"
                            },
                            "execution_end_time": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table No Filter').ExecutionEndTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "execution_start_time": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table No Filter').ExecutionStartTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "filter_alias": { "value": null, "type": "String" },
                            "filter_condition": {
                              "value": null,
                              "type": "String"
                            },
                            "input_parameters": {
                              "value": {
                                "value": "{\n    \"DF_FIELD_ALGORITHM_ASSIGNMENT\": @{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].FieldAlgorithmAssignments},\n    \"DF_COLUMNS_TO_MASK\": @{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToMask},\n    \"DF_BODY_TYPE_MAPPING\": @{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].DataFactoryTypeMapping},\n    \"DF_FAIL_ON_NONCONFORMANT_DATA\": @{pipeline().parameters.P_FAIL_ON_NONCONFORMANT_DATA},\n    \"DF_TRIM_LENGTHS\": @{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].TrimLengths},\n    \"DF_FIELD_DATE_FORMAT\": @{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].DateFormatAssignments}\n}",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "is_masking_activity": {
                              "value": "true",
                              "type": "Boolean"
                            },
                            "pipeline_name": {
                              "value": {
                                "value": "@pipeline().Pipeline",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "pipeline_run_id": {
                              "value": {
                                "value": "@pipeline().RunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "pipeline_success": {
                              "value": "true",
                              "type": "Boolean"
                            },
                            "sink_database": {
                              "value": {
                                "value": "@pipeline().parameters.P_SINK_DATABASE",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "sink_schema": {
                              "value": {
                                "value": "@pipeline().parameters.P_SINK_SCHEMA",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_table": {
                              "value": {
                                "value": "@item().sink_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_database": {
                              "value": {
                                "value": "@pipeline().parameters.P_SOURCE_DATABASE",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "source_schema": {
                              "value": {
                                "value": "@pipeline().parameters.P_SOURCE_SCHEMA",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_table": {
                              "value": {
                                "value": "@item().source_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            }
                          }
                        },
                        "linkedServiceName": {
                          "referenceName": "[parameters('azuresql_mask_metadata_store_db')]",
                          "type": "LinkedServiceReference"
                        }
                      },
                      {
                        "name": "Update Masked State No Filter Failed",
                        "type": "SqlServerStoredProcedure",
                        "dependsOn": [
                          {
                            "activity": "Perform Masking Per Table No Filter",
                            "dependencyConditions": ["Failed"]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "storedProcedureName": {
                            "value": "@variables('METADATA_EVENT_PROCEDURE_NAME')",
                            "type": "Expression"
                          },
                          "storedProcedureParameters": {
                            "activity_run_id": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table No Filter').ActivityRunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "error_message": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table No Filter').Error.message",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "execution_end_time": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table No Filter').ExecutionEndTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "execution_start_time": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table No Filter').ExecutionStartTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "filter_alias": { "value": null, "type": "String" },
                            "filter_condition": {
                              "value": null,
                              "type": "String"
                            },
                            "input_parameters": {
                              "value": {
                                "value": "{\n    \"DF_FIELD_ALGORITHM_ASSIGNMENT\": @{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].FieldAlgorithmAssignments},\n    \"DF_COLUMNS_TO_MASK\": @{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToMask},\n    \"DF_BODY_TYPE_MAPPING\": @{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].DataFactoryTypeMapping},\n    \"DF_FAIL_ON_NONCONFORMANT_DATA\": @{pipeline().parameters.P_FAIL_ON_NONCONFORMANT_DATA},\n    \"DF_TRIM_LENGTHS\": @{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].TrimLengths},\n    \"DF_FIELD_DATE_FORMAT\": @{activity('Get Masking Parameters No Filter').output.runStatus.output.MaskingParameterOutput.value[0].DateFormatAssignments}\n}",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "is_masking_activity": {
                              "value": "true",
                              "type": "Boolean"
                            },
                            "pipeline_name": {
                              "value": {
                                "value": "@pipeline().Pipeline",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "pipeline_run_id": {
                              "value": {
                                "value": "@pipeline().RunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "pipeline_success": {
                              "value": "false",
                              "type": "Boolean"
                            },
                            "sink_database": {
                              "value": {
                                "value": "@pipeline().parameters.P_SINK_DATABASE",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "sink_schema": {
                              "value": {
                                "value": "@pipeline().parameters.P_SINK_SCHEMA",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_table": {
                              "value": {
                                "value": "@item().sink_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_database": {
                              "value": {
                                "value": "@pipeline().parameters.P_SOURCE_DATABASE",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "source_schema": {
                              "value": {
                                "value": "@pipeline().parameters.P_SOURCE_SCHEMA",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_table": {
                              "value": {
                                "value": "@item().source_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            }
                          }
                        },
                        "linkedServiceName": {
                          "referenceName": "[parameters('azuresql_mask_metadata_store_db')]",
                          "type": "LinkedServiceReference"
                        }
                      },
                      {
                        "name": "Fail After Updating Masked State No Filter",
                        "type": "Fail",
                        "dependsOn": [
                          {
                            "activity": "Update Masked State No Filter Failed",
                            "dependencyConditions": ["Succeeded"]
                          }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                          "message": {
                            "value": "Failed to mask @{item().source_table}",
                            "type": "Expression"
                          },
                          "errorCode": "500"
                        }
                      }
                    ],
                    "ifTrueActivities": [
                      {
                        "name": "Get Masking Parameters With Filter",
                        "description": "Get parameters needed for masking this table with the conditional masking filter",
                        "type": "ExecuteDataFlow",
                        "dependsOn": [],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "dataflow": {
                            "referenceName": "dcsazure_AzureSQL_to_AzureSQL_filtered_params_df",
                            "type": "DataFlowReference",
                            "parameters": {
                              "runId": {
                                "value": "'@{pipeline().RunId}'",
                                "type": "Expression"
                              },
                              "DF_METADATA_SCHEMA": {
                                "value": "'@{variables('METADATA_SCHEMA')}'",
                                "type": "Expression"
                              },
                              "DF_METADATA_RULESET_TABLE": {
                                "value": "'@{variables('METADATA_RULESET_TABLE')}'",
                                "type": "Expression"
                              },
                              "DF_METADATA_ADF_TYPE_MAPPING_TABLE": {
                                "value": "'@{variables('METADATA_ADF_TYPE_MAPPING_TABLE')}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_DATABASE": {
                                "value": "'@{item().source_database}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_SCHEMA": {
                                "value": "'@{item().source_schema}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_TABLE": {
                                "value": "'@{item().source_table}'",
                                "type": "Expression"
                              },
                              "DF_COLUMN_WIDTH_ESTIMATE": "1000",
                              "DF_FILTER_KEY": {
                                "value": "'@{item().filter_alias}'",
                                "type": "Expression"
                              },
                              "DF_DATASET": {
                                "value": "'@{item().source_dataset}'",
                                "type": "Expression"
                              }
                            },
                            "datasetParameters": {
                              "Ruleset": {},
                              "TypeMapping": {},
                              "MaskingParameterOutput": {}
                            }
                          },
                          "staging": {},
                          "compute": {
                            "coreCount": 8,
                            "computeType": "General"
                          },
                          "traceLevel": "None",
                          "cacheSinks": { "firstRowOnly": true }
                        }
                      },
                      {
                        "name": "Perform Masking Per Table With Filter",
                        "description": "Perform masking for the part of this table that satisfies the specified filter",
                        "type": "ExecuteDataFlow",
                        "dependsOn": [
                          {
                            "activity": "Get Masking Parameters With Filter",
                            "dependencyConditions": ["Succeeded"]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "dataflow": {
                            "referenceName": "dcsazure_AzureSQL_to_AzureSQL_filtered_mask_df",
                            "type": "DataFlowReference",
                            "parameters": {
                              "runId": {
                                "value": "'@{pipeline().RunId}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_SCHEMA": {
                                "value": "'@{item().source_schema}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_TABLE": {
                                "value": "'@{item().source_table}'",
                                "type": "Expression"
                              },
                              "DF_SINK_SCHEMA": {
                                "value": "'@{item().sink_schema}'",
                                "type": "Expression"
                              },
                              "DF_SINK_TABLE": {
                                "value": "'@{item().sink_table}'",
                                "type": "Expression"
                              },
                              "DF_FIELD_ALGORITHM_ASSIGNMENT": {
                                "value": "'@{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].FieldAlgorithmAssignments}'",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_MASK": {
                                "value": "@activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToMask",
                                "type": "Expression"
                              },
                              "DF_BODY_TYPE_MAPPING": {
                                "value": "@activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].DataFactoryTypeMapping",
                                "type": "Expression"
                              },
                              "DF_NUMBER_OF_ROWS_PER_BATCH": {
                                "value": "@variables('TARGET_BATCH_SIZE')",
                                "type": "Expression"
                              },
                              "DF_TRIM_LENGTHS": {
                                "value": "@activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].TrimLengths",
                                "type": "Expression"
                              },
                              "DF_FAIL_ON_NONCONFORMANT_DATA": {
                                "value": "@pipeline().parameters.P_FAIL_ON_NONCONFORMANT_DATA",
                                "type": "Expression"
                              },
                              "DF_FIELD_DATE_FORMAT": {
                                "value": "'@{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].DateFormatAssignments}'",
                                "type": "Expression"
                              },
                              "DF_FILTER_CONDITION": {
                                "value": "@item().filter_value",
                                "type": "Expression"
                              }
                            },
                            "datasetParameters": { "Source": {}, "Sink": {} }
                          },
                          "staging": {},
                          "compute": {
                            "coreCount": 8,
                            "computeType": "General"
                          },
                          "traceLevel": "Fine"
                        }
                      },
                      {
                        "name": "Update Masked State With Filter",
                        "type": "SqlServerStoredProcedure",
                        "dependsOn": [
                          {
                            "activity": "Perform Masking Per Table With Filter",
                            "dependencyConditions": ["Succeeded"]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "storedProcedureName": {
                            "value": "@variables('METADATA_EVENT_PROCEDURE_NAME')",
                            "type": "Expression"
                          },
                          "storedProcedureParameters": {
                            "activity_run_id": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table With Filter').ActivityRunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "error_message": {
                              "value": null,
                              "type": "String"
                            },
                            "execution_end_time": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table With Filter').ExecutionEndTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "execution_start_time": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table With Filter').ExecutionStartTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "filter_alias": {
                              "value": {
                                "value": "@item().filter_alias",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "filter_condition": {
                              "value": {
                                "value": "@item().filter_value",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "input_parameters": {
                              "value": {
                                "value": "{\n    \"DF_FIELD_ALGORITHM_ASSIGNMENT\": @{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].FieldAlgorithmAssignments},\n    \"DF_COLUMNS_TO_MASK\": @{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToMask},\n    \"DF_BODY_TYPE_MAPPING\": @{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].DataFactoryTypeMapping},\n    \"DF_FAIL_ON_NONCONFORMANT_DATA\": @{pipeline().parameters.P_FAIL_ON_NONCONFORMANT_DATA},\n    \"DF_TRIM_LENGTHS\": @{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].TrimLengths},\n    \"DF_FIELD_DATE_FORMAT\": @{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].DateFormatAssignments}\n}",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "is_masking_activity": {
                              "value": "true",
                              "type": "Boolean"
                            },
                            "pipeline_name": {
                              "value": {
                                "value": "@pipeline().Pipeline",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "pipeline_run_id": {
                              "value": {
                                "value": "@pipeline().RunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "pipeline_success": {
                              "value": "true",
                              "type": "Boolean"
                            },
                            "sink_database": {
                              "value": {
                                "value": "@pipeline().parameters.P_SINK_DATABASE",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "sink_schema": {
                              "value": {
                                "value": "@pipeline().parameters.P_SINK_SCHEMA",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_table": {
                              "value": {
                                "value": "@item().sink_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_database": {
                              "value": {
                                "value": "@pipeline().parameters.P_SOURCE_DATABASE",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "source_schema": {
                              "value": {
                                "value": "@pipeline().parameters.P_SOURCE_SCHEMA",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_table": {
                              "value": {
                                "value": "@item().source_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            }
                          }
                        },
                        "linkedServiceName": {
                          "referenceName": "[parameters('azuresql_mask_metadata_store_db')]",
                          "type": "LinkedServiceReference"
                        }
                      },
                      {
                        "name": "Update Masked State With Filter Failed",
                        "type": "SqlServerStoredProcedure",
                        "dependsOn": [
                          {
                            "activity": "Perform Masking Per Table With Filter",
                            "dependencyConditions": ["Failed"]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "storedProcedureName": {
                            "value": "@variables('METADATA_EVENT_PROCEDURE_NAME')",
                            "type": "Expression"
                          },
                          "storedProcedureParameters": {
                            "activity_run_id": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table With Filter').ActivityRunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "error_message": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table With Filter').Error.message",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "execution_end_time": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table With Filter').ExecutionEndTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "execution_start_time": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table With Filter').ExecutionStartTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "filter_alias": {
                              "value": {
                                "value": "@item().filter_alias",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "filter_condition": {
                              "value": {
                                "value": "@item().filter_value",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "input_parameters": {
                              "value": {
                                "value": "{\n    \"DF_FIELD_ALGORITHM_ASSIGNMENT\": @{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].FieldAlgorithmAssignments},\n    \"DF_COLUMNS_TO_MASK\": @{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].ColumnsToMask},\n    \"DF_BODY_TYPE_MAPPING\": @{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].DataFactoryTypeMapping},\n    \"DF_FAIL_ON_NONCONFORMANT_DATA\": @{pipeline().parameters.P_FAIL_ON_NONCONFORMANT_DATA},\n    \"DF_TRIM_LENGTHS\": @{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].TrimLengths},\n    \"DF_FIELD_DATE_FORMAT\": @{activity('Get Masking Parameters With Filter').output.runStatus.output.MaskingParameterOutput.value[0].DateFormatAssignments}\n}",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "is_masking_activity": {
                              "value": "true",
                              "type": "Boolean"
                            },
                            "pipeline_name": {
                              "value": {
                                "value": "@pipeline().Pipeline",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "pipeline_run_id": {
                              "value": {
                                "value": "@pipeline().RunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "pipeline_success": {
                              "value": "false",
                              "type": "Boolean"
                            },
                            "sink_database": {
                              "value": {
                                "value": "@pipeline().parameters.P_SINK_DATABASE",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "sink_schema": {
                              "value": {
                                "value": "@pipeline().parameters.P_SINK_SCHEMA",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_table": {
                              "value": {
                                "value": "@item().sink_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_database": {
                              "value": {
                                "value": "@pipeline().parameters.P_SOURCE_DATABASE",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "source_schema": {
                              "value": {
                                "value": "@pipeline().parameters.P_SOURCE_SCHEMA",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_table": {
                              "value": {
                                "value": "@item().source_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            }
                          }
                        },
                        "linkedServiceName": {
                          "referenceName": "[parameters('azuresql_mask_metadata_store_db')]",
                          "type": "LinkedServiceReference"
                        }
                      },
                      {
                        "name": "Fail After Updating Masked State With Filter",
                        "type": "Fail",
                        "dependsOn": [
                          {
                            "activity": "Update Masked State With Filter Failed",
                            "dependencyConditions": ["Succeeded"]
                          }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                          "message": {
                            "value": "Failed to mask @{item().source_table} with filter alias @{item().filter_alias}",
                            "type": "Expression"
                          },
                          "errorCode": "500"
                        }
                      }
                    ]
                  }
                }
              ]
            }
          },
          {
            "name": "Select Tables Without Required Masking",
            "description": "Select tables with a data mapping, and no assigned algorithms or rows.",
            "type": "Lookup",
            "dependsOn": [
              {
                "activity": "For Each Table To Truncate",
                "dependencyConditions": ["Succeeded"]
              }
            ],
            "policy": {
              "timeout": "0.12:00:00",
              "retry": 0,
              "retryIntervalInSeconds": 30,
              "secureOutput": false,
              "secureInput": false
            },
            "userProperties": [],
            "typeProperties": {
              "source": {
                "type": "AzureSqlSource",
                "sqlReaderQuery": {
                  "value": "SELECT DISTINCT\n\tsource_database,\n\tsource_schema,\n\tsource_table,\n\tsink_schema,\n\tsink_database,\n\tsink_table\nFROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')} dm\nWHERE\nUPPER(source_dataset) = UPPER('@{variables('DATASET')}')\nAND UPPER(sink_dataset) = UPPER('@{variables('DATASET')}')\nAND UPPER(source_database) = UPPER('@{pipeline().parameters.P_SOURCE_DATABASE}')\nAND UPPER(sink_database) = UPPER('@{pipeline().parameters.P_SINK_DATABASE}')\nAND UPPER(source_schema) = UPPER('@{pipeline().parameters.P_SOURCE_SCHEMA}')\nAND UPPER(sink_schema) = UPPER('@{pipeline().parameters.P_SINK_SCHEMA}')\nAND (dm.mapping_complete IS NULL OR dm.mapping_complete = 0)\nEXCEPT\nSELECT DISTINCT\n\tsource_schema,\n\tsource_database,\n\tsource_table,\n\tsink_schema,\n\tsink_database,\n\tsink_table\nFROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_RULESET_TABLE')} dd\nJOIN @{variables('METADATA_SCHEMA')}.@{variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')} dm\nON (\n\tUPPER(dm.source_database) = UPPER(dd.specified_database)\n\tAND UPPER(dm.source_schema) = UPPER(dd.specified_schema)\n\tAND UPPER(dm.source_table) = UPPER(dd.identified_table)\n)\nWHERE\n\tUPPER(dd.dataset) = UPPER('@{variables('DATASET')}')\n\tAND UPPER(dm.source_dataset) = UPPER('@{variables('DATASET')}')\n\tAND UPPER(dm.sink_dataset) = UPPER('@{variables('DATASET')}')\n\tAND dd.assigned_algorithm IS NOT NULL\n\tAND dd.assigned_algorithm != ''\n\tAND UPPER(dm.source_database) = UPPER('@{pipeline().parameters.P_SOURCE_DATABASE}')\n\tAND UPPER(dm.sink_database) = UPPER('@{pipeline().parameters.P_SINK_DATABASE}')\n\tAND UPPER(dm.source_schema) = UPPER('@{pipeline().parameters.P_SOURCE_SCHEMA}')\n\tAND UPPER(dm.sink_schema) = UPPER('@{pipeline().parameters.P_SINK_SCHEMA}');\n",
                  "type": "Expression"
                },
                "queryTimeout": "02:00:00",
                "partitionOption": "None"
              },
              "dataset": {
                "referenceName": "dcsazure_AzureSQL_to_AzureSQL_mask_metadata_ds",
                "type": "DatasetReference",
                "parameters": {
                  "DS_METADATA_SCHEMA": {
                    "value": "@variables('METADATA_SCHEMA')",
                    "type": "Expression"
                  },
                  "DS_METADATA_TABLE": {
                    "value": "@variables('METADATA_RULESET_TABLE')",
                    "type": "Expression"
                  }
                }
              },
              "firstRowOnly": false
            }
          },
          {
            "name": "Filter If Copy Unmasked Enabled",
            "type": "Filter",
            "dependsOn": [
              {
                "activity": "Select Tables Without Required Masking",
                "dependencyConditions": ["Succeeded"]
              }
            ],
            "userProperties": [],
            "typeProperties": {
              "items": {
                "value": "@activity('Select Tables Without Required Masking').output.value",
                "type": "Expression"
              },
              "condition": {
                "value": "@pipeline().parameters.P_COPY_UNMASKED_TABLES",
                "type": "Expression"
              }
            }
          },
          {
            "name": "For Each Table With No Masking",
            "description": "Copy unmasked data of each table using either Copy Dataflow or Copy Activity",
            "type": "ForEach",
            "dependsOn": [
              {
                "activity": "Filter If Copy Unmasked Enabled",
                "dependencyConditions": ["Succeeded"]
              }
            ],
            "userProperties": [],
            "typeProperties": {
              "items": {
                "value": "@activity('Filter If Copy Unmasked Enabled').output.value",
                "type": "Expression"
              },
              "activities": [
                {
                  "name": "If Use Copy Dataflow",
                  "type": "IfCondition",
                  "dependsOn": [],
                  "userProperties": [],
                  "typeProperties": {
                    "expression": {
                      "value": "@pipeline().parameters.P_USE_COPY_DATAFLOW",
                      "type": "Expression"
                    },
                    "ifFalseActivities": [
                      {
                        "name": "Copy Unmasked Data",
                        "description": "Calls the Copy Activity to copy unmasked data from source schema to sink schema for a given table if P_USE_COPY_DATAFLOW parameter is disabled",
                        "type": "Copy",
                        "dependsOn": [],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "source": {
                            "type": "AzureSqlSource",
                            "queryTimeout": "02:00:00",
                            "partitionOption": "None"
                          },
                          "sink": {
                            "type": "AzureSqlSink",
                            "writeBehavior": "insert",
                            "sqlWriterUseTableLock": false
                          },
                          "enableStaging": false,
                          "translator": {
                            "type": "TabularTranslator",
                            "typeConversion": true,
                            "typeConversionSettings": {
                              "allowDataTruncation": true,
                              "treatBooleanAsNumber": false
                            }
                          }
                        },
                        "inputs": [
                          {
                            "referenceName": "dcsazure_AzureSQL_to_AzureSQL_mask_source_ds",
                            "type": "DatasetReference",
                            "parameters": {
                              "DS_SOURCE_SCHEMA": {
                                "value": "@item().source_schema",
                                "type": "Expression"
                              },
                              "DS_SOURCE_TABLE": {
                                "value": "@item().source_table",
                                "type": "Expression"
                              }
                            }
                          }
                        ],
                        "outputs": [
                          {
                            "referenceName": "dcsazure_AzureSQL_to_AzureSQL_mask_sink_ds",
                            "type": "DatasetReference",
                            "parameters": {
                              "DS_SINK_SCHEMA": {
                                "value": "@item().sink_schema",
                                "type": "Expression"
                              },
                              "DS_SINK_TABLE": {
                                "value": "@item().sink_table",
                                "type": "Expression"
                              }
                            }
                          }
                        ]
                      },
                      {
                        "name": "Update Copy Unmasked Data State",
                        "type": "SqlServerStoredProcedure",
                        "dependsOn": [
                          {
                            "activity": "Copy Unmasked Data",
                            "dependencyConditions": ["Succeeded"]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "storedProcedureName": {
                            "value": "@variables('METADATA_EVENT_PROCEDURE_NAME')",
                            "type": "Expression"
                          },
                          "storedProcedureParameters": {
                            "activity_run_id": {
                              "value": {
                                "value": "@activity('Copy Unmasked Data').ActivityRunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "error_message": {
                              "value": null,
                              "type": "String"
                            },
                            "execution_end_time": {
                              "value": {
                                "value": "@activity('Copy Unmasked Data').ExecutionEndTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "execution_start_time": {
                              "value": {
                                "value": "@activity('Copy Unmasked Data').ExecutionStartTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "filter_alias": { "value": null, "type": "String" },
                            "filter_condition": {
                              "value": null,
                              "type": "String"
                            },
                            "input_parameters": {
                              "value": {
                                "value": "{\n\"P_USE_COPY_DATAFLOW\": @{pipeline().parameters.P_USE_COPY_DATAFLOW}\n}\n",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "is_masking_activity": {
                              "value": "false",
                              "type": "Boolean"
                            },
                            "pipeline_name": {
                              "value": {
                                "value": "@pipeline().Pipeline",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "pipeline_run_id": {
                              "value": {
                                "value": "@pipeline().RunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "pipeline_success": {
                              "value": "true",
                              "type": "Boolean"
                            },
                            "sink_database": {
                              "value": {
                                "value": "@pipeline().parameters.P_SINK_DATABASE",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "sink_schema": {
                              "value": {
                                "value": "@pipeline().parameters.P_SINK_SCHEMA",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_table": {
                              "value": {
                                "value": "@item().sink_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_database": {
                              "value": {
                                "value": "@pipeline().parameters.P_SOURCE_DATABASE",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "source_schema": {
                              "value": {
                                "value": "@pipeline().parameters.P_SOURCE_SCHEMA",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_table": {
                              "value": {
                                "value": "@item().source_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            }
                          }
                        },
                        "linkedServiceName": {
                          "referenceName": "[parameters('azuresql_mask_metadata_store_db')]",
                          "type": "LinkedServiceReference"
                        }
                      },
                      {
                        "name": "Update Copy Unmasked Data State Failed",
                        "type": "SqlServerStoredProcedure",
                        "dependsOn": [
                          {
                            "activity": "Copy Unmasked Data",
                            "dependencyConditions": ["Failed"]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "storedProcedureName": {
                            "value": "@variables('METADATA_EVENT_PROCEDURE_NAME')",
                            "type": "Expression"
                          },
                          "storedProcedureParameters": {
                            "activity_run_id": {
                              "value": {
                                "value": "@activity('Copy Unmasked Data').ActivityRunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "error_message": {
                              "value": {
                                "value": "@activity('Copy Unmasked Data').Error.message",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "execution_end_time": {
                              "value": {
                                "value": "@activity('Copy Unmasked Data').ExecutionEndTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "execution_start_time": {
                              "value": {
                                "value": "@activity('Copy Unmasked Data').ExecutionStartTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "filter_alias": { "value": null, "type": "String" },
                            "filter_condition": {
                              "value": null,
                              "type": "String"
                            },
                            "input_parameters": {
                              "value": {
                                "value": "{\n\"P_USE_COPY_DATAFLOW\": @{pipeline().parameters.P_USE_COPY_DATAFLOW}\n}\n",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "is_masking_activity": {
                              "value": "false",
                              "type": "Boolean"
                            },
                            "pipeline_name": {
                              "value": {
                                "value": "@pipeline().Pipeline",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "pipeline_run_id": {
                              "value": {
                                "value": "@pipeline().RunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "pipeline_success": {
                              "value": "false",
                              "type": "Boolean"
                            },
                            "sink_database": {
                              "value": {
                                "value": "@pipeline().parameters.P_SINK_DATABASE",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "sink_schema": {
                              "value": {
                                "value": "@pipeline().parameters.P_SINK_SCHEMA",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_table": {
                              "value": {
                                "value": "@item().sink_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_database": {
                              "value": {
                                "value": "@pipeline().parameters.P_SOURCE_DATABASE",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "source_schema": {
                              "value": {
                                "value": "@pipeline().parameters.P_SOURCE_SCHEMA",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_table": {
                              "value": {
                                "value": "@item().source_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            }
                          }
                        },
                        "linkedServiceName": {
                          "referenceName": "[parameters('azuresql_mask_metadata_store_db')]",
                          "type": "LinkedServiceReference"
                        }
                      },
                      {
                        "name": "Fail After Updating Copy Unmasked Data State",
                        "type": "Fail",
                        "dependsOn": [
                          {
                            "activity": "Update Copy Unmasked Data State Failed",
                            "dependencyConditions": ["Succeeded"]
                          }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                          "message": {
                            "value": "Failed to copy @{item().source_table}",
                            "type": "Expression"
                          },
                          "errorCode": "500"
                        }
                      }
                    ],
                    "ifTrueActivities": [
                      {
                        "name": "Call Copy Dataflow",
                        "description": "Calls the Copy Dataflow to copy unmasked data from source schema to sink schema for a given table if P_USE_COPY_DATAFLOW parameter is enabled",
                        "type": "ExecuteDataFlow",
                        "dependsOn": [],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "dataflow": {
                            "referenceName": "dcsazure_AzureSQL_to_AzureSQL_copy_df",
                            "type": "DataFlowReference",
                            "parameters": {
                              "runId": {
                                "value": "'@{pipeline().RunId}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_SCHEMA": {
                                "value": "'@{item().source_schema}'",
                                "type": "Expression"
                              },
                              "DF_SINK_SCHEMA": {
                                "value": "'@{item().sink_schema}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_TABLE": {
                                "value": "'@{item().source_table}'",
                                "type": "Expression"
                              },
                              "DF_SINK_TABLE": {
                                "value": "'@{item().sink_table}'",
                                "type": "Expression"
                              }
                            },
                            "datasetParameters": {
                              "SourceData": {},
                              "SinkData": {}
                            }
                          },
                          "staging": {},
                          "compute": {
                            "coreCount": 8,
                            "computeType": "General"
                          },
                          "traceLevel": "Fine"
                        }
                      },
                      {
                        "name": "Update Copy Dataflow State",
                        "type": "SqlServerStoredProcedure",
                        "dependsOn": [
                          {
                            "activity": "Call Copy Dataflow",
                            "dependencyConditions": ["Succeeded"]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "storedProcedureName": {
                            "value": "@variables('METADATA_EVENT_PROCEDURE_NAME')",
                            "type": "Expression"
                          },
                          "storedProcedureParameters": {
                            "activity_run_id": {
                              "value": {
                                "value": "@activity('Call Copy Dataflow').ActivityRunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "error_message": {
                              "value": null,
                              "type": "String"
                            },
                            "execution_end_time": {
                              "value": {
                                "value": "@activity('Call Copy Dataflow').ExecutionEndTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "execution_start_time": {
                              "value": {
                                "value": "@activity('Call Copy Dataflow').ExecutionStartTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "filter_alias": { "value": null, "type": "String" },
                            "filter_condition": {
                              "value": null,
                              "type": "String"
                            },
                            "input_parameters": {
                              "value": {
                                "value": "{\n\"P_USE_COPY_DATAFLOW\": @{pipeline().parameters.P_USE_COPY_DATAFLOW}\n}\n",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "is_masking_activity": {
                              "value": "false",
                              "type": "Boolean"
                            },
                            "pipeline_name": {
                              "value": {
                                "value": "@pipeline().Pipeline",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "pipeline_run_id": {
                              "value": {
                                "value": "@pipeline().RunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "pipeline_success": {
                              "value": "true",
                              "type": "Boolean"
                            },
                            "sink_database": {
                              "value": {
                                "value": "@pipeline().parameters.P_SINK_DATABASE",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "sink_schema": {
                              "value": {
                                "value": "@pipeline().parameters.P_SINK_SCHEMA",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_table": {
                              "value": {
                                "value": "@item().sink_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_database": {
                              "value": {
                                "value": "@pipeline().parameters.P_SOURCE_DATABASE",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "source_schema": {
                              "value": {
                                "value": "@pipeline().parameters.P_SOURCE_SCHEMA",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_table": {
                              "value": {
                                "value": "@item().source_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            }
                          }
                        },
                        "linkedServiceName": {
                          "referenceName": "[parameters('azuresql_mask_metadata_store_db')]",
                          "type": "LinkedServiceReference"
                        }
                      },
                      {
                        "name": "Update Copy Dataflow State Failed",
                        "type": "SqlServerStoredProcedure",
                        "dependsOn": [
                          {
                            "activity": "Call Copy Dataflow",
                            "dependencyConditions": ["Failed"]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "storedProcedureName": {
                            "value": "@variables('METADATA_EVENT_PROCEDURE_NAME')",
                            "type": "Expression"
                          },
                          "storedProcedureParameters": {
                            "activity_run_id": {
                              "value": {
                                "value": "@activity('Call Copy Dataflow').ActivityRunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "error_message": {
                              "value": {
                                "value": "@activity('Call Copy Dataflow').Error.message",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "execution_end_time": {
                              "value": {
                                "value": "@activity('Call Copy Dataflow').ExecutionEndTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "execution_start_time": {
                              "value": {
                                "value": "@activity('Call Copy Dataflow').ExecutionStartTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "filter_alias": { "value": null, "type": "String" },
                            "filter_condition": {
                              "value": null,
                              "type": "String"
                            },
                            "input_parameters": {
                              "value": {
                                "value": "{\n\"P_USE_COPY_DATAFLOW\": @{pipeline().parameters.P_USE_COPY_DATAFLOW}\n}\n",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "is_masking_activity": {
                              "value": "false",
                              "type": "Boolean"
                            },
                            "pipeline_name": {
                              "value": {
                                "value": "@pipeline().Pipeline",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "pipeline_run_id": {
                              "value": {
                                "value": "@pipeline().RunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "pipeline_success": {
                              "value": "false",
                              "type": "Boolean"
                            },
                            "sink_database": {
                              "value": {
                                "value": "@pipeline().parameters.P_SINK_DATABASE",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "sink_schema": {
                              "value": {
                                "value": "@pipeline().parameters.P_SINK_SCHEMA",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_table": {
                              "value": {
                                "value": "@item().sink_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_database": {
                              "value": {
                                "value": "@pipeline().parameters.P_SOURCE_DATABASE",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "source_schema": {
                              "value": {
                                "value": "@pipeline().parameters.P_SOURCE_SCHEMA",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_table": {
                              "value": {
                                "value": "@item().source_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            }
                          }
                        },
                        "linkedServiceName": {
                          "referenceName": "[parameters('azuresql_mask_metadata_store_db')]",
                          "type": "LinkedServiceReference"
                        }
                      },
                      {
                        "name": "Fail After Updating Copy Dataflow State",
                        "type": "Fail",
                        "dependsOn": [
                          {
                            "activity": "Update Copy Dataflow State Failed",
                            "dependencyConditions": ["Succeeded"]
                          }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                          "message": {
                            "value": "Failed to copy @{item().source_table}",
                            "type": "Expression"
                          },
                          "errorCode": "500"
                        }
                      }
                    ]
                  }
                }
              ]
            }
          },
          {
            "name": "Test Filter Conditions",
            "description": "Use data preview on Lookup \"Select Tables That Require Masking\" activity to confirm what filter conditions are to be applied. Leverage data preview on this data flow to confirm your filter is working as expected.",
            "type": "ExecuteDataFlow",
            "state": "Inactive",
            "onInactiveMarkAs": "Succeeded",
            "dependsOn": [],
            "policy": {
              "timeout": "0.12:00:00",
              "retry": 0,
              "retryIntervalInSeconds": 30,
              "secureOutput": false,
              "secureInput": false
            },
            "userProperties": [],
            "typeProperties": {
              "dataflow": {
                "referenceName": "dcsazure_AzureSQL_to_AzureSQL_filter_test_utility_df",
                "type": "DataFlowReference",
                "parameters": {
                  "runId": {
                    "value": "'@{pipeline().RunId}'",
                    "type": "Expression"
                  },
                  "DF_SOURCE_SCHEMA": {
                    "value": "'@{pipeline().parameters.P_SOURCE_SCHEMA}'",
                    "type": "Expression"
                  },
                  "DF_SOURCE_TABLE": "''",
                  "DF_SINK_SCHEMA": "''",
                  "DF_SINK_TABLE": "''",
                  "DF_FIELD_ALGORITHM_ASSIGNMENT": "'{}'",
                  "DF_COLUMNS_TO_MASK": [""],
                  "DF_BODY_TYPE_MAPPING": "'(timestamp as date, status as string, message as string, trace_id as string, items as (DELPHIX_COMPLIANCE_SERVICE_BATCH_ID as long)[])'",
                  "DF_NUMBER_OF_BATCHES": "100",
                  "DF_TRIM_LENGTHS": [1000],
                  "DF_FAIL_ON_NONCONFORMANT_DATA": "true()",
                  "DF_FIELD_DATE_FORMAT": "'{}'",
                  "DF_FILTER_CONDITION": "true()"
                },
                "datasetParameters": { "Source": {}, "Sink": {} }
              },
              "staging": {},
              "compute": { "coreCount": 8, "computeType": "General" },
              "traceLevel": "Fine"
            }
          },
          {
            "name": "Check If We Should Reapply Mapping",
            "type": "IfCondition",
            "dependsOn": [],
            "userProperties": [],
            "typeProperties": {
              "expression": {
                "value": "@pipeline().parameters.P_REAPPLY_MAPPING",
                "type": "Expression"
              },
              "ifTrueActivities": [
                {
                  "name": "Mark Table Mapping Incomplete",
                  "description": "Mark all tables in this database and schema as unmapped so that we can re-apply the mapping to them",
                  "type": "Script",
                  "dependsOn": [],
                  "policy": {
                    "timeout": "0.12:00:00",
                    "retry": 0,
                    "retryIntervalInSeconds": 30,
                    "secureOutput": false,
                    "secureInput": false
                  },
                  "userProperties": [],
                  "linkedServiceName": {
                    "referenceName": "[parameters('azuresql_mask_metadata_store_db')]",
                    "type": "LinkedServiceReference"
                  },
                  "typeProperties": {
                    "scripts": [
                      {
                        "type": "Query",
                        "text": {
                          "value": "UPDATE\n    @{variables('METADATA_SCHEMA')}.@{variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')}\nSET\n    mapping_complete = CAST(0 AS BIT),\n    masked_status = NULL\nWHERE\n    UPPER(source_dataset) = UPPER('@{variables('DATASET')}')\n    AND UPPER(source_database) = UPPER('@{pipeline().parameters.P_SOURCE_DATABASE}')\n    AND UPPER(source_schema) = UPPER('@{pipeline().parameters.P_SOURCE_SCHEMA}')",
                          "type": "Expression"
                        }
                      }
                    ],
                    "scriptBlockExecutionTimeout": "02:00:00"
                  }
                }
              ]
            }
          },
          {
            "name": "Select Tables We Should Truncate",
            "type": "Lookup",
            "dependsOn": [
              {
                "activity": "Drop Constraints",
                "dependencyConditions": ["Succeeded"]
              }
            ],
            "policy": {
              "timeout": "0.12:00:00",
              "retry": 0,
              "retryIntervalInSeconds": 30,
              "secureOutput": false,
              "secureInput": false
            },
            "userProperties": [],
            "typeProperties": {
              "source": {
                "type": "AzureSqlSource",
                "sqlReaderQuery": {
                  "value": "SELECT DISTINCT\n    dm.sink_dataset,\n    dm.sink_database,\n    dm.sink_schema,\n    dm.sink_table\nFROM\n    @{variables('METADATA_SCHEMA')}.@{variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')} dm\nWHERE\n    dm.source_dataset = '@{variables('DATASET')}'\n    AND dm.source_database = '@{pipeline().parameters.P_SOURCE_DATABASE}'\n    AND dm.source_schema = '@{pipeline().parameters.P_SOURCE_SCHEMA}'\n    AND dm.sink_dataset = '@{variables('DATASET')}'\n    AND dm.sink_database = '@{pipeline().parameters.P_SINK_DATABASE}'\n    AND dm.sink_schema = '@{pipeline().parameters.P_SINK_SCHEMA}'\n    AND (dm.mapping_complete IS NULL OR dm.mapping_complete = 0)\n    AND LOWER('@{pipeline().parameters.P_TRUNCATE_SINK_BEFORE_WRITE}') = 'true'\n",
                  "type": "Expression"
                },
                "queryTimeout": "02:00:00",
                "partitionOption": "None"
              },
              "dataset": {
                "referenceName": "dcsazure_AzureSQL_to_AzureSQL_mask_metadata_ds",
                "type": "DatasetReference",
                "parameters": {
                  "DS_METADATA_SCHEMA": {
                    "value": "@variables('METADATA_SCHEMA')",
                    "type": "Expression"
                  },
                  "DS_METADATA_TABLE": {
                    "value": "@variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')",
                    "type": "Expression"
                  }
                }
              },
              "firstRowOnly": false
            }
          },
          {
            "name": "For Each Table To Truncate",
            "type": "ForEach",
            "dependsOn": [
              {
                "activity": "Select Tables We Should Truncate",
                "dependencyConditions": ["Succeeded"]
              }
            ],
            "userProperties": [],
            "typeProperties": {
              "items": {
                "value": "@activity('Select Tables We Should Truncate').output.value",
                "type": "Expression"
              },
              "activities": [
                {
                  "name": "Truncate Selected Table",
                  "type": "Script",
                  "dependsOn": [],
                  "policy": {
                    "timeout": "0.12:00:00",
                    "retry": 0,
                    "retryIntervalInSeconds": 30,
                    "secureOutput": false,
                    "secureInput": false
                  },
                  "userProperties": [],
                  "linkedServiceName": {
                    "referenceName": "[parameters('azuresql_mask_sink_db')]",
                    "type": "LinkedServiceReference"
                  },
                  "typeProperties": {
                    "scripts": [
                      {
                        "type": "Query",
                        "text": {
                          "value": "TRUNCATE TABLE \"@{item().sink_database}\".\"@{item().sink_schema}\".\"@{item().sink_table}\"",
                          "type": "Expression"
                        }
                      }
                    ],
                    "scriptBlockExecutionTimeout": "02:00:00"
                  }
                }
              ]
            }
          },
          {
            "name": "Configure Masked Status",
            "description": "Configure Masked Status for a given table in the Source-to-Sink mapping table if it is not set. Masked Status will not be set if the table has not been masked before or if P_REAPPLY_MASKING parameter is set to true.",
            "type": "Script",
            "dependsOn": [
              {
                "activity": "Select Tables That Require Masking",
                "dependencyConditions": ["Succeeded"]
              }
            ],
            "policy": {
              "timeout": "0.12:00:00",
              "retry": 0,
              "retryIntervalInSeconds": 30,
              "secureOutput": false,
              "secureInput": false
            },
            "userProperties": [],
            "linkedServiceName": {
              "referenceName": "[parameters('azuresql_mask_metadata_store_db')]",
              "type": "LinkedServiceReference"
            },
            "typeProperties": {
              "scripts": [
                {
                  "type": "Query",
                  "text": {
                    "value": "WITH\n    tables_requiring_filters AS (\n        SELECT DISTINCT\n            dataset, specified_database, specified_schema, identified_table\n        FROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_RULESET_TABLE')}\n        WHERE ISJSON(assigned_algorithm) = 1\n            AND dataset = '@{variables('DATASET')}'\n            AND specified_database = '@{pipeline().parameters.P_SOURCE_DATABASE}'\n            AND specified_schema = '@{pipeline().parameters.P_SOURCE_SCHEMA}'\n    ), all_filters AS (\n        SELECT DISTINCT\n            JSON_VALUE(kc.value, '$.alias') as filter_alias,\n            identified_table\n        FROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_RULESET_TABLE')} d\n            CROSS APPLY OPENJSON(d.assigned_algorithm) kc\n        WHERE\n            ISJSON(d.assigned_algorithm,ARRAY) = 1\n            AND\n            d.identified_table in (\n                SELECT identified_table FROM tables_requiring_filters\n            )\n    ), sources_and_filters AS (\n        SELECT\n            dataset,\n            specified_database,\n            specified_schema,\n            tables_requiring_filters.identified_table,\n            JSON_OBJECTAGG(filter_alias:CAST(0 as BIT)) AS masked_status\n        FROM tables_requiring_filters\n            INNER JOIN all_filters\n            ON tables_requiring_filters.identified_table = all_filters.identified_table\n        GROUP BY dataset, specified_database, specified_schema, tables_requiring_filters.identified_table\n    )\n    UPDATE @{variables('METADATA_SCHEMA')}.@{variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')}\n    SET masked_status = sf.masked_status\n    FROM sources_and_filters sf\n    INNER JOIN @{variables('METADATA_SCHEMA')}.@{variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')} dm ON\n        dm.source_dataset = sf.dataset AND\n        dm.source_database = sf.specified_database AND\n        dm.source_schema = sf.specified_schema AND\n        dm.source_table = sf.identified_table\n    WHERE\n        dm.masked_status IS NULL\n        AND (dm.mapping_complete IS NULL OR dm.mapping_complete = 0)\n",
                    "type": "Expression"
                  }
                }
              ],
              "scriptBlockExecutionTimeout": "02:00:00"
            }
          },
          {
            "name": "Drop Constraints",
            "description": "Drop constraints for all tables in sink schema",
            "type": "ForEach",
            "dependsOn": [
              {
                "activity": "Select Discovered Constraints",
                "dependencyConditions": ["Succeeded"]
              }
            ],
            "userProperties": [],
            "typeProperties": {
              "items": {
                "value": "@activity('Select Discovered Constraints').output.value",
                "type": "Expression"
              },
              "activities": [
                {
                  "name": "Drop Constraint",
                  "type": "Script",
                  "dependsOn": [],
                  "policy": {
                    "timeout": "0.12:00:00",
                    "retry": 0,
                    "retryIntervalInSeconds": 30,
                    "secureOutput": false,
                    "secureInput": false
                  },
                  "userProperties": [],
                  "linkedServiceName": {
                    "referenceName": "[parameters('azuresql_mask_sink_db')]",
                    "type": "LinkedServiceReference"
                  },
                  "typeProperties": {
                    "scripts": [
                      {
                        "type": "Query",
                        "text": {
                          "value": "@concat('IF (OBJECT_ID(''',item().specified_schema, '.',item().constraint_name,''') IS NOT NULL) BEGIN ALTER TABLE ',item().specified_schema, '.', item().child_table, ' DROP CONSTRAINT ', item().constraint_name, ' END ')",
                          "type": "Expression"
                        }
                      }
                    ],
                    "scriptBlockExecutionTimeout": "02:00:00"
                  }
                },
                {
                  "name": "Update Drop Contraint Error",
                  "description": "Update capture_constraints table with the error message encountered during Drop Constraint activity",
                  "type": "Script",
                  "dependsOn": [
                    {
                      "activity": "Drop Constraint",
                      "dependencyConditions": ["Failed"]
                    }
                  ],
                  "policy": {
                    "timeout": "0.12:00:00",
                    "retry": 0,
                    "retryIntervalInSeconds": 30,
                    "secureOutput": false,
                    "secureInput": false
                  },
                  "userProperties": [],
                  "linkedServiceName": {
                    "referenceName": "[parameters('azuresql_mask_metadata_store_db')]",
                    "type": "LinkedServiceReference"
                  },
                  "typeProperties": {
                    "scripts": [
                      {
                        "type": "Query",
                        "text": {
                          "value": "UPDATE capture_constraints\nSET drop_error_message = '@{item().Error.message}'\nWHERE pipeline_run_id = '@{pipeline().RunId}'\n    AND dataset = '@{variables('DATASET')}'\n    AND specified_database = '@{pipeline().parameters.P_SINK_DATABASE}'\n    AND specified_schema = '@{pipeline().parameters.P_SINK_SCHEMA}'\n    AND identified_parent_table = '@{item().identified_parent_table}'\n    AND child_table = '@{item().child_table}'\n    AND constraint_name = '@{item().constraint_name}'",
                          "type": "Expression"
                        }
                      }
                    ],
                    "scriptBlockExecutionTimeout": "02:00:00"
                  }
                },
                {
                  "name": "Fail on Drop Constraint Error",
                  "description": "Fail on Drop Constraint Error",
                  "type": "Fail",
                  "dependsOn": [
                    {
                      "activity": "Update Drop Contraint Error",
                      "dependencyConditions": ["Succeeded"]
                    }
                  ],
                  "userProperties": [],
                  "typeProperties": {
                    "message": {
                      "value": "Failed to drop constraint @{item().constraint_name} on @{item().child_table}",
                      "type": "Expression"
                    },
                    "errorCode": "500"
                  }
                }
              ]
            }
          },
          {
            "name": "Capture Referential Constraints",
            "type": "Copy",
            "dependsOn": [
              {
                "activity": "Check If We Should Reapply Mapping",
                "dependencyConditions": ["Succeeded"]
              }
            ],
            "policy": {
              "timeout": "0.12:00:00",
              "retry": 0,
              "retryIntervalInSeconds": 30,
              "secureOutput": false,
              "secureInput": false
            },
            "userProperties": [],
            "typeProperties": {
              "source": {
                "type": "AzureSqlSource",
                "sqlReaderQuery": {
                  "value": "SELECT \n    '@{pipeline().RunId}' AS pipeline_run_id,\n    'AZURESQL' AS dataset, \n    '@{pipeline().parameters.P_SINK_DATABASE}' AS specified_database, \n    '@{pipeline().parameters.P_SINK_SCHEMA}' AS specified_schema, \n    parent_table.name AS identified_parent_table, \n    child_table.name AS child_table, \n    fk.name AS constraint_name, \n    STUFF(\n        (\n            SELECT ',' + parent_col.name \n            FROM sys.foreign_key_columns AS fk_col \n            INNER JOIN sys.columns AS parent_col \n                ON fk_col.parent_object_id = parent_col.object_id \n                AND fk_col.parent_column_id = parent_col.column_id \n            WHERE fk_col.parent_object_id = fk.parent_object_id \n                AND fk_col.constraint_object_id = fk.object_id \n            FOR XML PATH(''), TYPE\n        ).value('.', 'NVARCHAR(MAX)'), \n        1, 1, ''\n    ) AS children_columns, \n    STUFF(\n        (\n            SELECT ',' + child_col.name \n            FROM sys.foreign_key_columns AS fk_col \n            INNER JOIN sys.columns AS child_col \n                ON fk_col.referenced_object_id = child_col.object_id \n                AND fk_col.referenced_column_id = child_col.column_id \n            WHERE fk_col.parent_object_id = fk.parent_object_id \n                AND fk_col.constraint_object_id = fk.object_id \n            FOR XML PATH(''), TYPE\n        ).value('.', 'NVARCHAR(MAX)'), \n        1, 1, ''\n    ) AS parent_columns, \n    CASE \n        WHEN fk.is_disabled = 0 THEN 'Enabled' \n        ELSE 'Disabled' \n    END AS pre_drop_status, \n    GETDATE() AS drop_timestamp, \n    'N/A' AS post_create_status \nFROM sys.foreign_keys AS fk \nINNER JOIN sys.tables AS child_table \n    ON fk.parent_object_id = child_table.object_id \nINNER JOIN sys.tables AS parent_table \n    ON fk.referenced_object_id = parent_table.object_id \nWHERE LOWER(SCHEMA_NAME(parent_table.schema_id)) = LOWER('@{pipeline().parameters.P_SINK_SCHEMA}')\n",
                  "type": "Expression"
                },
                "queryTimeout": "02:00:00",
                "partitionOption": "None"
              },
              "sink": {
                "type": "AzureSqlSink",
                "writeBehavior": "upsert",
                "upsertSettings": {
                  "useTempDB": true,
                  "keys": [
                    "dataset",
                    "specified_database",
                    "specified_schema",
                    "identified_parent_table",
                    "child_table",
                    "constraint_name"
                  ]
                },
                "sqlWriterUseTableLock": false,
                "disableMetricsCollection": false
              },
              "enableStaging": false,
              "translator": {
                "type": "TabularTranslator",
                "mappings": [
                  {
                    "source": {
                      "name": "pipeline_run_id",
                      "type": "String",
                      "physicalType": "varchar"
                    },
                    "sink": {
                      "name": "pipeline_run_id",
                      "type": "Guid",
                      "physicalType": "uniqueidentifier"
                    }
                  },
                  {
                    "source": {
                      "name": "dataset",
                      "type": "String",
                      "physicalType": "varchar"
                    },
                    "sink": {
                      "name": "dataset",
                      "type": "String",
                      "physicalType": "varchar"
                    }
                  },
                  {
                    "source": {
                      "name": "specified_database",
                      "type": "String",
                      "physicalType": "varchar"
                    },
                    "sink": {
                      "name": "specified_database",
                      "type": "String",
                      "physicalType": "varchar"
                    }
                  },
                  {
                    "source": {
                      "name": "specified_schema",
                      "type": "String",
                      "physicalType": "varchar"
                    },
                    "sink": {
                      "name": "specified_schema",
                      "type": "String",
                      "physicalType": "varchar"
                    }
                  },
                  {
                    "source": {
                      "name": "identified_parent_table",
                      "type": "String",
                      "physicalType": "nvarchar"
                    },
                    "sink": {
                      "name": "identified_parent_table",
                      "type": "String",
                      "physicalType": "varchar"
                    }
                  },
                  {
                    "source": {
                      "name": "child_table",
                      "type": "String",
                      "physicalType": "nvarchar"
                    },
                    "sink": {
                      "name": "child_table",
                      "type": "String",
                      "physicalType": "varchar"
                    }
                  },
                  {
                    "source": {
                      "name": "constraint_name",
                      "type": "String",
                      "physicalType": "nvarchar"
                    },
                    "sink": {
                      "name": "constraint_name",
                      "type": "String",
                      "physicalType": "varchar"
                    }
                  },
                  {
                    "source": {
                      "name": "parent_columns",
                      "type": "String",
                      "physicalType": "nvarchar"
                    },
                    "sink": {
                      "name": "parent_columns",
                      "type": "String",
                      "physicalType": "varchar"
                    }
                  },
                  {
                    "source": {
                      "name": "children_columns",
                      "type": "String",
                      "physicalType": "nvarchar"
                    },
                    "sink": {
                      "name": "children_columns",
                      "type": "String",
                      "physicalType": "varchar"
                    }
                  },
                  {
                    "source": {
                      "name": "pre_drop_status",
                      "type": "String",
                      "physicalType": "varchar"
                    },
                    "sink": {
                      "name": "pre_drop_status",
                      "type": "String",
                      "physicalType": "varchar"
                    }
                  },
                  {
                    "source": {
                      "name": "drop_timestamp",
                      "type": "DateTime",
                      "physicalType": "datetime"
                    },
                    "sink": {
                      "name": "drop_timestamp",
                      "type": "DateTime",
                      "physicalType": "datetime"
                    }
                  },
                  {
                    "source": {
                      "name": "post_create_status",
                      "type": "String",
                      "physicalType": "varchar"
                    },
                    "sink": {
                      "name": "post_create_status",
                      "type": "String",
                      "physicalType": "varchar"
                    }
                  }
                ],
                "typeConversion": true,
                "typeConversionSettings": {
                  "allowDataTruncation": true,
                  "treatBooleanAsNumber": false
                }
              }
            },
            "inputs": [
              {
                "referenceName": "dcsazure_AzureSQL_to_AzureSQL_mask_sink_ds",
                "type": "DatasetReference",
                "parameters": { "DS_SINK_SCHEMA": " ", "DS_SINK_TABLE": " " }
              }
            ],
            "outputs": [
              {
                "referenceName": "dcsazure_AzureSQL_to_AzureSQL_mask_metadata_ds",
                "type": "DatasetReference",
                "parameters": {
                  "DS_METADATA_SCHEMA": {
                    "value": "@variables('METADATA_SCHEMA')",
                    "type": "Expression"
                  },
                  "DS_METADATA_TABLE": {
                    "value": "@variables('METADATA_CONSTRAINT_TABLE')",
                    "type": "Expression"
                  }
                }
              }
            ]
          },
          {
            "name": "Select Discovered Constraints",
            "type": "Lookup",
            "dependsOn": [
              {
                "activity": "Capture Referential Constraints",
                "dependencyConditions": ["Succeeded"]
              }
            ],
            "policy": {
              "timeout": "0.12:00:00",
              "retry": 0,
              "retryIntervalInSeconds": 30,
              "secureOutput": false,
              "secureInput": false
            },
            "userProperties": [],
            "typeProperties": {
              "source": {
                "type": "AzureSqlSource",
                "sqlReaderQuery": {
                  "value": "SELECT \n    ct.specified_database, \n    ct.specified_schema, \n    ct.identified_parent_table, \n    ct.child_table, \n    ct.constraint_name, \n    ct.parent_columns, \n    ct.children_columns, \n    ct.pre_drop_status \nFROM \n    @{variables('METADATA_SCHEMA')}.@{variables('METADATA_CONSTRAINT_TABLE')} ct\nJOIN @{variables('METADATA_SCHEMA')}.@{variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')} dm\nON \n\tct.dataset = dm.sink_dataset \n    AND ct.specified_database = dm.sink_database \n    AND ct.specified_schema = dm.sink_schema \n    AND (\n\t\tct.identified_parent_table = dm.sink_table OR\n\t\tct.child_table = dm.sink_table \n\t)\nWHERE\n    pipeline_run_id = '@{pipeline().RunId}'\n    AND LOWER(ct.specified_database) = LOWER('@{pipeline().parameters.P_SINK_DATABASE}')\n    AND LOWER(ct.specified_schema) = LOWER('@{pipeline().parameters.P_SINK_SCHEMA}')\n    AND dataset = '@{variables('DATASET')}'\n    AND LOWER(ct.pre_drop_status) = LOWER('Enabled')\n    AND (dm.mapping_complete IS NULL OR dm.mapping_complete = 0)\n\tAND (ISJSON(dm.masked_status) = 0 OR dm.masked_status IS NULL)\nORDER BY \n    ct.child_table",
                  "type": "Expression"
                },
                "queryTimeout": "02:00:00",
                "partitionOption": "None"
              },
              "dataset": {
                "referenceName": "dcsazure_AzureSQL_to_AzureSQL_mask_metadata_ds",
                "type": "DatasetReference",
                "parameters": {
                  "DS_METADATA_SCHEMA": {
                    "value": "@variables('METADATA_SCHEMA')",
                    "type": "Expression"
                  },
                  "DS_METADATA_TABLE": {
                    "value": "@variables('METADATA_CONSTRAINT_TABLE')",
                    "type": "Expression"
                  }
                }
              },
              "firstRowOnly": false
            }
          },
          {
            "name": "Create Constraints",
            "description": "Create constraints for all tables in sink schema",
            "type": "ForEach",
            "dependsOn": [
              {
                "activity": "For Each Table To Mask",
                "dependencyConditions": ["Completed"]
              },
              {
                "activity": "For Each Table With No Masking",
                "dependencyConditions": ["Completed"]
              }
            ],
            "userProperties": [],
            "typeProperties": {
              "items": {
                "value": "@activity('Select Discovered Constraints').output.value",
                "type": "Expression"
              },
              "activities": [
                {
                  "name": "Create Constraint",
                  "type": "Script",
                  "dependsOn": [],
                  "policy": {
                    "timeout": "0.12:00:00",
                    "retry": 0,
                    "retryIntervalInSeconds": 30,
                    "secureOutput": false,
                    "secureInput": false
                  },
                  "userProperties": [],
                  "linkedServiceName": {
                    "referenceName": "[parameters('azuresql_mask_sink_db')]",
                    "type": "LinkedServiceReference"
                  },
                  "typeProperties": {
                    "scripts": [
                      {
                        "type": "Query",
                        "text": {
                          "value": "@concat('ALTER TABLE ', item().specified_schema, '.', item().child_table,' ADD CONSTRAINT ', item().constraint_name,' FOREIGN KEY (',item().children_columns,') REFERENCES ',item().specified_schema, '.', item().identified_parent_table, '(', item().parent_columns,')', if(equals(toLower(item().pre_drop_status), toLower('Disabled')), 'NOCHECK', ''))",
                          "type": "Expression"
                        }
                      }
                    ],
                    "scriptBlockExecutionTimeout": "02:00:00"
                  }
                },
                {
                  "name": "Update Create Constraint Error",
                  "description": "Update capture_constraints table with the error message encountered during Create Constraint activity",
                  "type": "Script",
                  "dependsOn": [
                    {
                      "activity": "Create Constraint",
                      "dependencyConditions": ["Failed"]
                    }
                  ],
                  "policy": {
                    "timeout": "0.12:00:00",
                    "retry": 0,
                    "retryIntervalInSeconds": 30,
                    "secureOutput": false,
                    "secureInput": false
                  },
                  "userProperties": [],
                  "linkedServiceName": {
                    "referenceName": "[parameters('azuresql_mask_metadata_store_db')]",
                    "type": "LinkedServiceReference"
                  },
                  "typeProperties": {
                    "scripts": [
                      {
                        "type": "Query",
                        "text": {
                          "value": "UPDATE capture_constraints\nSET create_error_message = '@{item().Error.message}',\nlast_create_timestamp = GETDATE()\nWHERE pipeline_run_id = '@{pipeline().RunId}'\n    AND dataset = '@{variables('DATASET')}'\n    AND specified_database = '@{pipeline().parameters.P_SINK_DATABASE}'\n    AND specified_schema = '@{pipeline().parameters.P_SINK_SCHEMA}'\n    AND identified_parent_table = '@{item().identified_parent_table}'\n    AND child_table = '@{item().child_table}'\n    AND constraint_name = '@{item().constraint_name}'",
                          "type": "Expression"
                        }
                      }
                    ],
                    "scriptBlockExecutionTimeout": "02:00:00"
                  }
                },
                {
                  "name": "Fail on Create Constraint Error",
                  "description": "Fail on Create Constraint Error",
                  "type": "Fail",
                  "dependsOn": [
                    {
                      "activity": "Update Create Constraint Error",
                      "dependencyConditions": ["Succeeded"]
                    }
                  ],
                  "userProperties": [],
                  "typeProperties": {
                    "message": {
                      "value": "Failed to create constraint @{item().constraint_name} on @{item().child_table}",
                      "type": "Expression"
                    },
                    "errorCode": "500"
                  }
                }
              ]
            }
          },
          {
            "name": "Capture Referential Constraints Status",
            "type": "Copy",
            "dependsOn": [
              {
                "activity": "Create Constraints",
                "dependencyConditions": ["Succeeded"]
              }
            ],
            "policy": {
              "timeout": "0.12:00:00",
              "retry": 0,
              "retryIntervalInSeconds": 30,
              "secureOutput": false,
              "secureInput": false
            },
            "userProperties": [],
            "typeProperties": {
              "source": {
                "type": "AzureSqlSource",
                "sqlReaderQuery": {
                  "value": "SELECT \n    '@{pipeline().RunId}' AS pipeline_run_id,\n    'AZURESQL' AS dataset, \n    '@{pipeline().parameters.P_SINK_DATABASE}' AS specified_database, \n    '@{pipeline().parameters.P_SINK_SCHEMA}' AS specified_schema, \n    parent_table.name AS identified_parent_table, \n    child_table.name AS child_table, \n    fk.name AS constraint_name, \n    STUFF(\n        (\n            SELECT ',' + parent_col.name \n            FROM sys.foreign_key_columns AS fk_col \n            INNER JOIN sys.columns AS parent_col \n                ON fk_col.parent_object_id = parent_col.object_id \n                AND fk_col.parent_column_id = parent_col.column_id \n            WHERE fk_col.parent_object_id = fk.parent_object_id \n                AND fk_col.constraint_object_id = fk.object_id \n            FOR XML PATH(''), TYPE\n        ).value('.', 'NVARCHAR(MAX)'), \n        1, 1, ''\n    ) AS children_columns, \n    STUFF(\n        (\n            SELECT ',' + child_col.name \n            FROM sys.foreign_key_columns AS fk_col \n            INNER JOIN sys.columns AS child_col \n                ON fk_col.referenced_object_id = child_col.object_id \n                AND fk_col.referenced_column_id = child_col.column_id \n            WHERE fk_col.parent_object_id = fk.parent_object_id \n                AND fk_col.constraint_object_id = fk.object_id \n            FOR XML PATH(''), TYPE\n        ).value('.', 'NVARCHAR(MAX)'), \n        1, 1, ''\n    ) AS parent_columns, \n    CASE \n        WHEN fk.is_disabled = 0 THEN 'Enabled' \n        ELSE 'Disabled' \n    END AS post_create_status,\n    GETDATE() AS create_timestamp\nFROM sys.foreign_keys AS fk \nINNER JOIN sys.tables AS child_table \n    ON fk.parent_object_id = child_table.object_id \nINNER JOIN sys.tables AS parent_table \n    ON fk.referenced_object_id = parent_table.object_id \nWHERE LOWER(SCHEMA_NAME(parent_table.schema_id)) = LOWER('@{pipeline().parameters.P_SINK_SCHEMA}')",
                  "type": "Expression"
                },
                "queryTimeout": "02:00:00",
                "partitionOption": "None"
              },
              "sink": {
                "type": "AzureSqlSink",
                "writeBehavior": "upsert",
                "upsertSettings": {
                  "useTempDB": true,
                  "keys": [
                    "dataset",
                    "specified_database",
                    "specified_schema",
                    "identified_parent_table",
                    "child_table",
                    "constraint_name"
                  ]
                },
                "sqlWriterUseTableLock": false,
                "disableMetricsCollection": false
              },
              "enableStaging": false,
              "translator": {
                "type": "TabularTranslator",
                "mappings": [
                  {
                    "source": {
                      "name": "pipeline_run_id",
                      "type": "String",
                      "physicalType": "varchar"
                    },
                    "sink": {
                      "name": "pipeline_run_id",
                      "type": "Guid",
                      "physicalType": "uniqueidentifier"
                    }
                  },
                  {
                    "source": {
                      "name": "dataset",
                      "type": "String",
                      "physicalType": "varchar"
                    },
                    "sink": {
                      "name": "dataset",
                      "type": "String",
                      "physicalType": "varchar"
                    }
                  },
                  {
                    "source": {
                      "name": "specified_database",
                      "type": "String",
                      "physicalType": "varchar"
                    },
                    "sink": {
                      "name": "specified_database",
                      "type": "String",
                      "physicalType": "varchar"
                    }
                  },
                  {
                    "source": {
                      "name": "specified_schema",
                      "type": "String",
                      "physicalType": "varchar"
                    },
                    "sink": {
                      "name": "specified_schema",
                      "type": "String",
                      "physicalType": "varchar"
                    }
                  },
                  {
                    "source": {
                      "name": "identified_parent_table",
                      "type": "String",
                      "physicalType": "nvarchar"
                    },
                    "sink": {
                      "name": "identified_parent_table",
                      "type": "String",
                      "physicalType": "varchar"
                    }
                  },
                  {
                    "source": {
                      "name": "child_table",
                      "type": "String",
                      "physicalType": "nvarchar"
                    },
                    "sink": {
                      "name": "child_table",
                      "type": "String",
                      "physicalType": "varchar"
                    }
                  },
                  {
                    "source": {
                      "name": "constraint_name",
                      "type": "String",
                      "physicalType": "nvarchar"
                    },
                    "sink": {
                      "name": "constraint_name",
                      "type": "String",
                      "physicalType": "varchar"
                    }
                  },
                  {
                    "source": {
                      "name": "parent_columns",
                      "type": "String",
                      "physicalType": "nvarchar"
                    },
                    "sink": {
                      "name": "parent_columns",
                      "type": "String",
                      "physicalType": "varchar"
                    }
                  },
                  {
                    "source": {
                      "name": "children_columns",
                      "type": "String",
                      "physicalType": "nvarchar"
                    },
                    "sink": {
                      "name": "children_columns",
                      "type": "String",
                      "physicalType": "varchar"
                    }
                  },
                  {
                    "source": {
                      "name": "post_create_status",
                      "type": "String",
                      "physicalType": "varchar"
                    },
                    "sink": {
                      "name": "post_create_status",
                      "type": "String",
                      "physicalType": "varchar"
                    }
                  },
                  {
                    "source": {
                      "name": "create_timestamp",
                      "type": "DateTime",
                      "physicalType": "datetime"
                    },
                    "sink": {
                      "name": "create_timestamp",
                      "type": "DateTime",
                      "physicalType": "datetime"
                    }
                  }
                ],
                "typeConversion": true,
                "typeConversionSettings": {
                  "allowDataTruncation": true,
                  "treatBooleanAsNumber": false
                }
              }
            },
            "inputs": [
              {
                "referenceName": "dcsazure_AzureSQL_to_AzureSQL_mask_sink_ds",
                "type": "DatasetReference",
                "parameters": { "DS_SINK_SCHEMA": " ", "DS_SINK_TABLE": " " }
              }
            ],
            "outputs": [
              {
                "referenceName": "dcsazure_AzureSQL_to_AzureSQL_mask_metadata_ds",
                "type": "DatasetReference",
                "parameters": {
                  "DS_METADATA_SCHEMA": {
                    "value": "@variables('METADATA_SCHEMA')",
                    "type": "Expression"
                  },
                  "DS_METADATA_TABLE": {
                    "value": "@variables('METADATA_CONSTRAINT_TABLE')",
                    "type": "Expression"
                  }
                }
              }
            ]
          }
        ],
        "policy": { "elapsedTimeMetric": {} },
        "parameters": {
          "P_COPY_UNMASKED_TABLES": { "type": "bool", "defaultValue": false },
          "P_USE_COPY_DATAFLOW": { "type": "bool", "defaultValue": false },
          "P_FAIL_ON_NONCONFORMANT_DATA": {
            "type": "bool",
            "defaultValue": true
          },
          "P_SOURCE_DATABASE": { "type": "string" },
          "P_SINK_DATABASE": { "type": "string" },
          "P_SOURCE_SCHEMA": { "type": "string" },
          "P_SINK_SCHEMA": { "type": "string" },
          "P_REAPPLY_MAPPING": { "type": "bool", "defaultValue": true },
          "P_TRUNCATE_SINK_BEFORE_WRITE": {
            "type": "bool",
            "defaultValue": true
          }
        },
        "variables": {
          "METADATA_SCHEMA": { "type": "String", "defaultValue": "dbo" },
          "METADATA_RULESET_TABLE": {
            "type": "String",
            "defaultValue": "discovered_ruleset"
          },
          "METADATA_SOURCE_TO_SINK_MAPPING_TABLE": {
            "type": "String",
            "defaultValue": "adf_data_mapping"
          },
          "METADATA_ADF_TYPE_MAPPING_TABLE": {
            "type": "String",
            "defaultValue": "adf_type_mapping"
          },
          "BLOB_STORE_STAGING_STORAGE_PATH": {
            "type": "String",
            "defaultValue": "staging-containter"
          },
          "DATASET": { "type": "String", "defaultValue": "AZURESQL" },
          "CONDITIONAL_MASKING_RESERVED_CHARACTER": {
            "type": "String",
            "defaultValue": "%"
          },
          "METADATA_EVENT_PROCEDURE_NAME": {
            "type": "String",
            "defaultValue": "insert_adf_masking_event"
          },
          "TARGET_BATCH_SIZE": { "type": "Integer", "defaultValue": 2000 },
          "METADATA_CONSTRAINT_TABLE": {
            "type": "String",
            "defaultValue": "capture_constraints"
          }
        },
        "folder": { "name": "dcsazure_AzureSQL_to_AzureSQL" },
        "annotations": [],
        "lastPublishTime": "2024-11-20T18:33:28Z"
      },
      "dependsOn": [
        "[concat(variables('factoryId'), '/datasets/dcsazure_AzureSQL_to_AzureSQL_mask_metadata_ds')]",
        "[concat(variables('factoryId'), '/dataflows/dcsazure_AzureSQL_to_AzureSQL_filter_test_utility_df')]",
        "[concat(variables('factoryId'), '/datasets/dcsazure_AzureSQL_to_AzureSQL_mask_sink_ds')]",
        "[concat(variables('factoryId'), '/dataflows/dcsazure_AzureSQL_to_AzureSQL_unfiltered_mask_params_df')]",
        "[concat(variables('factoryId'), '/dataflows/dcsazure_AzureSQL_to_AzureSQL_unfiltered_mask_df')]",
        "[concat(variables('factoryId'), '/dataflows/dcsazure_AzureSQL_to_AzureSQL_filtered_params_df')]",
        "[concat(variables('factoryId'), '/dataflows/dcsazure_AzureSQL_to_AzureSQL_filtered_mask_df')]",
        "[concat(variables('factoryId'), '/datasets/dcsazure_AzureSQL_to_AzureSQL_mask_source_ds')]",
        "[concat(variables('factoryId'), '/dataflows/dcsazure_AzureSQL_to_AzureSQL_copy_df')]"
      ]
    },
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_AzureSQL_to_AzureSQL_mask_metadata_ds')]",
      "type": "Microsoft.DataFactory/factories/datasets",
      "apiVersion": "2018-06-01",
      "properties": {
        "linkedServiceName": {
          "referenceName": "[parameters('azuresql_mask_metadata_store_db')]",
          "type": "LinkedServiceReference"
        },
        "parameters": {
          "DS_METADATA_SCHEMA": { "type": "string" },
          "DS_METADATA_TABLE": { "type": "string" }
        },
        "folder": { "name": "dcsazure_AzureSQL_to_AzureSQL" },
        "annotations": [],
        "type": "AzureSqlTable",
        "schema": [],
        "typeProperties": {
          "schema": {
            "value": "@dataset().DS_METADATA_SCHEMA",
            "type": "Expression"
          },
          "table": {
            "value": "@dataset().DS_METADATA_TABLE",
            "type": "Expression"
          }
        }
      },
      "dependsOn": []
    },
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_AzureSQL_to_AzureSQL_filter_test_utility_df')]",
      "type": "Microsoft.DataFactory/factories/dataflows",
      "apiVersion": "2018-06-01",
      "properties": {
        "folder": { "name": "dcsazure_AzureSQL_to_AzureSQL" },
        "type": "MappingDataFlow",
        "typeProperties": {
          "sources": [
            {
              "linkedService": {
                "referenceName": "[parameters('azuresql_mask_source_db')]",
                "type": "LinkedServiceReference"
              },
              "name": "Source",
              "description": "Select source data at DF_SOURCE_SCHEMA.DF_SOURCE_TABLE using an inline dataset"
            }
          ],
          "sinks": [
            {
              "linkedService": {
                "referenceName": "[parameters('azuresql_mask_sink_db')]",
                "type": "LinkedServiceReference"
              },
              "name": "Sink",
              "description": "Sink results of masking to data store by sinking the unrolled results of the masking call to the columns of the same name in the data sink"
            }
          ],
          "transformations": [
            {
              "name": "FilterToAppropriateRows",
              "description": "Filter base table based on supplied filter"
            }
          ],
          "scriptLines": [
            "parameters{",
            "     runId as string (''),",
            "     DF_SOURCE_SCHEMA as string (''),",
            "     DF_SOURCE_TABLE as string (''),",
            "     DF_SINK_SCHEMA as string (''),",
            "     DF_SINK_TABLE as string (''),",
            "     DF_FIELD_ALGORITHM_ASSIGNMENT as string ('{}'),",
            "     DF_COLUMNS_TO_MASK as string[] ([\"\"]),",
            "     DF_BODY_TYPE_MAPPING as string ('(timestamp as date, status as string, message as string, trace_id as string, items as (DELPHIX_COMPLIANCE_SERVICE_BATCH_ID as long)[])'),",
            "     DF_NUMBER_OF_BATCHES as integer (100),",
            "     DF_TRIM_LENGTHS as integer[] ([1000]),",
            "     DF_FAIL_ON_NONCONFORMANT_DATA as boolean (true()),",
            "     DF_FIELD_DATE_FORMAT as string ('{}'),",
            "     DF_FILTER_CONDITION as boolean (true())",
            "}",
            "source(allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'table',",
            "     store: 'sqlserver',",
            "     schemaName: ($DF_SOURCE_SCHEMA),",
            "     tableName: ($DF_SOURCE_TABLE),",
            "     isolationLevel: 'READ_UNCOMMITTED',",
            "     partitionBy('roundRobin', 32)) ~> Source",
            "Source filter($DF_FILTER_CONDITION) ~> FilterToAppropriateRows",
            "FilterToAppropriateRows sink(allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'table',",
            "     store: 'sqlserver',",
            "     schemaName: ($DF_SINK_SCHEMA),",
            "     tableName: ($DF_SINK_TABLE),",
            "     insertable: true,",
            "     updateable: false,",
            "     deletable: false,",
            "     upsertable: false,",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true,",
            "     errorHandlingOption: 'stopOnFirstError',",
            "     mapColumn(",
            "          each(match(name!=\"DELPHIX_COMPLIANCE_SERVICE_BATCH_ID\"&&name!=\"DELPHIX_COMPLIANCE_SERVICE_SORT_ID\"))",
            "     ),",
            "     preCommands: [],",
            "     postCommands: []) ~> Sink"
          ]
        }
      },
      "dependsOn": []
    },
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_AzureSQL_to_AzureSQL_mask_sink_ds')]",
      "type": "Microsoft.DataFactory/factories/datasets",
      "apiVersion": "2018-06-01",
      "properties": {
        "linkedServiceName": {
          "referenceName": "[parameters('azuresql_mask_sink_db')]",
          "type": "LinkedServiceReference"
        },
        "parameters": {
          "DS_SINK_SCHEMA": { "type": "string" },
          "DS_SINK_TABLE": { "type": "string" }
        },
        "folder": { "name": "dcsazure_AzureSQL_to_AzureSQL" },
        "annotations": [],
        "type": "AzureSqlTable",
        "schema": [],
        "typeProperties": {
          "schema": {
            "value": "@dataset().DS_SINK_SCHEMA",
            "type": "Expression"
          },
          "table": { "value": "@dataset().DS_SINK_TABLE", "type": "Expression" }
        }
      },
      "dependsOn": []
    },
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_AzureSQL_to_AzureSQL_unfiltered_mask_params_df')]",
      "type": "Microsoft.DataFactory/factories/dataflows",
      "apiVersion": "2018-06-01",
      "properties": {
        "folder": { "name": "dcsazure_AzureSQL_to_AzureSQL" },
        "type": "MappingDataFlow",
        "typeProperties": {
          "sources": [
            {
              "linkedService": {
                "referenceName": "[parameters('azuresql_mask_metadata_store_db')]",
                "type": "LinkedServiceReference"
              },
              "name": "Ruleset",
              "description": "Get the ruleset table from the metadata store at DF_METADATA_SCHEMA.DF_METADATA_RULESET_TABLE"
            },
            {
              "linkedService": {
                "referenceName": "[parameters('azuresql_mask_metadata_store_db')]",
                "type": "LinkedServiceReference"
              },
              "name": "TypeMapping",
              "description": "Get the type mapping table from the metadata store at DF_METADATA_STORE.DF_METADATA_ADF_TYPE_MAPPING_TABLE"
            }
          ],
          "sinks": [
            {
              "name": "MaskingParameterOutput",
              "description": "Sink results of computing masking parameters to activity output cache"
            }
          ],
          "transformations": [
            {
              "name": "FilterToSingleTable",
              "description": "Filter ruleset table down to the table in question by specifying dataset, specified_database, specified_schema, identified_table, and assigned_algorithm - making sure they match the dataset associated with each version of the dataflow, DF_SOURCE_DATABASE, DF_SOURCE_SCHEMA, DF_SOURCE_TABLE, and not empty or null (respectively). This filters the ruleset down to only the rules that need to be applied for masking this particular table"
            },
            {
              "name": "RulesetWithTypes",
              "description": "Join the ruleset table with the type mapping table based on the type of the column and the translation of that type to an ADF type"
            },
            {
              "name": "RulesetWithAlgorithmTypeMapping",
              "description": "Generate several columns:\n\n    output_row that always contains 1 (used later for Aggregate and Join operations)\n    adf_type_conversion that contains a string like <column_name> as <adf_type>\n    column_width_estimate that contains an integer that uses DF_COLUMN_WIDTH_ESTIMATE as the width for any column where identified_column_max_length is not positive, and identified_column_max_length plus some padding otherwise"
            },
            {
              "name": "GenerateMaskParameters",
              "description": "Grouped by output_row produce the following aggregates\n\n    FieldAlgorithmAssignments - a JSON string that maps a column name to its assigned algorithm\n    ColumnsToMask - a list of the column names that have an algorithm assigned\n    DataFactoryTypeMapping - a string that can be used by ADF to parse the output of a call to the Delphix masking endpoint, leveraging the adf_type_conversion column derived previously\n    NumberOfBatches - an integer value determined by computing the number of batches leveraging the max row_count as specified in the ruleset table, and the sum of column_width_estimate column derived previously\n    TrimLengths - a list of the actual widths of the columns so that will be used by the masking data flow to trim output before sinking"
            },
            {
              "name": "ModifyNumberOfBatches",
              "description": "Modifies the number of batches to be at least 1"
            },
            {
              "name": "FilterToDataSourceType",
              "description": "Filter type mapping table down to only the dataset in question"
            },
            {
              "name": "ParseMetadata",
              "description": "Parse the content from the metadata column that contains JSON, specifically handling parsing of known keys (i.e. date_format)"
            },
            {
              "name": "DateFormatString",
              "description": "Derive columns as necessary for handling the parsed data (i.e. consume parsed_metadata.date_format and put it in a column date_format_string), and add an output_row column that always contains 1 (used later for Aggregate and Join operations)"
            },
            {
              "name": "DateFormatHeader",
              "description": "Create DateFormatAssignment, grouped by output_row (which is always 1), generating a JSON string that maps a column to its specified date format"
            },
            {
              "name": "AllMaskingParameters",
              "description": "Perform an inner join on output_row with the output of RemoveUnnecessaryColumns - combining all computed masking parameters into the same output stream"
            },
            {
              "name": "DateFormatHeaderHandlingNulls",
              "description": "Update column DateFormatAssignments to coalesce DateFormatAssignments, and NoFormatHeader (i.e. if DateFormatAssignments is null, take NoFormatHeader, which won't be null)"
            },
            {
              "name": "RemoveUnnecessaryColumns",
              "description": "Remove intermediate columns"
            },
            {
              "name": "SplitOnDateFormat",
              "description": "Split the data into two streams, data that contains a specified date\nformat, and data that does not"
            },
            {
              "name": "NoFormatHeader",
              "description": "Create NoFormatHeader, that generates a JSON string containing an empty map when all values are null, grouped by output_row (which is always 1)"
            },
            {
              "name": "JoinDateHeaders",
              "description": "Full outer join both DateFormatHeader and NoFormatHeader where output_row = output_row"
            }
          ],
          "scriptLines": [
            "parameters{",
            "     runId as string (''),",
            "     DF_METADATA_SCHEMA as string ('dbo'),",
            "     DF_METADATA_RULESET_TABLE as string ('discovered_ruleset'),",
            "     DF_METADATA_ADF_TYPE_MAPPING_TABLE as string ('adf_type_mapping'),",
            "     DF_SOURCE_DB as string (''),",
            "     DF_SOURCE_SCHEMA as string (''),",
            "     DF_SOURCE_TABLE as string (''),",
            "     DF_COLUMN_WIDTH_ESTIMATE as integer (1000),",
            "     DF_DATASET as string ('AZURESQL')",
            "}",
            "source(output(",
            "          dataset as string,",
            "          specified_database as string,",
            "          specified_schema as string,",
            "          identified_table as string,",
            "          identified_column as string,",
            "          identified_column_type as string,",
            "          identified_column_max_length as integer,",
            "          ordinal_position as integer,",
            "          row_count as long,",
            "          metadata as string,",
            "          profiled_domain as string,",
            "          profiled_algorithm as string,",
            "          confidence_score as decimal(6,5),",
            "          rows_profiled as long,",
            "          assigned_algorithm as string,",
            "          last_profiled_updated_timestamp as timestamp",
            "     ),",
            "     allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'table',",
            "     store: 'sqlserver',",
            "     schemaName: ($DF_METADATA_SCHEMA),",
            "     tableName: ($DF_METADATA_RULESET_TABLE),",
            "     isolationLevel: 'READ_UNCOMMITTED') ~> Ruleset",
            "source(output(",
            "          dataset as string,",
            "          dataset_type as string,",
            "          adf_type as string",
            "     ),",
            "     allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'table',",
            "     store: 'sqlserver',",
            "     schemaName: ($DF_METADATA_SCHEMA),",
            "     tableName: ($DF_METADATA_ADF_TYPE_MAPPING_TABLE),",
            "     isolationLevel: 'READ_UNCOMMITTED') ~> TypeMapping",
            "Ruleset filter(equalsIgnoreCase(dataset, $DF_DATASET) ",
            "&& equalsIgnoreCase(specified_database, $DF_SOURCE_DB) ",
            "&& equalsIgnoreCase(specified_schema, $DF_SOURCE_SCHEMA) ",
            "&& equalsIgnoreCase(identified_table, $DF_SOURCE_TABLE)",
            "&& !isNull(assigned_algorithm)",
            "&& !equalsIgnoreCase(assigned_algorithm, '')) ~> FilterToSingleTable",
            "FilterToSingleTable, FilterToDataSourceType join(identified_column_type <=> dataset_type,",
            "     joinType:'inner',",
            "     matchType:'exact',",
            "     ignoreSpaces: false,",
            "     broadcast: 'left')~> RulesetWithTypes",
            "RulesetWithTypes derive(output_row = 1,",
            "          adf_type_conversion = concat(identified_column, ' as ', adf_type),",
            "          column_width_estimate = iif(identified_column_max_length > 0, identified_column_max_length+4, $DF_COLUMN_WIDTH_ESTIMATE)) ~> RulesetWithAlgorithmTypeMapping",
            "RulesetWithAlgorithmTypeMapping aggregate(groupBy(output_row),",
            "     FieldAlgorithmAssignments = regexReplace(reduce(mapAssociation(keyValues(collect(identified_column), collect(assigned_algorithm)), '\"' + #key + '\":\"' + #value + '\"'), '{', #acc + #item + ',', #result + '}'), ',}', '}'),",
            "          ColumnsToMask = regexReplace(reduce(collect(identified_column), '[',  #acc + '\"' + #item + '\",', #result + ']'), ',]', ']'),",
            "          DataFactoryTypeMapping = concat(\"'\", '(timestamp as date, status as string, message as string, trace_id as string, items as (DELPHIX_COMPLIANCE_SERVICE_BATCH_ID as long, ',",
            "    regexReplace(reduce(collect(identified_column + ' as ' + adf_type), '', #acc + #item + ', ', #result + ')'), ', \\\\)', ')'),",
            "    '[])', \"'\"),",
            "          NumberOfBatches = toInteger(ceil(((max(row_count) * (sum(column_width_estimate) + log10(max(row_count)) +1)) / (2000000 * .9)))),",
            "          TrimLengths = regexReplace(reduce(collect(identified_column_max_length), '[',  #acc + toString(#item) + ',', toString(#result) + ']'), ',]', ']')) ~> GenerateMaskParameters",
            "GenerateMaskParameters derive(NumberOfBatches = iif(NumberOfBatches > 0, NumberOfBatches, 1)) ~> ModifyNumberOfBatches",
            "TypeMapping filter(equalsIgnoreCase(dataset, $DF_DATASET)) ~> FilterToDataSourceType",
            "FilterToSingleTable parse(parsed_metadata = metadata ? (date_format as string),",
            "     format: 'json',",
            "     documentForm: 'singleDocument') ~> ParseMetadata",
            "ParseMetadata derive(output_row = 1,",
            "          date_format_string = parsed_metadata.date_format) ~> DateFormatString",
            "SplitOnDateFormat@ContainsDateFormat aggregate(groupBy(output_row),",
            "     DateFormatAssignments = regexReplace(reduce(mapAssociation(keyValues(collect(identified_column), collect(date_format_string)), '\"' + #key + '\":\"' + #value + '\"'), '{', #acc + #item + ',', #result + '}'), ',}', '}')) ~> DateFormatHeader",
            "ModifyNumberOfBatches, RemoveUnnecessaryColumns join(GenerateMaskParameters@output_row == RemoveUnnecessaryColumns@output_row,",
            "     joinType:'inner',",
            "     matchType:'exact',",
            "     ignoreSpaces: false,",
            "     broadcast: 'auto')~> AllMaskingParameters",
            "JoinDateHeaders derive(DateFormatAssignments = coalesce(DateFormatAssignments,NoFormatHeader),",
            "          output_row = coalesce(DateFormatHeader@output_row, NoFormatHeader@output_row)) ~> DateFormatHeaderHandlingNulls",
            "DateFormatHeaderHandlingNulls select(mapColumn(",
            "          output_row,",
            "          DateFormatAssignments",
            "     ),",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true) ~> RemoveUnnecessaryColumns",
            "DateFormatString split(not(isNull(date_format_string)),",
            "     disjoint: false) ~> SplitOnDateFormat@(ContainsDateFormat, DoesNotContainDateFormat)",
            "SplitOnDateFormat@DoesNotContainDateFormat aggregate(groupBy(output_row),",
            "     NoFormatHeader = reduce(collect(date_format_string), '{', #acc + #item + ',', #result + '}')) ~> NoFormatHeader",
            "DateFormatHeader, NoFormatHeader join(DateFormatHeader@output_row == NoFormatHeader@output_row,",
            "     joinType:'outer',",
            "     matchType:'exact',",
            "     ignoreSpaces: false,",
            "     broadcast: 'auto')~> JoinDateHeaders",
            "AllMaskingParameters sink(validateSchema: false,",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true,",
            "     store: 'cache',",
            "     format: 'inline',",
            "     output: true,",
            "     saveOrder: 1) ~> MaskingParameterOutput"
          ]
        }
      },
      "dependsOn": []
    },
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_AzureSQL_to_AzureSQL_unfiltered_mask_df')]",
      "type": "Microsoft.DataFactory/factories/dataflows",
      "apiVersion": "2018-06-01",
      "properties": {
        "folder": { "name": "dcsazure_AzureSQL_to_AzureSQL" },
        "type": "MappingDataFlow",
        "typeProperties": {
          "sources": [
            {
              "linkedService": {
                "referenceName": "[parameters('azuresql_mask_source_db')]",
                "type": "LinkedServiceReference"
              },
              "name": "Source",
              "description": "Select source data at DF_SOURCE_SCHEMA.DF_SOURCE_TABLE using an inline dataset"
            }
          ],
          "sinks": [
            {
              "linkedService": {
                "referenceName": "[parameters('azuresql_mask_sink_db')]",
                "type": "LinkedServiceReference"
              },
              "name": "Sink",
              "description": "Sink results of masking to data store by sinking the unrolled results of the masking call to the columns of the same name in the data sink"
            }
          ],
          "transformations": [
            {
              "name": "DCSForAzureAPI",
              "linkedService": {
                "referenceName": "[parameters('ProdDCSForAzureService')]",
                "type": "LinkedServiceReference"
              }
            },
            {
              "name": "AddSortKey",
              "description": "Create column DELPHIX_COMPLIANCE_SERVICE_SORT_ID that consists of SHA of the data across all columns in the table - every row will have this value and it cannot be null"
            },
            {
              "name": "SortBySortKey",
              "description": "Sort the table by the value in DELPHIX_COMPLIANCE_SERVICE_SORT_ID, as we need the table to be in a particular order before we apply a surrogate key"
            },
            {
              "name": "CreateSurrogateKey",
              "description": "Add a DELPHIX_COMPLIANCE_SERVICE_BATCH_ID column that increments by 1 and starts at 1 after applying the sorting"
            },
            {
              "name": "WrapValuesInArray",
              "description": "For each column we wish to mask, convert the value into an array, this is needed to preserve null values as null when using collect, as null values become []"
            },
            {
              "name": "SelectColumnsUnmasked",
              "description": "Select only columns that don't require masking"
            },
            {
              "name": "AggregateColumnsByBatch",
              "description": "For each column we wish to mask, aggregate to a list using collect, grouped by DELPHIX_COMPLIANCE_SERVICE_BATCH_ID with integer division by DF_NUMBER_OF_ROWS_PER_BATCH - so there will be a targeted number of total rows in each aggregation, name the group as DELPHIX_COMPLIANCE_SERVICE_BATCH_GROUP"
            },
            {
              "name": "FlattenValuesOutOfArray",
              "description": "For each column we wish to mask, flatten the value out of the array, in the case where the value was previously [], it becomes null"
            },
            {
              "name": "AssertNoFailures",
              "description": "Confirm that we received a 200 response status from the API request"
            },
            {
              "name": "FlattenAggregateData",
              "description": "Unroll the API response body into named columns"
            },
            {
              "name": "JoinMaskedAndUnmaskedData",
              "description": "Inner join on SelectColumnsUnmasked and TrimMaskedStrings based on matching DELPHIX_COMPLIANCE_SERVICE_BATCH_ID"
            },
            {
              "name": "TrimMaskedStrings",
              "description": "For each column with a string type, trim the string to length based on the value in DF_TRIM_LENGTHS - this is needed as masking a string may produce a longer string that exceeds the column width in the sink"
            }
          ],
          "scriptLines": [
            "parameters{",
            "     runId as string (''),",
            "     DF_SOURCE_SCHEMA as string (''),",
            "     DF_SOURCE_TABLE as string (''),",
            "     DF_SINK_SCHEMA as string (''),",
            "     DF_SINK_TABLE as string (''),",
            "     DF_FIELD_ALGORITHM_ASSIGNMENT as string ('{}'),",
            "     DF_COLUMNS_TO_MASK as string[] ([\"\"]),",
            "     DF_BODY_TYPE_MAPPING as string ('(timestamp as date, status as string, message as string, trace_id as string, items as (DELPHIX_COMPLIANCE_SERVICE_BATCH_ID as long)[])'),",
            "     DF_NUMBER_OF_ROWS_PER_BATCH as integer (1000),",
            "     DF_TRIM_LENGTHS as integer[] ([1000]),",
            "     DF_FAIL_ON_NONCONFORMANT_DATA as boolean (true()),",
            "     DF_FIELD_DATE_FORMAT as string ('{}')",
            "}",
            "source(allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'table',",
            "     store: 'sqlserver',",
            "     schemaName: ($DF_SOURCE_SCHEMA),",
            "     tableName: ($DF_SOURCE_TABLE),",
            "     isolationLevel: 'READ_UNCOMMITTED',",
            "     partitionBy('roundRobin', 32)) ~> Source",
            "FlattenValuesOutOfArray call(mapColumn(",
            "          each(match(name!='DELPHIX_COMPLIANCE_SERVICE_BATCH_GROUP'))",
            "     ),",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true,",
            "     output(",
            "          headers as [string,string],",
            "          body as (timestamp as date, status as string, message as string, trace_id as string, items as (DELPHIX_COMPLIANCE_SERVICE_BATCH_ID as long, LAST_NAME as string, FIRST_NAME as string, EMAIL as string, PHONE as string, STAFF_ID as integer, ACTIVE as integer, STORE_ID as integer, MANAGER_ID as integer)[]),",
            "          status as string",
            "     ),",
            "     allowSchemaDrift: true,",
            "     format: 'rest',",
            "     store: 'restservice',",
            "     timeout: 30,",
            "     requestInterval: 0,",
            "     headers = ['Run-Id' -> $runId, 'Field-Algorithm-Assignment' -> $DF_FIELD_ALGORITHM_ASSIGNMENT, 'Fail-On-Non-Conformant-Data' -> iif($DF_FAIL_ON_NONCONFORMANT_DATA,'true','false'), 'Field-Date-Format' -> $DF_FIELD_DATE_FORMAT],",
            "     httpMethod: 'POST',",
            "     entity: '/v1/masking/batchMaskByColumn',",
            "     headerColumnName: 'headers',",
            "     bodyColumnName: 'body',",
            "     statusColumnName: 'status',",
            "     addResponseCode: true,",
            "     requestFormat: ['type' -> 'json'],",
            "     responseFormat: ['type' -> 'json', 'documentForm' -> 'documentPerLine'],",
            "     columnTypeMap: ['body'->'$DF_BODY_TYPE_MAPPING']) ~> DCSForAzureAPI",
            "Source derive(DELPHIX_COMPLIANCE_SERVICE_SORT_ID = sha2(256, columns())) ~> AddSortKey",
            "AddSortKey sort(asc(DELPHIX_COMPLIANCE_SERVICE_SORT_ID, false)) ~> SortBySortKey",
            "SortBySortKey keyGenerate(output(DELPHIX_COMPLIANCE_SERVICE_BATCH_ID as long),",
            "     startAt: 1L,",
            "     stepValue: 1L) ~> CreateSurrogateKey",
            "CreateSurrogateKey derive(each(match(contains($DF_COLUMNS_TO_MASK,#item==name)), $$ = array($$))) ~> WrapValuesInArray",
            "CreateSurrogateKey select(mapColumn(",
            "          each(match(!contains($DF_COLUMNS_TO_MASK,#item==name)))",
            "     ),",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true) ~> SelectColumnsUnmasked",
            "WrapValuesInArray aggregate(groupBy(DELPHIX_COMPLIANCE_SERVICE_BATCH_GROUP = toInteger(ceil(DELPHIX_COMPLIANCE_SERVICE_BATCH_ID/$DF_NUMBER_OF_ROWS_PER_BATCH))),",
            "     each(match(contains($DF_COLUMNS_TO_MASK,#item==name)||(name==\"DELPHIX_COMPLIANCE_SERVICE_BATCH_ID\")), $$ = collect($$))) ~> AggregateColumnsByBatch",
            "AggregateColumnsByBatch derive(each(match(contains($DF_COLUMNS_TO_MASK,#item==name)||(name==\"DELPHIX_COMPLIANCE_SERVICE_BATCH_ID\")), $$ = flatten($$))) ~> FlattenValuesOutOfArray",
            "DCSForAzureAPI assert(expectTrue(toInteger(regexExtract(status, '(\\\\d+)', 1)) == 200, false, 'Failed_request', null, iif(isNull(body.message), status, concatWS(', ', 'timestamp: ' + toString(body.timestamp), 'status: ' + body.status, 'message: ' + body.message, 'trace_id: ' + body.trace_id))),",
            "     abort: true) ~> AssertNoFailures",
            "AssertNoFailures foldDown(unroll(body.items),",
            "     mapColumn(",
            "          every(body.items,match(true()))",
            "     ),",
            "     skipDuplicateMapInputs: false,",
            "     skipDuplicateMapOutputs: false) ~> FlattenAggregateData",
            "SelectColumnsUnmasked, TrimMaskedStrings join(SelectColumnsUnmasked@DELPHIX_COMPLIANCE_SERVICE_BATCH_ID == FlattenAggregateData@DELPHIX_COMPLIANCE_SERVICE_BATCH_ID,",
            "     joinType:'inner',",
            "     matchType:'exact',",
            "     ignoreSpaces: false,",
            "     broadcast: 'off')~> JoinMaskedAndUnmaskedData",
            "FlattenAggregateData derive(each(match(type=='string'), $$ = iif(",
            "    greater($DF_TRIM_LENGTHS[toInteger($# - 1)], 0), ",
            "    substring($$, 1, $DF_TRIM_LENGTHS[toInteger($# - 1)]), ",
            "    $$",
            "))) ~> TrimMaskedStrings",
            "JoinMaskedAndUnmaskedData sink(allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'table',",
            "     store: 'sqlserver',",
            "     schemaName: ($DF_SINK_SCHEMA),",
            "     tableName: ($DF_SINK_TABLE),",
            "     preSQLs:[(concat(\"IF EXISTS (SELECT 1 FROM sys.columns WHERE object_id = OBJECT_ID('\", $DF_SINK_SCHEMA, \"' + '.' + '\", $DF_SINK_TABLE, \"') AND is_identity = 1) BEGIN \", 'SET IDENTITY_INSERT', ' ', $DF_SINK_SCHEMA, '.', $DF_SINK_TABLE, ' ', 'ON; END'))],",
            "     insertable: true,",
            "     updateable: false,",
            "     deletable: false,",
            "     upsertable: false,",
            "     postSQLs:[(concat(\"IF EXISTS (SELECT 1 FROM sys.columns WHERE object_id = OBJECT_ID('\", $DF_SINK_SCHEMA, \"' + '.' + '\", $DF_SINK_TABLE, \"') AND is_identity = 1) BEGIN \", 'SET IDENTITY_INSERT', ' ', $DF_SINK_SCHEMA, '.', $DF_SINK_TABLE, ' ', 'OFF; END'))],",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true,",
            "     errorHandlingOption: 'stopOnFirstError',",
            "     mapColumn(",
            "          each(match(name!=\"DELPHIX_COMPLIANCE_SERVICE_BATCH_ID\"&&name!=\"DELPHIX_COMPLIANCE_SERVICE_SORT_ID\"))",
            "     ),",
            "     preCommands: [],",
            "     postCommands: []) ~> Sink"
          ]
        }
      },
      "dependsOn": []
    },
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_AzureSQL_to_AzureSQL_filtered_params_df')]",
      "type": "Microsoft.DataFactory/factories/dataflows",
      "apiVersion": "2018-06-01",
      "properties": {
        "description": "Generate masking parameters when conditional algorithms are defined",
        "folder": { "name": "dcsazure_AzureSQL_to_AzureSQL" },
        "type": "MappingDataFlow",
        "typeProperties": {
          "sources": [
            {
              "linkedService": {
                "referenceName": "[parameters('azuresql_mask_metadata_store_db')]",
                "type": "LinkedServiceReference"
              },
              "name": "Ruleset",
              "description": "Get the ruleset table from the metadata store at DF_METADATA_SCHEMA.DF_METADATA_RULESET_TABLE"
            },
            {
              "linkedService": {
                "referenceName": "[parameters('azuresql_mask_metadata_store_db')]",
                "type": "LinkedServiceReference"
              },
              "name": "TypeMapping",
              "description": "Get the type mapping table from the metadata store at DF_METADATA_STORE.DF_METADATA_ADF_TYPE_MAPPING_TABLE"
            }
          ],
          "sinks": [
            {
              "name": "MaskingParameterOutput",
              "description": "Sink results of computing masking parameters to activity output cache"
            }
          ],
          "transformations": [
            {
              "name": "FilterToSingleTable",
              "description": "Filter ruleset table down to the table in question by specifying dataset, specified_database, specified_schema, identified_table, and assigned_algorithm - making sure they match the dataset associated with each version of the dataflow, DF_SOURCE_DATABASE, DF_SOURCE_SCHEMA, DF_SOURCE_TABLE, and not empty or null (respectively). This filters the ruleset down to only the rules that need to be applied for masking this particular table"
            },
            {
              "name": "RulesetWithTypes",
              "description": "Join the ruleset table with the type mapping table based on the type of the column and the translation of that type to an ADF type"
            },
            {
              "name": "RulesetWithAlgorithmTypeMapping",
              "description": "Generate several columns:\n\n    output_row that always contains 1 (used later for Aggregate and Join operations)\n    adf_type_conversion that contains a string like <column_name> as <adf_type>\n    column_width_estimate that contains an integer that uses DF_COLUMN_WIDTH_ESTIMATE as the width for any column where identified_column_max_length is not positive, and identified_column_max_length plus some padding otherwise"
            },
            {
              "name": "GenerateMaskParameters",
              "description": "Grouped by output_row produce the following aggregates\n\n    FieldAlgorithmAssignments - a JSON string that maps a column name to its assigned algorithm\n    ColumnsToMask - a list of the column names that have an algorithm assigned\n    DataFactoryTypeMapping - a string that can be used by ADF to parse the output of a call to the Delphix masking endpoint, leveraging the adf_type_conversion column derived previously\n    NumberOfBatches - an integer value determined by computing the number of batches leveraging the max row_count as specified in the ruleset table, and the sum of column_width_estimate column derived previously\n    TrimLengths - a list of the actual widths of the columns so that will be used by the masking data flow to trim output before sinking"
            },
            {
              "name": "ModifyNumberOfBatches",
              "description": "Modifies the number of batches to be at least 1"
            },
            {
              "name": "FilterToDataSourceType",
              "description": "Filter type mapping table down to only the dataset in question"
            },
            {
              "name": "ParseMetadata",
              "description": "Parse the content from the metadata column that contains JSON, specifically handling parsing of known keys (i.e. date_format)"
            },
            {
              "name": "DateFormatString",
              "description": "Derive columns as necessary for handling the parsed data (i.e. consume parsed_metadata.date_format, and conditional_date_format and put it in a column date_format_string), and add an output_row column that always contains 1 (used later for Aggregate and Join operations)"
            },
            {
              "name": "DateFormatHeader",
              "description": "Create DateFormatAssignment, grouped by output_row (which is always 1), generating a JSON string that maps a column to its specified date format"
            },
            {
              "name": "AllMaskingParameters",
              "description": "Perform an inner join on output_row with the output of RemoveUnnecessaryColumns - combining all computed masking parameters into the same output stream"
            },
            {
              "name": "DateFormatHeaderHandlingNulls",
              "description": "Update column DateFormatAssignments to coalesce DateFormatAssignments, and NoFormatHeader (i.e. if DateFormatAssignments is null, take NoFormatHeader, which won't be null)"
            },
            {
              "name": "RemoveUnnecessaryColumns",
              "description": "Remove intermediate columns"
            },
            {
              "name": "SplitOnDateFormat",
              "description": "Split the data into two streams, data that contains a specified date\nformat, and data that does not"
            },
            {
              "name": "NoFormatHeader",
              "description": "Create NoFormatHeader, that generates a JSON string containing an empty map when all values are null, grouped by output_row (which is always 1)"
            },
            {
              "name": "JoinDateHeaders",
              "description": "Full outer join both DateFormatHeader and NoFormatHeader where output_row = output_row"
            },
            {
              "name": "ParseKeyColumn",
              "description": "Parse key column conditions"
            },
            {
              "name": "HandleCompositeAlgorithms",
              "description": "Conditionally distributing the data in assigned_algorithm groups, the type of data in assigned_algorithms"
            },
            {
              "name": "ParseAlgorithm",
              "description": "Parse conditional algorithm assignment"
            },
            {
              "name": "FlattenKeyConditions",
              "description": "Unroll the aliases and conditions from the key column"
            },
            {
              "name": "FilterToConditionKey",
              "description": "Filter out rows that don't apply to this condition key, and rows that don't include an assigned algorithm"
            },
            {
              "name": "JoinConditionalAlgorithms",
              "description": "Join the key column, its conditions, and the algorithms assigned to those conditions"
            },
            {
              "name": "SimplifySimpleRulesetTable",
              "description": "Simplify the columns of the ruleset table for algorithms that are always applied"
            },
            {
              "name": "SimplifyConditionalRulesetTable",
              "description": "Rename columns in the conditional ruleset table to match the simplified ruleset table"
            },
            {
              "name": "UnionAllRules",
              "description": "Combining rows from conditional and non-conditional ruleset tables"
            },
            {
              "name": "FlattenAlgorithmAssignments",
              "description": "Unroll the conditions from the conditional algorithm assignment"
            },
            {
              "name": "FlattenConditionalFormatting",
              "description": "Unroll the conditions from the conditional date_format assignment"
            },
            {
              "name": "FilterUnmatchingAlias",
              "description": "Filter down to only this filer alias, as necessary"
            }
          ],
          "scriptLines": [
            "parameters{",
            "     runId as string (''),",
            "     DF_METADATA_SCHEMA as string ('dbo'),",
            "     DF_METADATA_RULESET_TABLE as string ('discovered_ruleset'),",
            "     DF_METADATA_ADF_TYPE_MAPPING_TABLE as string ('adf_type_mapping'),",
            "     DF_SOURCE_DATABASE as string (''),",
            "     DF_SOURCE_SCHEMA as string (''),",
            "     DF_SOURCE_TABLE as string (''),",
            "     DF_COLUMN_WIDTH_ESTIMATE as integer (1000),",
            "     DF_FILTER_KEY as string (''),",
            "     DF_DATASET as string ('AZURESQL')",
            "}",
            "source(output(",
            "          dataset as string,",
            "          specified_database as string,",
            "          specified_schema as string,",
            "          identified_table as string,",
            "          identified_column as string,",
            "          identified_column_type as string,",
            "          identified_column_max_length as integer,",
            "          ordinal_position as integer,",
            "          row_count as long,",
            "          metadata as string,",
            "          profiled_domain as string,",
            "          profiled_algorithm as string,",
            "          confidence_score as decimal(6,5),",
            "          rows_profiled as long,",
            "          assigned_algorithm as string,",
            "          last_profiled_updated_timestamp as timestamp",
            "     ),",
            "     allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'table',",
            "     store: 'sqlserver',",
            "     schemaName: ($DF_METADATA_SCHEMA),",
            "     tableName: ($DF_METADATA_RULESET_TABLE),",
            "     isolationLevel: 'READ_UNCOMMITTED') ~> Ruleset",
            "source(output(",
            "          dataset as string,",
            "          dataset_type as string,",
            "          adf_type as string",
            "     ),",
            "     allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'table',",
            "     store: 'sqlserver',",
            "     schemaName: ($DF_METADATA_SCHEMA),",
            "     tableName: ($DF_METADATA_ADF_TYPE_MAPPING_TABLE),",
            "     isolationLevel: 'READ_UNCOMMITTED') ~> TypeMapping",
            "Ruleset filter(equalsIgnoreCase(dataset, $DF_DATASET) ",
            "&& equalsIgnoreCase(specified_database, $DF_SOURCE_DATABASE) ",
            "&& equalsIgnoreCase(specified_schema, $DF_SOURCE_SCHEMA) ",
            "&& equalsIgnoreCase(identified_table, $DF_SOURCE_TABLE)",
            "&& !isNull(assigned_algorithm)",
            "&& !equalsIgnoreCase(assigned_algorithm, '')) ~> FilterToSingleTable",
            "UnionAllRules, FilterToDataSourceType join(identified_column_type <=> dataset_type,",
            "     joinType:'inner',",
            "     matchType:'exact',",
            "     ignoreSpaces: false,",
            "     broadcast: 'left')~> RulesetWithTypes",
            "RulesetWithTypes derive(output_row = 1,",
            "          adf_type_conversion = concat(identified_column, ' as ', adf_type),",
            "          column_width_estimate = iif(identified_column_max_length > 0, identified_column_max_length+4, $DF_COLUMN_WIDTH_ESTIMATE)) ~> RulesetWithAlgorithmTypeMapping",
            "RulesetWithAlgorithmTypeMapping aggregate(groupBy(output_row),",
            "     FieldAlgorithmAssignments = regexReplace(reduce(mapAssociation(keyValues(collect(identified_column), collect(assigned_algorithm)), '\"' + #key + '\":\"' + #value + '\"'), '{', #acc + #item + ',', #result + '}'), ',}', '}'),",
            "          ColumnsToMask = regexReplace(reduce(collect(identified_column), '[',  #acc + '\"' + #item + '\",', #result + ']'), ',]', ']'),",
            "          DataFactoryTypeMapping = concat(\"'\", '(timestamp as date, status as string, message as string, trace_id as string, items as (DELPHIX_COMPLIANCE_SERVICE_BATCH_ID as long, ',",
            "    regexReplace(reduce(collect(identified_column + ' as ' + adf_type), '', #acc + #item + ', ', #result + ')'), ', \\\\)', ')'),",
            "    '[])', \"'\"),",
            "          NumberOfBatches = toInteger(ceil(((max(row_count) * (sum(column_width_estimate) + log10(max(row_count)) +1)) / (2000000 * .9)))),",
            "          TrimLengths = regexReplace(reduce(collect(identified_column_max_length), '[',  #acc + toString(#item) + ',', toString(#result) + ']'), ',]', ']')) ~> GenerateMaskParameters",
            "GenerateMaskParameters derive(NumberOfBatches = iif(NumberOfBatches > 0, NumberOfBatches, 1)) ~> ModifyNumberOfBatches",
            "TypeMapping filter(equalsIgnoreCase(dataset, $DF_DATASET)) ~> FilterToDataSourceType",
            "FilterToSingleTable parse(parsed_metadata = metadata ? (date_format as string),",
            "          conditional_formatting = metadata ? (key_column as string,",
            "          conditions as (alias as string, date_format as string)[]),",
            "     format: 'json',",
            "     documentForm: 'singleDocument') ~> ParseMetadata",
            "FilterUnmatchingAlias derive(output_row = 1,",
            "          date_format_string = coalesce(conditional_date_format, parsed_metadata.date_format)) ~> DateFormatString",
            "SplitOnDateFormat@ContainsDateFormat aggregate(groupBy(output_row),",
            "     DateFormatAssignments = regexReplace(reduce(mapAssociation(keyValues(collect(identified_column), collect(date_format_string)), '\"' + #key + '\":\"' + #value + '\"'), '{', #acc + #item + ',', #result + '}'), ',}', '}')) ~> DateFormatHeader",
            "ModifyNumberOfBatches, RemoveUnnecessaryColumns join(GenerateMaskParameters@output_row == RemoveUnnecessaryColumns@output_row,",
            "     joinType:'inner',",
            "     matchType:'exact',",
            "     ignoreSpaces: false,",
            "     broadcast: 'auto')~> AllMaskingParameters",
            "JoinDateHeaders derive(DateFormatAssignments = coalesce(DateFormatAssignments,NoFormatHeader),",
            "          output_row = coalesce(DateFormatHeader@output_row, NoFormatHeader@output_row)) ~> DateFormatHeaderHandlingNulls",
            "DateFormatHeaderHandlingNulls select(mapColumn(",
            "          output_row,",
            "          DateFormatAssignments",
            "     ),",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true) ~> RemoveUnnecessaryColumns",
            "DateFormatString split(not(isNull(date_format_string)),",
            "     disjoint: false) ~> SplitOnDateFormat@(ContainsDateFormat, DoesNotContainDateFormat)",
            "SplitOnDateFormat@DoesNotContainDateFormat aggregate(groupBy(output_row),",
            "     NoFormatHeader = reduce(collect(date_format_string), '{', #acc + #item + ',', #result + '}')) ~> NoFormatHeader",
            "DateFormatHeader, NoFormatHeader join(DateFormatHeader@output_row == NoFormatHeader@output_row,",
            "     joinType:'outer',",
            "     matchType:'exact',",
            "     ignoreSpaces: false,",
            "     broadcast: 'auto')~> JoinDateHeaders",
            "HandleCompositeAlgorithms@KeyColumn parse(conditions_set = assigned_algorithm ? (alias as string, condition as string)[],",
            "     format: 'json',",
            "     documentForm: 'arrayOfDocuments') ~> ParseKeyColumn",
            "FilterToSingleTable split(like(assigned_algorithm, '[%]'),",
            "     like(assigned_algorithm, '{%}'),",
            "     disjoint: false) ~> HandleCompositeAlgorithms@(KeyColumn, ConditionalAlgorithm, StandardAlgorithm)",
            "HandleCompositeAlgorithms@ConditionalAlgorithm parse(conditional_algorithm = assigned_algorithm ? (key_column as string,",
            "          conditions as (alias as string, algorithm as string)[]),",
            "          conditional_formatting = metadata ? (key_column as string,",
            "          conditions as (alias as string, date_format as string)[]),",
            "     format: 'json',",
            "     documentForm: 'singleDocument') ~> ParseAlgorithm",
            "ParseKeyColumn foldDown(unroll(conditions_set),",
            "     mapColumn(",
            "          dataset,",
            "          specified_database,",
            "          specified_schema,",
            "          identified_table,",
            "          identified_column,",
            "          identified_column_type,",
            "          identified_column_max_length,",
            "          row_count,",
            "          alias = conditions_set.alias,",
            "          condition = conditions_set.condition",
            "     ),",
            "     skipDuplicateMapInputs: false,",
            "     skipDuplicateMapOutputs: false) ~> FlattenKeyConditions",
            "JoinConditionalAlgorithms filter(equalsIgnoreCase(FlattenAlgorithmAssignments@alias, $DF_FILTER_KEY) && not(isNull(algorithm)) && algorithm != '') ~> FilterToConditionKey",
            "FlattenKeyConditions, FlattenAlgorithmAssignments join(FlattenKeyConditions@identified_column == key_column",
            "     && FlattenKeyConditions@alias == FlattenAlgorithmAssignments@alias,",
            "     joinType:'inner',",
            "     matchType:'exact',",
            "     ignoreSpaces: false,",
            "     broadcast: 'auto')~> JoinConditionalAlgorithms",
            "HandleCompositeAlgorithms@StandardAlgorithm select(mapColumn(",
            "          dataset,",
            "          specified_database,",
            "          specified_schema,",
            "          identified_table,",
            "          identified_column,",
            "          identified_column_type,",
            "          identified_column_max_length,",
            "          row_count,",
            "          assigned_algorithm",
            "     ),",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true) ~> SimplifySimpleRulesetTable",
            "FilterToConditionKey select(mapColumn(",
            "          dataset = FlattenAlgorithmAssignments@dataset,",
            "          specified_database = FlattenAlgorithmAssignments@specified_database,",
            "          specified_schema = FlattenAlgorithmAssignments@specified_schema,",
            "          identified_table = FlattenAlgorithmAssignments@identified_table,",
            "          identified_column = FlattenAlgorithmAssignments@identified_column,",
            "          identified_column_type = FlattenAlgorithmAssignments@identified_column_type,",
            "          identified_column_max_length = FlattenAlgorithmAssignments@identified_column_max_length,",
            "          row_count = FlattenAlgorithmAssignments@row_count,",
            "          assigned_algorithm = algorithm,",
            "          key_column,",
            "          condition",
            "     ),",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true) ~> SimplifyConditionalRulesetTable",
            "SimplifyConditionalRulesetTable, SimplifySimpleRulesetTable union(byName: true)~> UnionAllRules",
            "ParseAlgorithm foldDown(unroll(conditional_algorithm.conditions),",
            "     mapColumn(",
            "          dataset,",
            "          specified_database,",
            "          specified_schema,",
            "          identified_table,",
            "          identified_column,",
            "          identified_column_type,",
            "          identified_column_max_length,",
            "          row_count,",
            "          key_column = conditional_algorithm.key_column,",
            "          alias = conditional_algorithm.conditions.alias,",
            "          algorithm = conditional_algorithm.conditions.algorithm",
            "     ),",
            "     skipDuplicateMapInputs: false,",
            "     skipDuplicateMapOutputs: false) ~> FlattenAlgorithmAssignments",
            "ParseMetadata foldDown(unroll(conditional_formatting.conditions),",
            "     mapColumn(",
            "          dataset,",
            "          specified_database,",
            "          specified_schema,",
            "          identified_table,",
            "          identified_column,",
            "          identified_column_type,",
            "          identified_column_max_length,",
            "          ordinal_position,",
            "          row_count,",
            "          metadata,",
            "          profiled_domain,",
            "          profiled_algorithm,",
            "          confidence_score,",
            "          rows_profiled,",
            "          assigned_algorithm,",
            "          last_profiled_updated_timestamp,",
            "          parsed_metadata,",
            "          conditional_formatting_key_column = conditional_formatting.key_column,",
            "          alias = conditional_formatting.conditions.alias,",
            "          conditional_date_format = conditional_formatting.conditions.date_format",
            "     ),",
            "     skipDuplicateMapInputs: false,",
            "     skipDuplicateMapOutputs: false) ~> FlattenConditionalFormatting",
            "FlattenConditionalFormatting filter(alias == $DF_FILTER_KEY || isNull(alias)) ~> FilterUnmatchingAlias",
            "AllMaskingParameters sink(validateSchema: false,",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true,",
            "     store: 'cache',",
            "     format: 'inline',",
            "     output: true,",
            "     saveOrder: 1) ~> MaskingParameterOutput"
          ]
        }
      },
      "dependsOn": []
    },
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_AzureSQL_to_AzureSQL_filtered_mask_df')]",
      "type": "Microsoft.DataFactory/factories/dataflows",
      "apiVersion": "2018-06-01",
      "properties": {
        "folder": { "name": "dcsazure_AzureSQL_to_AzureSQL" },
        "type": "MappingDataFlow",
        "typeProperties": {
          "sources": [
            {
              "linkedService": {
                "referenceName": "[parameters('azuresql_mask_source_db')]",
                "type": "LinkedServiceReference"
              },
              "name": "Source",
              "description": "Select source data at DF_SOURCE_SCHEMA.DF_SOURCE_TABLE using an inline dataset"
            }
          ],
          "sinks": [
            {
              "linkedService": {
                "referenceName": "[parameters('azuresql_mask_sink_db')]",
                "type": "LinkedServiceReference"
              },
              "name": "Sink",
              "description": "Sink results of masking to data store by sinking the unrolled results of the masking call to the columns of the same name in the data sink"
            }
          ],
          "transformations": [
            {
              "name": "DCSForAzureAPI",
              "linkedService": {
                "referenceName": "[parameters('ProdDCSForAzureService')]",
                "type": "LinkedServiceReference"
              }
            },
            {
              "name": "AddSortKey",
              "description": "Create column DELPHIX_COMPLIANCE_SERVICE_SORT_ID that consists of SHA of the data across all columns in the table - every row will have this value and it cannot be null"
            },
            {
              "name": "SortBySortKey",
              "description": "Sort the table by the value in DELPHIX_COMPLIANCE_SERVICE_SORT_ID, as we need the table to be in a particular order before we apply a surrogate key"
            },
            {
              "name": "CreateSurrogateKey",
              "description": "Add a DELPHIX_COMPLIANCE_SERVICE_BATCH_ID column that increments by 1 and starts at 1 after applying the sorting"
            },
            {
              "name": "WrapValuesInArray",
              "description": "For each column we wish to mask, convert the value into an array, this is needed to preserve null values as null when using collect, as null values become []"
            },
            {
              "name": "SelectColumnsUnmasked",
              "description": "Select only columns that don't require masking"
            },
            {
              "name": "AggregateColumnsByBatch",
              "description": "For each column we wish to mask, aggregate to a list using collect, grouped by DELPHIX_COMPLIANCE_SERVICE_BATCH_ID with integer division by DF_NUMBER_OF_ROWS_PER_BATCH - so there will be a targeted number of total rows in each aggregation, name the group as DELPHIX_COMPLIANCE_SERVICE_BATCH_GROUP"
            },
            {
              "name": "FlattenValuesOutOfArray",
              "description": "For each column we wish to mask, flatten the value out of the array, in the case where the value was previously [], it becomes null"
            },
            {
              "name": "AssertNoFailures",
              "description": "Confirm that we received a 200 response status from the API request"
            },
            {
              "name": "FlattenAggregateData",
              "description": "Unroll the API response body into named columns"
            },
            {
              "name": "JoinMaskedAndUnmaskedData",
              "description": "Inner join on SelectColumnsUnmasked and TrimMaskedStrings based on matching DELPHIX_COMPLIANCE_SERVICE_BATCH_ID"
            },
            {
              "name": "TrimMaskedStrings",
              "description": "For each column with a string type, trim the string to length based on the value in DF_TRIM_LENGTHS - this is needed as masking a string may produce a longer string that exceeds the column width in the sink"
            },
            {
              "name": "ApplyTableFilter",
              "description": "Filter base table based on supplied filter"
            }
          ],
          "scriptLines": [
            "parameters{",
            "     runId as string (''),",
            "     DF_SOURCE_SCHEMA as string (''),",
            "     DF_SOURCE_TABLE as string (''),",
            "     DF_SINK_SCHEMA as string (''),",
            "     DF_SINK_TABLE as string (''),",
            "     DF_FIELD_ALGORITHM_ASSIGNMENT as string ('{}'),",
            "     DF_COLUMNS_TO_MASK as string[] ([\"\"]),",
            "     DF_BODY_TYPE_MAPPING as string ('(timestamp as date, status as string, message as string, trace_id as string, items as (DELPHIX_COMPLIANCE_SERVICE_BATCH_ID as long)[])'),",
            "     DF_NUMBER_OF_ROWS_PER_BATCH as integer (1000),",
            "     DF_TRIM_LENGTHS as integer[] ([1000]),",
            "     DF_FAIL_ON_NONCONFORMANT_DATA as boolean (true()),",
            "     DF_FIELD_DATE_FORMAT as string ('{}'),",
            "     DF_FILTER_CONDITION as boolean (true())",
            "}",
            "source(allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'table',",
            "     store: 'sqlserver',",
            "     schemaName: ($DF_SOURCE_SCHEMA),",
            "     tableName: ($DF_SOURCE_TABLE),",
            "     isolationLevel: 'READ_UNCOMMITTED',",
            "     partitionBy('roundRobin', 32)) ~> Source",
            "FlattenValuesOutOfArray call(mapColumn(",
            "          each(match(name!='DELPHIX_COMPLIANCE_SERVICE_BATCH_GROUP'))",
            "     ),",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true,",
            "     output(",
            "          headers as [string,string],",
            "          body as (timestamp as date, status as string, message as string, trace_id as string, items as (DELPHIX_COMPLIANCE_SERVICE_BATCH_ID as long, LAST_NAME as string, FIRST_NAME as string, EMAIL as string, PHONE as string, STAFF_ID as integer, ACTIVE as integer, STORE_ID as integer, MANAGER_ID as integer)[]),",
            "          status as string",
            "     ),",
            "     allowSchemaDrift: true,",
            "     format: 'rest',",
            "     store: 'restservice',",
            "     timeout: 30,",
            "     requestInterval: 0,",
            "     headers = ['Run-Id' -> $runId, 'Field-Algorithm-Assignment' -> $DF_FIELD_ALGORITHM_ASSIGNMENT, 'Fail-On-Non-Conformant-Data' -> iif($DF_FAIL_ON_NONCONFORMANT_DATA,'true','false'), 'Field-Date-Format' -> $DF_FIELD_DATE_FORMAT],",
            "     httpMethod: 'POST',",
            "     entity: '/v1/masking/batchMaskByColumn',",
            "     headerColumnName: 'headers',",
            "     bodyColumnName: 'body',",
            "     statusColumnName: 'status',",
            "     addResponseCode: true,",
            "     requestFormat: ['type' -> 'json'],",
            "     responseFormat: ['type' -> 'json', 'documentForm' -> 'documentPerLine'],",
            "     columnTypeMap: ['body'->'$DF_BODY_TYPE_MAPPING']) ~> DCSForAzureAPI",
            "ApplyTableFilter derive(DELPHIX_COMPLIANCE_SERVICE_SORT_ID = sha2(256, columns())) ~> AddSortKey",
            "AddSortKey sort(asc(DELPHIX_COMPLIANCE_SERVICE_SORT_ID, false)) ~> SortBySortKey",
            "SortBySortKey keyGenerate(output(DELPHIX_COMPLIANCE_SERVICE_BATCH_ID as long),",
            "     startAt: 1L,",
            "     stepValue: 1L) ~> CreateSurrogateKey",
            "CreateSurrogateKey derive(each(match(contains($DF_COLUMNS_TO_MASK,#item==name)), $$ = array($$))) ~> WrapValuesInArray",
            "CreateSurrogateKey select(mapColumn(",
            "          each(match(!contains($DF_COLUMNS_TO_MASK,#item==name)))",
            "     ),",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true) ~> SelectColumnsUnmasked",
            "WrapValuesInArray aggregate(groupBy(DELPHIX_COMPLIANCE_SERVICE_BATCH_GROUP = toInteger(ceil(DELPHIX_COMPLIANCE_SERVICE_BATCH_ID/$DF_NUMBER_OF_ROWS_PER_BATCH))),",
            "     each(match(contains($DF_COLUMNS_TO_MASK,#item==name)||(name==\"DELPHIX_COMPLIANCE_SERVICE_BATCH_ID\")), $$ = collect($$))) ~> AggregateColumnsByBatch",
            "AggregateColumnsByBatch derive(each(match(contains($DF_COLUMNS_TO_MASK,#item==name)||(name==\"DELPHIX_COMPLIANCE_SERVICE_BATCH_ID\")), $$ = flatten($$))) ~> FlattenValuesOutOfArray",
            "DCSForAzureAPI assert(expectTrue(toInteger(regexExtract(status, '(\\\\d+)', 1)) == 200, false, 'Failed_request', null, iif(isNull(body.message), status, concatWS(', ', 'timestamp: ' + toString(body.timestamp), 'status: ' + body.status, 'message: ' + body.message, 'trace_id: ' + body.trace_id))),",
            "     abort: true) ~> AssertNoFailures",
            "AssertNoFailures foldDown(unroll(body.items),",
            "     mapColumn(",
            "          every(body.items,match(true()))",
            "     ),",
            "     skipDuplicateMapInputs: false,",
            "     skipDuplicateMapOutputs: false) ~> FlattenAggregateData",
            "SelectColumnsUnmasked, TrimMaskedStrings join(SelectColumnsUnmasked@DELPHIX_COMPLIANCE_SERVICE_BATCH_ID == FlattenAggregateData@DELPHIX_COMPLIANCE_SERVICE_BATCH_ID,",
            "     joinType:'inner',",
            "     matchType:'exact',",
            "     ignoreSpaces: false,",
            "     broadcast: 'off')~> JoinMaskedAndUnmaskedData",
            "FlattenAggregateData derive(each(match(type=='string'), $$ = iif(",
            "    greater($DF_TRIM_LENGTHS[toInteger($# - 1)], 0), ",
            "    substring($$, 1, $DF_TRIM_LENGTHS[toInteger($# - 1)]), ",
            "    $$",
            "))) ~> TrimMaskedStrings",
            "Source filter($DF_FILTER_CONDITION) ~> ApplyTableFilter",
            "JoinMaskedAndUnmaskedData sink(allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'table',",
            "     store: 'sqlserver',",
            "     schemaName: ($DF_SINK_SCHEMA),",
            "     tableName: ($DF_SINK_TABLE),",
            "     preSQLs:[(concat(\"IF EXISTS (SELECT 1 FROM sys.columns WHERE object_id = OBJECT_ID('\", $DF_SINK_SCHEMA, \"' + '.' + '\", $DF_SINK_TABLE, \"') AND is_identity = 1) BEGIN \", 'SET IDENTITY_INSERT', ' ', $DF_SINK_SCHEMA, '.', $DF_SINK_TABLE, ' ', 'ON; END'))],",
            "     insertable: true,",
            "     updateable: false,",
            "     deletable: false,",
            "     upsertable: false,",
            "     postSQLs:[(concat(\"IF EXISTS (SELECT 1 FROM sys.columns WHERE object_id = OBJECT_ID('\", $DF_SINK_SCHEMA, \"' + '.' + '\", $DF_SINK_TABLE, \"') AND is_identity = 1) BEGIN \", 'SET IDENTITY_INSERT', ' ', $DF_SINK_SCHEMA, '.', $DF_SINK_TABLE, ' ', 'OFF; END'))],",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true,",
            "     errorHandlingOption: 'stopOnFirstError',",
            "     mapColumn(",
            "          each(match(name!=\"DELPHIX_COMPLIANCE_SERVICE_BATCH_ID\"&&name!=\"DELPHIX_COMPLIANCE_SERVICE_SORT_ID\"))",
            "     ),",
            "     preCommands: [],",
            "     postCommands: []) ~> Sink"
          ]
        }
      },
      "dependsOn": []
    },
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_AzureSQL_to_AzureSQL_mask_source_ds')]",
      "type": "Microsoft.DataFactory/factories/datasets",
      "apiVersion": "2018-06-01",
      "properties": {
        "linkedServiceName": {
          "referenceName": "[parameters('azuresql_mask_source_db')]",
          "type": "LinkedServiceReference"
        },
        "parameters": {
          "DS_SOURCE_SCHEMA": { "type": "string" },
          "DS_SOURCE_TABLE": { "type": "string" }
        },
        "folder": { "name": "dcsazure_AzureSQL_to_AzureSQL" },
        "annotations": [],
        "type": "AzureSqlTable",
        "schema": [],
        "typeProperties": {
          "schema": {
            "value": "@dataset().DS_SOURCE_SCHEMA",
            "type": "Expression"
          },
          "table": {
            "value": "@dataset().DS_SOURCE_TABLE",
            "type": "Expression"
          }
        }
      },
      "dependsOn": []
    },
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_AzureSQL_to_AzureSQL_copy_df')]",
      "type": "Microsoft.DataFactory/factories/dataflows",
      "apiVersion": "2018-06-01",
      "properties": {
        "folder": { "name": "dcsazure_AzureSQL_to_AzureSQL" },
        "type": "MappingDataFlow",
        "typeProperties": {
          "sources": [
            {
              "linkedService": {
                "referenceName": "[parameters('azuresql_mask_source_db')]",
                "type": "LinkedServiceReference"
              },
              "name": "SourceData",
              "description": "Select source data at DF_SOURCE_SCHEMA.DF_SOURCE_TABLE using an inline dataset"
            }
          ],
          "sinks": [
            {
              "linkedService": {
                "referenceName": "[parameters('azuresql_mask_sink_db')]",
                "type": "LinkedServiceReference"
              },
              "name": "SinkData",
              "description": "Select sink data at DF_SINK_SCHEMA.DF_SINK_TABLE using an inline dataset"
            }
          ],
          "transformations": [],
          "scriptLines": [
            "parameters{",
            "     runId as string (''),",
            "     DF_SOURCE_SCHEMA as string (''),",
            "     DF_SINK_SCHEMA as string (''),",
            "     DF_SOURCE_TABLE as string (''),",
            "     DF_SINK_TABLE as string ('')",
            "}",
            "source(allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'table',",
            "     store: 'sqlserver',",
            "     schemaName: ($DF_SOURCE_SCHEMA),",
            "     tableName: ($DF_SOURCE_TABLE),",
            "     isolationLevel: 'READ_UNCOMMITTED') ~> SourceData",
            "SourceData sink(allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'table',",
            "     store: 'sqlserver',",
            "     schemaName: ($DF_SINK_SCHEMA),",
            "     tableName: ($DF_SINK_TABLE),",
            "     preSQLs:[(concat(\"IF EXISTS (SELECT 1 FROM sys.columns WHERE object_id = OBJECT_ID('\", $DF_SINK_SCHEMA, \"' + '.' + '\", $DF_SINK_TABLE, \"') AND is_identity = 1) BEGIN \", 'SET IDENTITY_INSERT', ' ', $DF_SINK_SCHEMA, '.', $DF_SINK_TABLE, ' ', 'ON; END'))],",
            "     insertable: true,",
            "     updateable: false,",
            "     deletable: false,",
            "     upsertable: false,",
            "     postSQLs:[(concat(\"IF EXISTS (SELECT 1 FROM sys.columns WHERE object_id = OBJECT_ID('\", $DF_SINK_SCHEMA, \"' + '.' + '\", $DF_SINK_TABLE, \"') AND is_identity = 1) BEGIN \", 'SET IDENTITY_INSERT', ' ', $DF_SINK_SCHEMA, '.', $DF_SINK_TABLE, ' ', 'OFF; END'))],",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true,",
            "     errorHandlingOption: 'stopOnFirstError',",
            "     preCommands: [],",
            "     postCommands: []) ~> SinkData"
          ]
        }
      },
      "dependsOn": []
    }
  ]
}
