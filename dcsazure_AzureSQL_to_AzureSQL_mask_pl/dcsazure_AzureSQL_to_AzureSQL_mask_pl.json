{
  "$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
  "contentVersion": "1.0.0.0",
  "parameters": {
    "factoryName": {
      "type": "string",
      "metadata": "Data Factory name"
    },
    "azuresql_mask_metadata_store_db": {
      "type": "string"
    },
    "azuresql_mask_sink_db": {
      "type": "string"
    },
    "azuresql_mask_source_db": {
      "type": "string"
    },
    "ProdDCSForAzureService": {
      "type": "string"
    }
  },
  "variables": {
    "factoryId": "[concat('Microsoft.DataFactory/factories/', parameters('factoryName'))]"
  },
  "resources": [
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_AzureSQL_to_AzureSQL_mask_pl')]",
      "type": "Microsoft.DataFactory/factories/pipelines",
      "apiVersion": "2018-06-01",
      "properties": {
        "activities": [
          {
            "name": "Select Tables That Require Masking",
            "description": "Select tables with a data mapping and assigned algorithms, as well as filters that may be needed for conditional masking.",
            "type": "Lookup",
            "dependsOn": [
              {
                "activity": "For Each Table To Truncate",
                "dependencyConditions": [
                  "Succeeded"
                ]
              }
            ],
            "policy": {
              "timeout": "0.12:00:00",
              "retry": 0,
              "retryIntervalInSeconds": 30,
              "secureOutput": false,
              "secureInput": false
            },
            "userProperties": [],
            "typeProperties": {
              "source": {
                "type": "AzureSqlSource",
                "sqlReaderQuery": {
                  "value": "WITH\ntables_requiring_filters AS\n(\n\tSELECT DISTINCT\n\t\tdataset, specified_database, specified_schema, identified_table\n\tFROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_RULESET_TABLE')}\n\tWHERE ISJSON(assigned_algorithm) = 1\n\tAND dataset = '@{variables('DATASET')}'\n\tAND specified_database = '@{pipeline().parameters.P_SOURCE_DATABASE}'\n\tAND specified_schema = '@{pipeline().parameters.P_SOURCE_SCHEMA}'\n),\ntables_not_requiring_filters AS\n(\n\tSELECT DISTINCT\n\t\tdataset, specified_database, specified_schema, identified_table\n\tFROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_RULESET_TABLE')}\n\tWHERE assigned_algorithm IS NOT NULL\n\tAND assigned_algorithm != ''\n\tAND dataset = '@{variables('DATASET')}'\n\tAND specified_database = '@{pipeline().parameters.P_SOURCE_DATABASE}'\n\tAND specified_schema = '@{pipeline().parameters.P_SOURCE_SCHEMA}'\n\tEXCEPT\n\tSELECT dataset, specified_database, specified_schema, identified_table\n\tFROM tables_requiring_filters\n\tWHERE dataset = '@{variables('DATASET')}'\n\tAND specified_database = '@{pipeline().parameters.P_SOURCE_DATABASE}'\n\tAND specified_schema = '@{pipeline().parameters.P_SOURCE_SCHEMA}'\n),\nall_filters AS\n(\n\tSELECT DISTINCT\n\t\tJSON_VALUE(kc.value, '$.alias') as filter_alias,\n\t\treplace(JSON_VALUE(kc.value, '$.condition'), '@{variables('CONDITIONAL_MASKING_RESERVED_CHARACTER')}', concat('byName(''', d.identified_column, ''') ')) as filter_value,\n\t\td.identified_table\n\tFROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_RULESET_TABLE')} d \n\t\tCROSS APPLY OPENJSON(d.assigned_algorithm) kc\n\tWHERE\n\t\tISJSON(assigned_algorithm,ARRAY) = 1\n\t\tAND\n\t\td.identified_table in (\n\t\t\tSELECT identified_table FROM tables_requiring_filters\n\t\t)\n\t\tAND JSON_VALUE(kc.value,'$.alias') != 'default'\n),\ndefault_filters AS\n(\n\tSELECT DISTINCT\n\t\t'default' as filter_alias,\n\t\tSTRING_AGG(concat('not(', replace(JSON_VALUE(kc.value, '$.condition'), '@{variables('CONDITIONAL_MASKING_RESERVED_CHARACTER')}', concat('byName(''', d.identified_column, ''')')),')'), ' && ') as filter_value,\n\t\td.identified_table\n\tFROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_RULESET_TABLE')} d \n\t\tCROSS APPLY OPENJSON(d.assigned_algorithm) kc\n\tWHERE\n\t\tISJSON(assigned_algorithm,ARRAY) = 1\n\t\tAND\n\t\td.identified_table in (\n\t\t\tSELECT identified_table FROM tables_requiring_filters\n\t\t)\n\t\tAND JSON_VALUE(kc.value,'$.alias') != 'default'\n\tGROUP BY d.identified_table\n),\nsources_and_filters AS (\n\tSELECT\n\t\tt.dataset,\n\t\tt.specified_database,\n\t\tt.specified_schema,\n\t\tt.identified_table,\n\t\tf.filter_alias,\n\t\tf.filter_value\n\tFROM tables_requiring_filters t JOIN default_filters f\n\tON t.identified_table = f.identified_table\n\tUNION\n\tSELECT\n\t\tt.dataset,\n\t\tt.specified_database,\n\t\tt.specified_schema,\n\t\tt.identified_table,\n\t\tf.filter_alias,\n\t\tf.filter_value\n\tFROM tables_requiring_filters t JOIN all_filters f\n\tON t.identified_table = f.identified_table\n\tUNION\n\tSELECT\n\t\tdataset,\n\t\tspecified_database,\n\t\tspecified_schema,\n\t\tidentified_table,\n\t\t'',\n\t\t''\n\tFROM tables_not_requiring_filters\n)\nSELECT DISTINCT\n\tdm.source_dataset,\n\tdm.source_database,\n\tdm.source_schema,\n\tdm.source_table,\n\tdm.sink_dataset,\n\tdm.sink_database,\n\tdm.sink_schema,\n\tdm.sink_table,\n\trs.filter_alias,\n\trs.filter_value\nFROM\n\tsources_and_filters rs\n\tJOIN @{variables('METADATA_SCHEMA')}.@{variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')} dm\n\tON (\n\t\trs.dataset = dm.source_dataset AND\n\t\trs.specified_database = dm.source_database AND\n\t\trs.specified_schema = dm.source_schema AND\n\t\trs.identified_table = dm.source_table\n\t)\nWHERE\n\tdm.sink_database = '@{pipeline().parameters.P_SINK_DATABASE}' AND\n\tdm.sink_schema = '@{pipeline().parameters.P_SINK_SCHEMA}'\n\tAND (dm.mapping_complete IS NULL OR dm.mapping_complete = 0)\n\tAND (ISJSON(dm.masked_status) = 0  OR dm.masked_status IS NULL)\nUNION\nSELECT DISTINCT\n\tdm.source_dataset,\n\tdm.source_database,\n\tdm.source_schema,\n\tdm.source_table,\n\tdm.sink_dataset,\n\tdm.sink_database,\n\tdm.sink_schema,\n\tdm.sink_table,\n\trs.filter_alias,\n\trs.filter_value\nFROM\n\tsources_and_filters rs\n\tJOIN @{variables('METADATA_SCHEMA')}.@{variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')} dm\n\tCROSS APPLY OPENJSON(dm.masked_status) kc\n\tON (\n\t\trs.dataset = dm.source_dataset AND\n\t\trs.specified_database = dm.source_database AND\n\t\trs.specified_schema = dm.source_schema AND\n\t\trs.identified_table = dm.source_table\n\t)\nWHERE\n\tdm.sink_database = '@{pipeline().parameters.P_SINK_DATABASE}' AND\n\tdm.sink_schema = '@{pipeline().parameters.P_SINK_SCHEMA}'\n\tAND (dm.mapping_complete IS NULL OR dm.mapping_complete = 0)\n\tAND ISJSON(dm.masked_status) = 1\n\tAND kc.[key] = rs.filter_alias\n\tAND kc.[value] = 'false'\n\tAND (\n\t\t(filter_alias = 'default' AND  \n\t\t\tidentified_table IN (\n\t\t\t\tSELECT DISTINCT\n\t\t\t\t\tidentified_table\n\t\t\tFROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_RULESET_TABLE')} d\n\t\t\t\tCROSS APPLY OPENJSON(d.assigned_algorithm) kc\n\t\t\tWHERE\n\t\t\t\tISJSON(assigned_algorithm,ARRAY) = 1\n\t\t\t\tAND JSON_VALUE(kc.value, '$.alias') = 'default'\n\t\t\t)\n\t\t)\n\t\tOR\n\t\t(filter_alias != 'default')\n\t)\n",
                  "type": "Expression"
                },
                "queryTimeout": "02:00:00",
                "partitionOption": "None"
              },
              "dataset": {
                "referenceName": "dcsazure_AzureSQL_to_AzureSQL_mask_metadata_ds",
                "type": "DatasetReference",
                "parameters": {
                  "DS_METADATA_SCHEMA": {
                    "value": "@variables('METADATA_SCHEMA')",
                    "type": "Expression"
                  },
                  "DS_METADATA_TABLE": {
                    "value": "@variables('METADATA_RULESET_TABLE')",
                    "type": "Expression"
                  }
                }
              },
              "firstRowOnly": false
            }
          },
          {
            "name": "For Each Table To Mask",
            "type": "ForEach",
            "dependsOn": [
              {
                "activity": "Configure Masked Status",
                "dependencyConditions": [
                  "Succeeded"
                ]
              }
            ],
            "userProperties": [],
            "typeProperties": {
              "items": {
                "value": "@activity('Select Tables That Require Masking').output.value",
                "type": "Expression"
              },
              "isSequential": false,
              "activities": [
                {
                  "name": "Check For Conditional Masking",
                  "description": "Identify whether the table needs to be masked with conditional masking",
                  "type": "IfCondition",
                  "dependsOn": [
                    {
                      "activity": "Lookup Masking Parameters",
                      "dependencyConditions": [
                        "Succeeded"
                      ]
                    }
                  ],
                  "userProperties": [],
                  "typeProperties": {
                    "expression": {
                      "value": "@greater(length(item().filter_alias),0)",
                      "type": "Expression"
                    },
                    "ifFalseActivities": [
                      {
                        "name": "Perform Masking Per Table No Filter",
                        "description": "Perform masking for the entire table",
                        "type": "ExecuteDataFlow",
                        "dependsOn": [],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "dataflow": {
                            "referenceName": "dcsazure_AzureSQL_to_AzureSQL_unfiltered_mask_df",
                            "type": "DataFlowReference",
                            "parameters": {
                              "runId": {
                                "value": "'@{pipeline().RunId}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_SCHEMA": {
                                "value": "'@{item().source_schema}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_TABLE": {
                                "value": "'@{item().source_table}'",
                                "type": "Expression"
                              },
                              "DF_SINK_SCHEMA": {
                                "value": "'@{item().sink_schema}'",
                                "type": "Expression"
                              },
                              "DF_SINK_TABLE": {
                                "value": "'@{item().sink_table}'",
                                "type": "Expression"
                              },
                              "DF_FIELD_ALGORITHM_ASSIGNMENT": {
                                "value": "'@{activity('Lookup Masking Parameters').output.firstRow.FieldAlgorithmAssignments}'",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_MASK": {
                                "value": "@activity('Lookup Masking Parameters').output.firstRow.ColumnsToMask",
                                "type": "Expression"
                              },
                              "DF_BODY_TYPE_MAPPING": {
                                "value": "@activity('Lookup Masking Parameters').output.firstRow.DataFactoryTypeMapping",
                                "type": "Expression"
                              },
                              "DF_NUMBER_OF_ROWS_PER_BATCH": {
                                "value": "@variables('TARGET_BATCH_SIZE')",
                                "type": "Expression"
                              },
                              "DF_TRIM_LENGTHS": {
                                "value": "@activity('Lookup Masking Parameters').output.firstRow.TrimLengths",
                                "type": "Expression"
                              },
                              "DF_FAIL_ON_NONCONFORMANT_DATA": {
                                "value": "@pipeline().parameters.P_FAIL_ON_NONCONFORMANT_DATA",
                                "type": "Expression"
                              },
                              "DF_FIELD_DATE_FORMAT": {
                                "value": "'@{activity('Lookup Masking Parameters').output.firstRow.DateFormatAssignments}'",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_AS_STRINGS": {
                                "value": "@activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastAsStrings",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_BACK_TO_BINARY": {
                                "value": "@activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToBinary",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_BACK_TO_BOOLEAN": {
                                "value": "@activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToBoolean",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_BACK_TO_DATE": {
                                "value": "@activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToDate",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_BACK_TO_DOUBLE": {
                                "value": "@activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToDouble",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_BACK_TO_FLOAT": {
                                "value": "@activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToFloat",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_BACK_TO_INTEGER": {
                                "value": "@activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToInteger",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_BACK_TO_LONG": {
                                "value": "@activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToLong",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_BACK_TO_TIMESTAMP": {
                                "value": "@activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToTimestamp",
                                "type": "Expression"
                              },
                              "DF_NUMBER_OF_BATCHES": {
                                "value": "@activity('Lookup Masking Parameters').output.firstRow.NumberOfBatches",
                                "type": "Expression"
                              }
                            },
                            "datasetParameters": {
                              "Source": {},
                              "Sink": {}
                            },
                            "linkedServiceParameters": {
                              "Source": {
                                "linkedService": {
                                  "LS_DATABASE": {
                                    "value": "@pipeline().parameters.P_SOURCE_DATABASE",
                                    "type": "Expression"
                                  }
                                }
                              },
                              "Sink": {
                                "linkedService": {
                                  "LS_DATABASE": {
                                    "value": "@pipeline().parameters.P_SINK_DATABASE",
                                    "type": "Expression"
                                  }
                                }
                              }
                            }
                          },
                          "staging": {},
                          "compute": {
                            "coreCount": 8,
                            "computeType": "General"
                          },
                          "traceLevel": "None",
                          "cacheSinks": {
                            "firstRowOnly": true
                          }
                        }
                      },
                      {
                        "name": "Update Masked State No Filter",
                        "type": "SqlServerStoredProcedure",
                        "dependsOn": [
                          {
                            "activity": "Perform Masking Per Table No Filter",
                            "dependencyConditions": [
                              "Succeeded"
                            ]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "storedProcedureName": {
                            "value": "@{variables('METADATA_SCHEMA')}.@{variables('METADATA_EVENT_PROCEDURE_NAME')}",
                            "type": "Expression"
                          },
                          "storedProcedureParameters": {
                            "activity_run_id": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table No Filter').ActivityRunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "error_message": {
                              "value": null,
                              "type": "String"
                            },
                            "execution_end_time": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table No Filter').ExecutionEndTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "execution_start_time": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table No Filter').ExecutionStartTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "filter_alias": {
                              "value": null,
                              "type": "String"
                            },
                            "filter_condition": {
                              "value": null,
                              "type": "String"
                            },
                            "input_parameters": {
                              "value": {
                                "value": "{\n    \"DF_FIELD_ALGORITHM_ASSIGNMENT\": @{activity('Lookup Masking Parameters').output.firstRow.FieldAlgorithmAssignments},\n    \"DF_COLUMNS_TO_MASK\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToMask},\n    \"DF_BODY_TYPE_MAPPING\": @{activity('Lookup Masking Parameters').output.firstRow.DataFactoryTypeMapping},\n    \"DF_FAIL_ON_NONCONFORMANT_DATA\": @{pipeline().parameters.P_FAIL_ON_NONCONFORMANT_DATA},\n    \"DF_TRIM_LENGTHS\": @{activity('Lookup Masking Parameters').output.firstRow.TrimLengths},\n    \"DF_FIELD_DATE_FORMAT\": @{activity('Lookup Masking Parameters').output.firstRow.DateFormatAssignments},\n    \"DF_COLUMNS_TO_CAST_AS_STRINGS\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastAsStrings},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_BINARY\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToBinary},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_BOOLEAN\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToBoolean},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_DATE\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToDate},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_DOUBLE\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToDouble},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_FLOAT\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToFloat},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_INTEGER\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToInteger},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_LONG\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToLong},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_TIMESTAMP\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToTimestamp},\n    \"DF_NUMBER_OF_BATCHES\": @{activity('Lookup Masking Parameters').output.firstRow.NumberOfBatches}\n}",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "is_masking_activity": {
                              "value": "true",
                              "type": "Boolean"
                            },
                            "pipeline_name": {
                              "value": {
                                "value": "@pipeline().Pipeline",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "pipeline_run_id": {
                              "value": {
                                "value": "@pipeline().RunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "pipeline_success": {
                              "value": "true",
                              "type": "Boolean"
                            },
                            "sink_database": {
                              "value": {
                                "value": "@pipeline().parameters.P_SINK_DATABASE",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "sink_schema": {
                              "value": {
                                "value": "@pipeline().parameters.P_SINK_SCHEMA",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_table": {
                              "value": {
                                "value": "@item().sink_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_database": {
                              "value": {
                                "value": "@pipeline().parameters.P_SOURCE_DATABASE",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "source_schema": {
                              "value": {
                                "value": "@pipeline().parameters.P_SOURCE_SCHEMA",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_table": {
                              "value": {
                                "value": "@item().source_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            }
                          }
                        },
                        "linkedServiceName": {
                          "referenceName": "[parameters('azuresql_mask_metadata_store_db')]",
                          "type": "LinkedServiceReference"
                        }
                      },
                      {
                        "name": "Update Masked State No Filter Failed",
                        "type": "SqlServerStoredProcedure",
                        "dependsOn": [
                          {
                            "activity": "Perform Masking Per Table No Filter",
                            "dependencyConditions": [
                              "Failed"
                            ]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "storedProcedureName": {
                            "value": "@{variables('METADATA_SCHEMA')}.@{variables('METADATA_EVENT_PROCEDURE_NAME')}",
                            "type": "Expression"
                          },
                          "storedProcedureParameters": {
                            "activity_run_id": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table No Filter').ActivityRunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "error_message": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table No Filter').Error.message",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "execution_end_time": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table No Filter').ExecutionEndTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "execution_start_time": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table No Filter').ExecutionStartTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "filter_alias": {
                              "value": null,
                              "type": "String"
                            },
                            "filter_condition": {
                              "value": null,
                              "type": "String"
                            },
                            "input_parameters": {
                              "value": {
                                "value": "{\n    \"DF_FIELD_ALGORITHM_ASSIGNMENT\": @{activity('Lookup Masking Parameters').output.firstRow.FieldAlgorithmAssignments},\n    \"DF_COLUMNS_TO_MASK\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToMask},\n    \"DF_BODY_TYPE_MAPPING\": @{activity('Lookup Masking Parameters').output.firstRow.DataFactoryTypeMapping},\n    \"DF_FAIL_ON_NONCONFORMANT_DATA\": @{pipeline().parameters.P_FAIL_ON_NONCONFORMANT_DATA},\n    \"DF_TRIM_LENGTHS\": @{activity('Lookup Masking Parameters').output.firstRow.TrimLengths},\n    \"DF_FIELD_DATE_FORMAT\": @{activity('Lookup Masking Parameters').output.firstRow.DateFormatAssignments},\n    \"DF_COLUMNS_TO_CAST_AS_STRINGS\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastAsStrings},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_BINARY\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToBinary},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_BOOLEAN\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToBoolean},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_DATE\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToDate},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_DOUBLE\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToDouble},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_FLOAT\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToFloat},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_INTEGER\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToInteger},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_LONG\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToLong},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_TIMESTAMP\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToTimestamp},\n    \"DF_NUMBER_OF_BATCHES\": @{activity('Lookup Masking Parameters').output.firstRow.NumberOfBatches}\n}",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "is_masking_activity": {
                              "value": "true",
                              "type": "Boolean"
                            },
                            "pipeline_name": {
                              "value": {
                                "value": "@pipeline().Pipeline",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "pipeline_run_id": {
                              "value": {
                                "value": "@pipeline().RunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "pipeline_success": {
                              "value": "false",
                              "type": "Boolean"
                            },
                            "sink_database": {
                              "value": {
                                "value": "@pipeline().parameters.P_SINK_DATABASE",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "sink_schema": {
                              "value": {
                                "value": "@pipeline().parameters.P_SINK_SCHEMA",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_table": {
                              "value": {
                                "value": "@item().sink_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_database": {
                              "value": {
                                "value": "@pipeline().parameters.P_SOURCE_DATABASE",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "source_schema": {
                              "value": {
                                "value": "@pipeline().parameters.P_SOURCE_SCHEMA",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_table": {
                              "value": {
                                "value": "@item().source_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            }
                          }
                        },
                        "linkedServiceName": {
                          "referenceName": "[parameters('azuresql_mask_metadata_store_db')]",
                          "type": "LinkedServiceReference"
                        }
                      },
                      {
                        "name": "Fail After Updating Masked State No Filter",
                        "type": "Fail",
                        "dependsOn": [
                          {
                            "activity": "Update Masked State No Filter Failed",
                            "dependencyConditions": [
                              "Succeeded"
                            ]
                          }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                          "message": {
                            "value": "Failed to mask @{item().source_table}",
                            "type": "Expression"
                          },
                          "errorCode": "500"
                        }
                      }
                    ],
                    "ifTrueActivities": [
                      {
                        "name": "Perform Masking Per Table With Filter",
                        "description": "Perform masking for the part of this table that satisfies the specified filter",
                        "type": "ExecuteDataFlow",
                        "dependsOn": [],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "dataflow": {
                            "referenceName": "dcsazure_AzureSQL_to_AzureSQL_filtered_mask_df",
                            "type": "DataFlowReference",
                            "parameters": {
                              "runId": {
                                "value": "'@{pipeline().RunId}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_SCHEMA": {
                                "value": "'@{item().source_schema}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_TABLE": {
                                "value": "'@{item().source_table}'",
                                "type": "Expression"
                              },
                              "DF_SINK_SCHEMA": {
                                "value": "'@{item().sink_schema}'",
                                "type": "Expression"
                              },
                              "DF_SINK_TABLE": {
                                "value": "'@{item().sink_table}'",
                                "type": "Expression"
                              },
                              "DF_FIELD_ALGORITHM_ASSIGNMENT": {
                                "value": "'@{activity('Lookup Masking Parameters').output.firstRow.FieldAlgorithmAssignments\n\n\n}'",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_MASK": {
                                "value": "@activity('Lookup Masking Parameters').output.firstRow.ColumnsToMask",
                                "type": "Expression"
                              },
                              "DF_BODY_TYPE_MAPPING": {
                                "value": "@activity('Lookup Masking Parameters').output.firstRow.DataFactoryTypeMapping",
                                "type": "Expression"
                              },
                              "DF_NUMBER_OF_ROWS_PER_BATCH": {
                                "value": "@variables('TARGET_BATCH_SIZE')",
                                "type": "Expression"
                              },
                              "DF_TRIM_LENGTHS": {
                                "value": "@activity('Lookup Masking Parameters').output.firstRow.TrimLengths",
                                "type": "Expression"
                              },
                              "DF_FAIL_ON_NONCONFORMANT_DATA": {
                                "value": "@pipeline().parameters.P_FAIL_ON_NONCONFORMANT_DATA",
                                "type": "Expression"
                              },
                              "DF_FIELD_DATE_FORMAT": {
                                "value": "'@{activity('Lookup Masking Parameters').output.firstRow.DateFormatAssignments}'",
                                "type": "Expression"
                              },
                              "DF_FILTER_CONDITION": {
                                "value": "@item().filter_value",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_AS_STRINGS": {
                                "value": "@activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastAsStrings",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_BACK_TO_BINARY": {
                                "value": "@activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToBinary",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_BACK_TO_BOOLEAN": {
                                "value": "@activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToBoolean",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_BACK_TO_DATE": {
                                "value": "@activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToDate",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_BACK_TO_DOUBLE": {
                                "value": "@activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToDouble",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_BACK_TO_FLOAT": {
                                "value": "@activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToFloat",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_BACK_TO_INTEGER": {
                                "value": "@activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToInteger",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_BACK_TO_LONG": {
                                "value": "@activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToLong",
                                "type": "Expression"
                              },
                              "DF_COLUMNS_TO_CAST_BACK_TO_TIMESTAMP": {
                                "value": "@activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToTimestamp",
                                "type": "Expression"
                              }
                            },
                            "datasetParameters": {
                              "Source": {},
                              "Sink": {}
                            },
                            "linkedServiceParameters": {
                              "Source": {
                                "linkedService": {
                                  "LS_DATABASE": {
                                    "value": "@pipeline().parameters.P_SOURCE_DATABASE",
                                    "type": "Expression"
                                  }
                                }
                              },
                              "Sink": {
                                "linkedService": {
                                  "LS_DATABASE": {
                                    "value": "@pipeline().parameters.P_SINK_DATABASE",
                                    "type": "Expression"
                                  }
                                }
                              }
                            }
                          },
                          "staging": {},
                          "compute": {
                            "coreCount": 8,
                            "computeType": "General"
                          },
                          "traceLevel": "Fine"
                        }
                      },
                      {
                        "name": "Update Masked State With Filter",
                        "type": "SqlServerStoredProcedure",
                        "dependsOn": [
                          {
                            "activity": "Perform Masking Per Table With Filter",
                            "dependencyConditions": [
                              "Succeeded"
                            ]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "storedProcedureName": {
                            "value": "@{variables('METADATA_SCHEMA')}.@{variables('METADATA_EVENT_PROCEDURE_NAME')}",
                            "type": "Expression"
                          },
                          "storedProcedureParameters": {
                            "activity_run_id": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table With Filter').ActivityRunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "error_message": {
                              "value": null,
                              "type": "String"
                            },
                            "execution_end_time": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table With Filter').ExecutionEndTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "execution_start_time": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table With Filter').ExecutionStartTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "filter_alias": {
                              "value": {
                                "value": "@item().filter_alias",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "filter_condition": {
                              "value": {
                                "value": "@item().filter_value",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "input_parameters": {
                              "value": {
                                "value": "{\n    \"DF_FIELD_ALGORITHM_ASSIGNMENT\": @{activity('Lookup Masking Parameters').output.firstRow.FieldAlgorithmAssignments},\n    \"DF_COLUMNS_TO_MASK\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToMask},\n    \"DF_BODY_TYPE_MAPPING\": @{activity('Lookup Masking Parameters').output.firstRow.DataFactoryTypeMapping},\n    \"DF_FAIL_ON_NONCONFORMANT_DATA\": @{pipeline().parameters.P_FAIL_ON_NONCONFORMANT_DATA},\n    \"DF_TRIM_LENGTHS\": @{activity('Lookup Masking Parameters').output.firstRow.TrimLengths},\n    \"DF_FIELD_DATE_FORMAT\": @{activity('Lookup Masking Parameters').output.firstRow.DateFormatAssignments},\n    \"DF_COLUMNS_TO_CAST_AS_STRINGS\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastAsStrings},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_BINARY\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToBinary},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_BOOLEAN\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToBoolean},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_DATE\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToDate},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_DOUBLE\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToDouble},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_FLOAT\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToFloat},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_INTEGER\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToInteger},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_LONG\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToLong},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_TIMESTAMP\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToTimestamp}\n}",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "is_masking_activity": {
                              "value": "true",
                              "type": "Boolean"
                            },
                            "pipeline_name": {
                              "value": {
                                "value": "@pipeline().Pipeline",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "pipeline_run_id": {
                              "value": {
                                "value": "@pipeline().RunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "pipeline_success": {
                              "value": "true",
                              "type": "Boolean"
                            },
                            "sink_database": {
                              "value": {
                                "value": "@pipeline().parameters.P_SINK_DATABASE",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "sink_schema": {
                              "value": {
                                "value": "@pipeline().parameters.P_SINK_SCHEMA",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_table": {
                              "value": {
                                "value": "@item().sink_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_database": {
                              "value": {
                                "value": "@pipeline().parameters.P_SOURCE_DATABASE",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "source_schema": {
                              "value": {
                                "value": "@pipeline().parameters.P_SOURCE_SCHEMA",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_table": {
                              "value": {
                                "value": "@item().source_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            }
                          }
                        },
                        "linkedServiceName": {
                          "referenceName": "[parameters('azuresql_mask_metadata_store_db')]",
                          "type": "LinkedServiceReference"
                        }
                      },
                      {
                        "name": "Update Masked State With Filter Failed",
                        "type": "SqlServerStoredProcedure",
                        "dependsOn": [
                          {
                            "activity": "Perform Masking Per Table With Filter",
                            "dependencyConditions": [
                              "Failed"
                            ]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "storedProcedureName": {
                            "value": "@{variables('METADATA_SCHEMA')}.@{variables('METADATA_EVENT_PROCEDURE_NAME')}",
                            "type": "Expression"
                          },
                          "storedProcedureParameters": {
                            "activity_run_id": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table With Filter').ActivityRunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "error_message": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table With Filter').Error.message",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "execution_end_time": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table With Filter').ExecutionEndTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "execution_start_time": {
                              "value": {
                                "value": "@activity('Perform Masking Per Table With Filter').ExecutionStartTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "filter_alias": {
                              "value": {
                                "value": "@item().filter_alias",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "filter_condition": {
                              "value": {
                                "value": "@item().filter_value",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "input_parameters": {
                              "value": {
                                "value": "{\n    \"DF_FIELD_ALGORITHM_ASSIGNMENT\": @{activity('Lookup Masking Parameters').output.firstRow.FieldAlgorithmAssignments},\n    \"DF_COLUMNS_TO_MASK\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToMask},\n    \"DF_BODY_TYPE_MAPPING\": @{activity('Lookup Masking Parameters').output.firstRow.DataFactoryTypeMapping},\n    \"DF_FAIL_ON_NONCONFORMANT_DATA\": @{pipeline().parameters.P_FAIL_ON_NONCONFORMANT_DATA},\n    \"DF_TRIM_LENGTHS\": @{activity('Lookup Masking Parameters').output.firstRow.TrimLengths},\n    \"DF_FIELD_DATE_FORMAT\": @{activity('Lookup Masking Parameters').output.firstRow.DateFormatAssignments},\n    \"DF_COLUMNS_TO_CAST_AS_STRINGS\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastAsStrings},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_BINARY\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToBinary},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_BOOLEAN\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToBoolean},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_DATE\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToDate},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_DOUBLE\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToDouble},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_FLOAT\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToFloat},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_INTEGER\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToInteger},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_LONG\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToLong},\n    \"DF_COLUMNS_TO_CAST_BACK_TO_TIMESTAMP\": @{activity('Lookup Masking Parameters').output.firstRow.ColumnsToCastBackToTimestamp}\n}",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "is_masking_activity": {
                              "value": "true",
                              "type": "Boolean"
                            },
                            "pipeline_name": {
                              "value": {
                                "value": "@pipeline().Pipeline",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "pipeline_run_id": {
                              "value": {
                                "value": "@pipeline().RunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "pipeline_success": {
                              "value": "false",
                              "type": "Boolean"
                            },
                            "sink_database": {
                              "value": {
                                "value": "@pipeline().parameters.P_SINK_DATABASE",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "sink_schema": {
                              "value": {
                                "value": "@pipeline().parameters.P_SINK_SCHEMA",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_table": {
                              "value": {
                                "value": "@item().sink_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_database": {
                              "value": {
                                "value": "@pipeline().parameters.P_SOURCE_DATABASE",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "source_schema": {
                              "value": {
                                "value": "@pipeline().parameters.P_SOURCE_SCHEMA",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_table": {
                              "value": {
                                "value": "@item().source_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            }
                          }
                        },
                        "linkedServiceName": {
                          "referenceName": "[parameters('azuresql_mask_metadata_store_db')]",
                          "type": "LinkedServiceReference"
                        }
                      },
                      {
                        "name": "Fail After Updating Masked State With Filter",
                        "type": "Fail",
                        "dependsOn": [
                          {
                            "activity": "Update Masked State With Filter Failed",
                            "dependencyConditions": [
                              "Succeeded"
                            ]
                          }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                          "message": {
                            "value": "Failed to mask @{item().source_table} with filter alias @{item().filter_alias}",
                            "type": "Expression"
                          },
                          "errorCode": "500"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "Lookup Masking Parameters",
                  "description": "Lookup Masking Parameters",
                  "type": "Lookup",
                  "dependsOn": [],
                  "policy": {
                    "timeout": "0.12:00:00",
                    "retry": 0,
                    "retryIntervalInSeconds": 30,
                    "secureOutput": false,
                    "secureInput": false
                  },
                  "userProperties": [],
                  "typeProperties": {
                    "source": {
                      "type": "AzureSqlSource",
                      "sqlReaderStoredProcedureName": {
                        "value": "@{variables('METADATA_SCHEMA')}.@{variables('METADATA_MASKING_PARAMS_PROCEDURE_NAME')}",
                        "type": "Expression"
                      },
                      "storedProcedureParameters": {
                        "column_width_estimate": {
                          "type": "Int32",
                          "value": {
                            "value": "@variables('TARGET_BATCH_SIZE')",
                            "type": "Expression"
                          }
                        },
                        "dataset": {
                          "type": "String",
                          "value": {
                            "value": "@variables('DATASET')",
                            "type": "Expression"
                          }
                        },
                        "filter_alias": {
                          "type": "String",
                          "value": {
                            "value": "@item().filter_alias",
                            "type": "Expression"
                          }
                        },
                        "identified_table": {
                          "type": "String",
                          "value": {
                            "value": "@item().source_table",
                            "type": "Expression"
                          }
                        },
                        "specified_database": {
                          "type": "String",
                          "value": {
                            "value": "@pipeline().parameters.P_SOURCE_DATABASE",
                            "type": "Expression"
                          }
                        },
                        "specified_schema": {
                          "type": "String",
                          "value": {
                            "value": "@pipeline().parameters.P_SOURCE_SCHEMA",
                            "type": "Expression"
                          }
                        }
                      },
                      "queryTimeout": "02:00:00",
                      "partitionOption": "None"
                    },
                    "dataset": {
                      "referenceName": "dcsazure_AzureSQL_to_AzureSQL_mask_metadata_ds",
                      "type": "DatasetReference",
                      "parameters": {
                        "DS_METADATA_SCHEMA": {
                          "value": "@variables('METADATA_SCHEMA')",
                          "type": "Expression"
                        },
                        "DS_METADATA_TABLE": {
                          "value": "@variables('METADATA_RULESET_TABLE')",
                          "type": "Expression"
                        }
                      }
                    }
                  }
                }
              ]
            }
          },
          {
            "name": "Select Tables Without Required Masking",
            "description": "Select tables with a data mapping, and no assigned algorithms or rows.",
            "type": "Lookup",
            "dependsOn": [
              {
                "activity": "For Each Table To Truncate",
                "dependencyConditions": [
                  "Succeeded"
                ]
              }
            ],
            "policy": {
              "timeout": "0.12:00:00",
              "retry": 0,
              "retryIntervalInSeconds": 30,
              "secureOutput": false,
              "secureInput": false
            },
            "userProperties": [],
            "typeProperties": {
              "source": {
                "type": "AzureSqlSource",
                "sqlReaderQuery": {
                  "value": "SELECT DISTINCT\n\tsource_database,\n\tsource_schema,\n\tsource_table,\n\tsink_schema,\n\tsink_database,\n\tsink_table\nFROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')} dm\nWHERE\nUPPER(source_dataset) = UPPER('@{variables('DATASET')}')\nAND UPPER(sink_dataset) = UPPER('@{variables('DATASET')}')\nAND UPPER(source_database) = UPPER('@{pipeline().parameters.P_SOURCE_DATABASE}')\nAND UPPER(sink_database) = UPPER('@{pipeline().parameters.P_SINK_DATABASE}')\nAND UPPER(source_schema) = UPPER('@{pipeline().parameters.P_SOURCE_SCHEMA}')\nAND UPPER(sink_schema) = UPPER('@{pipeline().parameters.P_SINK_SCHEMA}')\nAND (dm.mapping_complete IS NULL OR dm.mapping_complete = 0)\nEXCEPT\nSELECT DISTINCT\n\tsource_database,\n\tsource_schema,\n\tsource_table,\n\tsink_schema,\n\tsink_database,\n\tsink_table\nFROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_RULESET_TABLE')} dd\nJOIN @{variables('METADATA_SCHEMA')}.@{variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')} dm\nON (\n\tUPPER(dm.source_database) = UPPER(dd.specified_database)\n\tAND UPPER(dm.source_schema) = UPPER(dd.specified_schema)\n\tAND UPPER(dm.source_table) = UPPER(dd.identified_table)\n)\nWHERE\n\tUPPER(dd.dataset) = UPPER('@{variables('DATASET')}')\n\tAND UPPER(dm.source_dataset) = UPPER('@{variables('DATASET')}')\n\tAND UPPER(dm.sink_dataset) = UPPER('@{variables('DATASET')}')\n\tAND dd.assigned_algorithm IS NOT NULL\n\tAND dd.assigned_algorithm != ''\n\tAND UPPER(dm.source_database) = UPPER('@{pipeline().parameters.P_SOURCE_DATABASE}')\n\tAND UPPER(dm.sink_database) = UPPER('@{pipeline().parameters.P_SINK_DATABASE}')\n\tAND UPPER(dm.source_schema) = UPPER('@{pipeline().parameters.P_SOURCE_SCHEMA}')\n\tAND UPPER(dm.sink_schema) = UPPER('@{pipeline().parameters.P_SINK_SCHEMA}');\n",
                  "type": "Expression"
                },
                "queryTimeout": "02:00:00",
                "partitionOption": "None"
              },
              "dataset": {
                "referenceName": "dcsazure_AzureSQL_to_AzureSQL_mask_metadata_ds",
                "type": "DatasetReference",
                "parameters": {
                  "DS_METADATA_SCHEMA": {
                    "value": "@variables('METADATA_SCHEMA')",
                    "type": "Expression"
                  },
                  "DS_METADATA_TABLE": {
                    "value": "@variables('METADATA_RULESET_TABLE')",
                    "type": "Expression"
                  }
                }
              },
              "firstRowOnly": false
            }
          },
          {
            "name": "Filter If Copy Unmasked Enabled",
            "type": "Filter",
            "dependsOn": [
              {
                "activity": "Select Tables Without Required Masking",
                "dependencyConditions": [
                  "Succeeded"
                ]
              }
            ],
            "userProperties": [],
            "typeProperties": {
              "items": {
                "value": "@activity('Select Tables Without Required Masking').output.value",
                "type": "Expression"
              },
              "condition": {
                "value": "@pipeline().parameters.P_COPY_UNMASKED_TABLES",
                "type": "Expression"
              }
            }
          },
          {
            "name": "For Each Table With No Masking",
            "description": "Copy unmasked data of each table using either Copy Dataflow or Copy Activity",
            "type": "ForEach",
            "dependsOn": [
              {
                "activity": "Filter If Copy Unmasked Enabled",
                "dependencyConditions": [
                  "Succeeded"
                ]
              }
            ],
            "userProperties": [],
            "typeProperties": {
              "items": {
                "value": "@activity('Filter If Copy Unmasked Enabled').output.value",
                "type": "Expression"
              },
              "activities": [
                {
                  "name": "If Use Copy Dataflow",
                  "type": "IfCondition",
                  "dependsOn": [],
                  "userProperties": [],
                  "typeProperties": {
                    "expression": {
                      "value": "@pipeline().parameters.P_USE_COPY_DATAFLOW",
                      "type": "Expression"
                    },
                    "ifFalseActivities": [
                      {
                        "name": "Copy Unmasked Data",
                        "description": "Calls the Copy Activity to copy unmasked data from source schema to sink schema for a given table if P_USE_COPY_DATAFLOW parameter is disabled",
                        "type": "Copy",
                        "dependsOn": [],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "source": {
                            "type": "AzureSqlSource",
                            "queryTimeout": "02:00:00",
                            "partitionOption": "None"
                          },
                          "sink": {
                            "type": "AzureSqlSink",
                            "writeBehavior": "insert",
                            "sqlWriterUseTableLock": false
                          },
                          "enableStaging": false,
                          "translator": {
                            "type": "TabularTranslator",
                            "typeConversion": true,
                            "typeConversionSettings": {
                              "allowDataTruncation": true,
                              "treatBooleanAsNumber": false
                            }
                          }
                        },
                        "inputs": [
                          {
                            "referenceName": "dcsazure_AzureSQL_to_AzureSQL_mask_source_ds",
                            "type": "DatasetReference",
                            "parameters": {
                              "DS_SOURCE_SCHEMA": {
                                "value": "@item().source_schema",
                                "type": "Expression"
                              },
                              "DS_SOURCE_TABLE": {
                                "value": "@item().source_table",
                                "type": "Expression"
                              },
                              "DS_SOURCE_DATABASE": {
                                "value": "@pipeline().parameters.P_SOURCE_DATABASE",
                                "type": "Expression"
                              }
                            }
                          }
                        ],
                        "outputs": [
                          {
                            "referenceName": "dcsazure_AzureSQL_to_AzureSQL_mask_sink_ds",
                            "type": "DatasetReference",
                            "parameters": {
                              "DS_SINK_SCHEMA": {
                                "value": "@item().sink_schema",
                                "type": "Expression"
                              },
                              "DS_SINK_TABLE": {
                                "value": "@item().sink_table",
                                "type": "Expression"
                              },
                              "DS_SINK_DATABASE": {
                                "value": "@pipeline().parameters.P_SINK_DATABASE",
                                "type": "Expression"
                              }
                            }
                          }
                        ]
                      },
                      {
                        "name": "Update Copy Unmasked Data State",
                        "type": "SqlServerStoredProcedure",
                        "dependsOn": [
                          {
                            "activity": "Copy Unmasked Data",
                            "dependencyConditions": [
                              "Succeeded"
                            ]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "storedProcedureName": {
                            "value": "@{variables('METADATA_SCHEMA')}.@{variables('METADATA_EVENT_PROCEDURE_NAME')}",
                            "type": "Expression"
                          },
                          "storedProcedureParameters": {
                            "activity_run_id": {
                              "value": {
                                "value": "@activity('Copy Unmasked Data').ActivityRunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "error_message": {
                              "value": null,
                              "type": "String"
                            },
                            "execution_end_time": {
                              "value": {
                                "value": "@activity('Copy Unmasked Data').ExecutionEndTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "execution_start_time": {
                              "value": {
                                "value": "@activity('Copy Unmasked Data').ExecutionStartTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "filter_alias": {
                              "value": null,
                              "type": "String"
                            },
                            "filter_condition": {
                              "value": null,
                              "type": "String"
                            },
                            "input_parameters": {
                              "value": {
                                "value": "{\n\"P_USE_COPY_DATAFLOW\": @{pipeline().parameters.P_USE_COPY_DATAFLOW}\n}\n",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "is_masking_activity": {
                              "value": "false",
                              "type": "Boolean"
                            },
                            "pipeline_name": {
                              "value": {
                                "value": "@pipeline().Pipeline",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "pipeline_run_id": {
                              "value": {
                                "value": "@pipeline().RunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "pipeline_success": {
                              "value": "true",
                              "type": "Boolean"
                            },
                            "sink_database": {
                              "value": {
                                "value": "@pipeline().parameters.P_SINK_DATABASE",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "sink_schema": {
                              "value": {
                                "value": "@pipeline().parameters.P_SINK_SCHEMA",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_table": {
                              "value": {
                                "value": "@item().sink_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_database": {
                              "value": {
                                "value": "@pipeline().parameters.P_SOURCE_DATABASE",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "source_schema": {
                              "value": {
                                "value": "@pipeline().parameters.P_SOURCE_SCHEMA",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_table": {
                              "value": {
                                "value": "@item().source_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            }
                          }
                        },
                        "linkedServiceName": {
                          "referenceName": "[parameters('azuresql_mask_metadata_store_db')]",
                          "type": "LinkedServiceReference"
                        }
                      },
                      {
                        "name": "Update Copy Unmasked Data State Failed",
                        "type": "SqlServerStoredProcedure",
                        "dependsOn": [
                          {
                            "activity": "Copy Unmasked Data",
                            "dependencyConditions": [
                              "Failed"
                            ]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "storedProcedureName": {
                            "value": "@{variables('METADATA_SCHEMA')}.@{variables('METADATA_EVENT_PROCEDURE_NAME')}",
                            "type": "Expression"
                          },
                          "storedProcedureParameters": {
                            "activity_run_id": {
                              "value": {
                                "value": "@activity('Copy Unmasked Data').ActivityRunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "error_message": {
                              "value": {
                                "value": "@activity('Copy Unmasked Data').Error.message",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "execution_end_time": {
                              "value": {
                                "value": "@activity('Copy Unmasked Data').ExecutionEndTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "execution_start_time": {
                              "value": {
                                "value": "@activity('Copy Unmasked Data').ExecutionStartTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "filter_alias": {
                              "value": null,
                              "type": "String"
                            },
                            "filter_condition": {
                              "value": null,
                              "type": "String"
                            },
                            "input_parameters": {
                              "value": {
                                "value": "{\n\"P_USE_COPY_DATAFLOW\": @{pipeline().parameters.P_USE_COPY_DATAFLOW}\n}\n",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "is_masking_activity": {
                              "value": "false",
                              "type": "Boolean"
                            },
                            "pipeline_name": {
                              "value": {
                                "value": "@pipeline().Pipeline",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "pipeline_run_id": {
                              "value": {
                                "value": "@pipeline().RunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "pipeline_success": {
                              "value": "false",
                              "type": "Boolean"
                            },
                            "sink_database": {
                              "value": {
                                "value": "@pipeline().parameters.P_SINK_DATABASE",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "sink_schema": {
                              "value": {
                                "value": "@pipeline().parameters.P_SINK_SCHEMA",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_table": {
                              "value": {
                                "value": "@item().sink_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_database": {
                              "value": {
                                "value": "@pipeline().parameters.P_SOURCE_DATABASE",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "source_schema": {
                              "value": {
                                "value": "@pipeline().parameters.P_SOURCE_SCHEMA",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_table": {
                              "value": {
                                "value": "@item().source_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            }
                          }
                        },
                        "linkedServiceName": {
                          "referenceName": "[parameters('azuresql_mask_metadata_store_db')]",
                          "type": "LinkedServiceReference"
                        }
                      },
                      {
                        "name": "Fail After Updating Copy Unmasked Data State",
                        "type": "Fail",
                        "dependsOn": [
                          {
                            "activity": "Update Copy Unmasked Data State Failed",
                            "dependencyConditions": [
                              "Succeeded"
                            ]
                          }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                          "message": {
                            "value": "Failed to copy @{item().source_table}",
                            "type": "Expression"
                          },
                          "errorCode": "500"
                        }
                      }
                    ],
                    "ifTrueActivities": [
                      {
                        "name": "Call Copy Dataflow",
                        "description": "Calls the Copy Dataflow to copy unmasked data from source schema to sink schema for a given table if P_USE_COPY_DATAFLOW parameter is enabled",
                        "type": "ExecuteDataFlow",
                        "dependsOn": [],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "dataflow": {
                            "referenceName": "dcsazure_AzureSQL_to_AzureSQL_copy_df",
                            "type": "DataFlowReference",
                            "parameters": {
                              "runId": {
                                "value": "'@{pipeline().RunId}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_SCHEMA": {
                                "value": "'@{item().source_schema}'",
                                "type": "Expression"
                              },
                              "DF_SINK_SCHEMA": {
                                "value": "'@{item().sink_schema}'",
                                "type": "Expression"
                              },
                              "DF_SOURCE_TABLE": {
                                "value": "'@{item().source_table}'",
                                "type": "Expression"
                              },
                              "DF_SINK_TABLE": {
                                "value": "'@{item().sink_table}'",
                                "type": "Expression"
                              }
                            },
                            "datasetParameters": {
                              "SourceData": {},
                              "SinkData": {}
                            },
                            "linkedServiceParameters": {
                              "SourceData": {
                                "linkedService": {
                                  "LS_DATABASE": {
                                    "value": "@pipeline().parameters.P_SOURCE_DATABASE",
                                    "type": "Expression"
                                  }
                                }
                              },
                              "SinkData": {
                                "linkedService": {
                                  "LS_DATABASE": {
                                    "value": "@pipeline().parameters.P_SINK_DATABASE",
                                    "type": "Expression"
                                  }
                                }
                              }
                            }
                          },
                          "staging": {},
                          "compute": {
                            "coreCount": 8,
                            "computeType": "General"
                          },
                          "traceLevel": "Fine"
                        }
                      },
                      {
                        "name": "Update Copy Dataflow State",
                        "type": "SqlServerStoredProcedure",
                        "dependsOn": [
                          {
                            "activity": "Call Copy Dataflow",
                            "dependencyConditions": [
                              "Succeeded"
                            ]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "storedProcedureName": {
                            "value": "@{variables('METADATA_SCHEMA')}.@{variables('METADATA_EVENT_PROCEDURE_NAME')}",
                            "type": "Expression"
                          },
                          "storedProcedureParameters": {
                            "activity_run_id": {
                              "value": {
                                "value": "@activity('Call Copy Dataflow').ActivityRunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "error_message": {
                              "value": null,
                              "type": "String"
                            },
                            "execution_end_time": {
                              "value": {
                                "value": "@activity('Call Copy Dataflow').ExecutionEndTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "execution_start_time": {
                              "value": {
                                "value": "@activity('Call Copy Dataflow').ExecutionStartTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "filter_alias": {
                              "value": null,
                              "type": "String"
                            },
                            "filter_condition": {
                              "value": null,
                              "type": "String"
                            },
                            "input_parameters": {
                              "value": {
                                "value": "{\n\"P_USE_COPY_DATAFLOW\": @{pipeline().parameters.P_USE_COPY_DATAFLOW}\n}\n",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "is_masking_activity": {
                              "value": "false",
                              "type": "Boolean"
                            },
                            "pipeline_name": {
                              "value": {
                                "value": "@pipeline().Pipeline",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "pipeline_run_id": {
                              "value": {
                                "value": "@pipeline().RunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "pipeline_success": {
                              "value": "true",
                              "type": "Boolean"
                            },
                            "sink_database": {
                              "value": {
                                "value": "@pipeline().parameters.P_SINK_DATABASE",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "sink_schema": {
                              "value": {
                                "value": "@pipeline().parameters.P_SINK_SCHEMA",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_table": {
                              "value": {
                                "value": "@item().sink_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_database": {
                              "value": {
                                "value": "@pipeline().parameters.P_SOURCE_DATABASE",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "source_schema": {
                              "value": {
                                "value": "@pipeline().parameters.P_SOURCE_SCHEMA",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_table": {
                              "value": {
                                "value": "@item().source_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            }
                          }
                        },
                        "linkedServiceName": {
                          "referenceName": "[parameters('azuresql_mask_metadata_store_db')]",
                          "type": "LinkedServiceReference"
                        }
                      },
                      {
                        "name": "Update Copy Dataflow State Failed",
                        "type": "SqlServerStoredProcedure",
                        "dependsOn": [
                          {
                            "activity": "Call Copy Dataflow",
                            "dependencyConditions": [
                              "Failed"
                            ]
                          }
                        ],
                        "policy": {
                          "timeout": "0.12:00:00",
                          "retry": 0,
                          "retryIntervalInSeconds": 30,
                          "secureOutput": false,
                          "secureInput": false
                        },
                        "userProperties": [],
                        "typeProperties": {
                          "storedProcedureName": {
                            "value": "@{variables('METADATA_SCHEMA')}.@{variables('METADATA_EVENT_PROCEDURE_NAME')}",
                            "type": "Expression"
                          },
                          "storedProcedureParameters": {
                            "activity_run_id": {
                              "value": {
                                "value": "@activity('Call Copy Dataflow').ActivityRunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "error_message": {
                              "value": {
                                "value": "@activity('Call Copy Dataflow').Error.message",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "execution_end_time": {
                              "value": {
                                "value": "@activity('Call Copy Dataflow').ExecutionEndTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "execution_start_time": {
                              "value": {
                                "value": "@activity('Call Copy Dataflow').ExecutionStartTime",
                                "type": "Expression"
                              },
                              "type": "DateTimeOffset"
                            },
                            "filter_alias": {
                              "value": null,
                              "type": "String"
                            },
                            "filter_condition": {
                              "value": null,
                              "type": "String"
                            },
                            "input_parameters": {
                              "value": {
                                "value": "{\n\"P_USE_COPY_DATAFLOW\": @{pipeline().parameters.P_USE_COPY_DATAFLOW}\n}\n",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "is_masking_activity": {
                              "value": "false",
                              "type": "Boolean"
                            },
                            "pipeline_name": {
                              "value": {
                                "value": "@pipeline().Pipeline",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "pipeline_run_id": {
                              "value": {
                                "value": "@pipeline().RunId",
                                "type": "Expression"
                              },
                              "type": "Guid"
                            },
                            "pipeline_success": {
                              "value": "false",
                              "type": "Boolean"
                            },
                            "sink_database": {
                              "value": {
                                "value": "@pipeline().parameters.P_SINK_DATABASE",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "sink_schema": {
                              "value": {
                                "value": "@pipeline().parameters.P_SINK_SCHEMA",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "sink_table": {
                              "value": {
                                "value": "@item().sink_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_database": {
                              "value": {
                                "value": "@pipeline().parameters.P_SOURCE_DATABASE",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_dataset": {
                              "value": {
                                "value": "@variables('DATASET')",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_metadata": {
                              "value": null,
                              "type": "String"
                            },
                            "source_schema": {
                              "value": {
                                "value": "@pipeline().parameters.P_SOURCE_SCHEMA",
                                "type": "Expression"
                              },
                              "type": "String"
                            },
                            "source_table": {
                              "value": {
                                "value": "@item().source_table",
                                "type": "Expression"
                              },
                              "type": "String"
                            }
                          }
                        },
                        "linkedServiceName": {
                          "referenceName": "[parameters('azuresql_mask_metadata_store_db')]",
                          "type": "LinkedServiceReference"
                        }
                      },
                      {
                        "name": "Fail After Updating Copy Dataflow State",
                        "type": "Fail",
                        "dependsOn": [
                          {
                            "activity": "Update Copy Dataflow State Failed",
                            "dependencyConditions": [
                              "Succeeded"
                            ]
                          }
                        ],
                        "userProperties": [],
                        "typeProperties": {
                          "message": {
                            "value": "Failed to copy @{item().source_table}",
                            "type": "Expression"
                          },
                          "errorCode": "500"
                        }
                      }
                    ]
                  }
                }
              ]
            }
          },
          {
            "name": "Test Filter Conditions",
            "description": "Use data preview on Lookup \"Select Tables That Require Masking\" activity to confirm what filter conditions are to be applied. Leverage data preview on this data flow to confirm your filter is working as expected.",
            "type": "ExecuteDataFlow",
            "state": "Inactive",
            "onInactiveMarkAs": "Succeeded",
            "dependsOn": [],
            "policy": {
              "timeout": "0.12:00:00",
              "retry": 0,
              "retryIntervalInSeconds": 30,
              "secureOutput": false,
              "secureInput": false
            },
            "userProperties": [],
            "typeProperties": {
              "dataflow": {
                "referenceName": "dcsazure_AzureSQL_to_AzureSQL_filter_test_utility_df",
                "type": "DataFlowReference",
                "parameters": {
                  "runId": {
                    "value": "'@{pipeline().RunId}'",
                    "type": "Expression"
                  },
                  "DF_SOURCE_SCHEMA": {
                    "value": "'@{pipeline().parameters.P_SOURCE_SCHEMA}'",
                    "type": "Expression"
                  },
                  "DF_SOURCE_TABLE": "''",
                  "DF_SINK_SCHEMA": "''",
                  "DF_SINK_TABLE": "''",
                  "DF_FIELD_ALGORITHM_ASSIGNMENT": "'{}'",
                  "DF_COLUMNS_TO_MASK": [
                    ""
                  ],
                  "DF_BODY_TYPE_MAPPING": "'(timestamp as date, status as string, message as string, trace_id as string, items as (DELPHIX_COMPLIANCE_SERVICE_BATCH_ID as long)[])'",
                  "DF_NUMBER_OF_BATCHES": 100,
                  "DF_TRIM_LENGTHS": [
                    1000
                  ],
                  "DF_FAIL_ON_NONCONFORMANT_DATA": "true()",
                  "DF_FIELD_DATE_FORMAT": "'{}'",
                  "DF_FILTER_CONDITION": "true()"
                },
                "datasetParameters": {
                  "Source": {},
                  "Sink": {}
                },
                "linkedServiceParameters": {
                  "Source": {
                    "linkedService": {
                      "LS_DATABASE": {
                        "value": "@pipeline().parameters.P_SOURCE_DATABASE",
                        "type": "Expression"
                      }
                    }
                  },
                  "Sink": {
                    "linkedService": {
                      "LS_DATABASE": {
                        "value": "@pipeline().parameters.P_SINK_DATABASE",
                        "type": "Expression"
                      }
                    }
                  }
                }
              },
              "staging": {},
              "compute": {
                "coreCount": 8,
                "computeType": "General"
              },
              "traceLevel": "Fine"
            }
          },
          {
            "name": "Check If We Should Reapply Mapping",
            "type": "IfCondition",
            "dependsOn": [],
            "userProperties": [],
            "typeProperties": {
              "expression": {
                "value": "@pipeline().parameters.P_REAPPLY_MAPPING",
                "type": "Expression"
              },
              "ifTrueActivities": [
                {
                  "name": "Mark Table Mapping Incomplete",
                  "description": "Mark all tables in this database and schema as unmapped so that we can re-apply the mapping to them",
                  "type": "Script",
                  "dependsOn": [],
                  "policy": {
                    "timeout": "0.12:00:00",
                    "retry": 0,
                    "retryIntervalInSeconds": 30,
                    "secureOutput": false,
                    "secureInput": false
                  },
                  "userProperties": [],
                  "linkedServiceName": {
                    "referenceName": "[parameters('azuresql_mask_metadata_store_db')]",
                    "type": "LinkedServiceReference"
                  },
                  "typeProperties": {
                    "scripts": [
                      {
                        "type": "Query",
                        "text": {
                          "value": "UPDATE\n    @{variables('METADATA_SCHEMA')}.@{variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')}\nSET\n    mapping_complete = CAST(0 AS BIT),\n    masked_status = NULL\nWHERE\n    UPPER(source_dataset) = UPPER('@{variables('DATASET')}')\n    AND UPPER(source_database) = UPPER('@{pipeline().parameters.P_SOURCE_DATABASE}')\n    AND UPPER(source_schema) = UPPER('@{pipeline().parameters.P_SOURCE_SCHEMA}')",
                          "type": "Expression"
                        }
                      }
                    ],
                    "scriptBlockExecutionTimeout": "02:00:00"
                  }
                }
              ]
            }
          },
          {
            "name": "Select Tables We Should Truncate",
            "type": "Lookup",
            "dependsOn": [
              {
                "activity": "Execute Drop Constraint Pipeline",
                "dependencyConditions": [
                  "Succeeded"
                ]
              }
            ],
            "policy": {
              "timeout": "0.12:00:00",
              "retry": 0,
              "retryIntervalInSeconds": 30,
              "secureOutput": false,
              "secureInput": false
            },
            "userProperties": [],
            "typeProperties": {
              "source": {
                "type": "AzureSqlSource",
                "sqlReaderQuery": {
                  "value": "SELECT DISTINCT\n    dm.sink_dataset,\n    dm.sink_database,\n    dm.sink_schema,\n    dm.sink_table\nFROM\n    @{variables('METADATA_SCHEMA')}.@{variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')} dm\nWHERE\n    dm.source_dataset = '@{variables('DATASET')}'\n    AND dm.source_database = '@{pipeline().parameters.P_SOURCE_DATABASE}'\n    AND dm.source_schema = '@{pipeline().parameters.P_SOURCE_SCHEMA}'\n    AND dm.sink_dataset = '@{variables('DATASET')}'\n    AND dm.sink_database = '@{pipeline().parameters.P_SINK_DATABASE}'\n    AND dm.sink_schema = '@{pipeline().parameters.P_SINK_SCHEMA}'\n    AND (dm.mapping_complete IS NULL OR dm.mapping_complete = 0)\n    AND LOWER('@{pipeline().parameters.P_TRUNCATE_SINK_BEFORE_WRITE}') = 'true'\n",
                  "type": "Expression"
                },
                "queryTimeout": "02:00:00",
                "partitionOption": "None"
              },
              "dataset": {
                "referenceName": "dcsazure_AzureSQL_to_AzureSQL_mask_metadata_ds",
                "type": "DatasetReference",
                "parameters": {
                  "DS_METADATA_SCHEMA": {
                    "value": "@variables('METADATA_SCHEMA')",
                    "type": "Expression"
                  },
                  "DS_METADATA_TABLE": {
                    "value": "@variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')",
                    "type": "Expression"
                  }
                }
              },
              "firstRowOnly": false
            }
          },
          {
            "name": "For Each Table To Truncate",
            "type": "ForEach",
            "dependsOn": [
              {
                "activity": "Select Tables We Should Truncate",
                "dependencyConditions": [
                  "Succeeded"
                ]
              }
            ],
            "userProperties": [],
            "typeProperties": {
              "items": {
                "value": "@activity('Select Tables We Should Truncate').output.value",
                "type": "Expression"
              },
              "activities": [
                {
                  "name": "Truncate Selected Table",
                  "type": "Script",
                  "dependsOn": [],
                  "policy": {
                    "timeout": "0.12:00:00",
                    "retry": 0,
                    "retryIntervalInSeconds": 30,
                    "secureOutput": false,
                    "secureInput": false
                  },
                  "userProperties": [],
                  "linkedServiceName": {
                    "referenceName": "[parameters('azuresql_mask_sink_db')]",
                    "type": "LinkedServiceReference",
                    "parameters": {
                      "LS_DATABASE": {
                        "value": "@pipeline().parameters.P_SINK_DATABASE",
                        "type": "Expression"
                      }
                    }
                  },
                  "typeProperties": {
                    "scripts": [
                      {
                        "type": "Query",
                        "text": {
                          "value": "TRUNCATE TABLE \"@{item().sink_database}\".\"@{item().sink_schema}\".\"@{item().sink_table}\"",
                          "type": "Expression"
                        }
                      }
                    ],
                    "scriptBlockExecutionTimeout": "02:00:00"
                  }
                }
              ]
            }
          },
          {
            "name": "Configure Masked Status",
            "description": "Configure Masked Status for a given table in the Source-to-Sink mapping table if it is not set. Masked Status will not be set if the table has not been masked before or if P_REAPPLY_MASKING parameter is set to true.",
            "type": "Script",
            "dependsOn": [
              {
                "activity": "Select Tables That Require Masking",
                "dependencyConditions": [
                  "Succeeded"
                ]
              }
            ],
            "policy": {
              "timeout": "0.12:00:00",
              "retry": 0,
              "retryIntervalInSeconds": 30,
              "secureOutput": false,
              "secureInput": false
            },
            "userProperties": [],
            "linkedServiceName": {
              "referenceName": "[parameters('azuresql_mask_metadata_store_db')]",
              "type": "LinkedServiceReference"
            },
            "typeProperties": {
              "scripts": [
                {
                  "type": "Query",
                  "text": {
                    "value": "WITH\n    tables_requiring_filters AS (\n        SELECT DISTINCT\n            dataset, specified_database, specified_schema, identified_table\n        FROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_RULESET_TABLE')}\n        WHERE ISJSON(assigned_algorithm) = 1\n            AND dataset = '@{variables('DATASET')}'\n            AND specified_database = '@{pipeline().parameters.P_SOURCE_DATABASE}'\n            AND specified_schema = '@{pipeline().parameters.P_SOURCE_SCHEMA}'\n    ), all_filters AS (\n        SELECT DISTINCT\n            JSON_VALUE(kc.value, '$.alias') as filter_alias,\n            identified_table\n        FROM @{variables('METADATA_SCHEMA')}.@{variables('METADATA_RULESET_TABLE')} d\n            CROSS APPLY OPENJSON(d.assigned_algorithm) kc\n        WHERE\n            ISJSON(d.assigned_algorithm,ARRAY) = 1\n            AND\n            d.identified_table in (\n                SELECT identified_table FROM tables_requiring_filters\n            )\n    ), sources_and_filters AS (\n        SELECT\n            dataset,\n            specified_database,\n            specified_schema,\n            tables_requiring_filters.identified_table,\n            JSON_OBJECTAGG(filter_alias:CAST(0 as BIT)) AS masked_status\n        FROM tables_requiring_filters\n            INNER JOIN all_filters\n            ON tables_requiring_filters.identified_table = all_filters.identified_table\n        GROUP BY dataset, specified_database, specified_schema, tables_requiring_filters.identified_table\n    )\n    UPDATE @{variables('METADATA_SCHEMA')}.@{variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')}\n    SET masked_status = sf.masked_status\n    FROM sources_and_filters sf\n    INNER JOIN @{variables('METADATA_SCHEMA')}.@{variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')} dm ON\n        dm.source_dataset = sf.dataset AND\n        dm.source_database = sf.specified_database AND\n        dm.source_schema = sf.specified_schema AND\n        dm.source_table = sf.identified_table\n    WHERE\n        dm.masked_status IS NULL\n        AND (dm.mapping_complete IS NULL OR dm.mapping_complete = 0)\n",
                    "type": "Expression"
                  }
                }
              ],
              "scriptBlockExecutionTimeout": "02:00:00"
            }
          },
          {
            "name": "Execute Drop Constraint Pipeline",
            "type": "ExecutePipeline",
            "dependsOn": [
              {
                "activity": "Check If We Should Reapply Mapping",
                "dependencyConditions": [
                  "Succeeded"
                ]
              }
            ],
            "policy": {
              "secureInput": false
            },
            "userProperties": [],
            "typeProperties": {
              "pipeline": {
                "referenceName": "dcsazure_AzureSQL_to_AzureSQL_mask_drop_constraint_pl",
                "type": "PipelineReference"
              },
              "waitOnCompletion": true,
              "parameters": {
                "P_SOURCE_DATABASE": {
                  "value": "@pipeline().parameters.P_SOURCE_DATABASE",
                  "type": "Expression"
                },
                "P_SINK_DATABASE": {
                  "value": "@pipeline().parameters.P_SINK_DATABASE",
                  "type": "Expression"
                },
                "P_SOURCE_SCHEMA": {
                  "value": "@pipeline().parameters.P_SOURCE_SCHEMA",
                  "type": "Expression"
                },
                "P_SINK_SCHEMA": {
                  "value": "@pipeline().parameters.P_SINK_SCHEMA",
                  "type": "Expression"
                },
                "P_DATASET": {
                  "value": "@variables('DATASET')",
                  "type": "Expression"
                },
                "P_METADATA_CONSTRAINT_TABLE": {
                  "value": "@variables('METADATA_CONSTRAINT_TABLE')",
                  "type": "Expression"
                },
                "P_METADATA_SCHEMA": {
                  "value": "@variables('METADATA_SCHEMA')",
                  "type": "Expression"
                },
                "P_METADATA_SOURCE_TO_SINK_MAPPING_TABLE": {
                  "value": "@variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')",
                  "type": "Expression"
                },
                "P_METADATA_EVENT_PROCEDURE_NAME": {
                  "value": "@variables('METADATA_EVENT_PROCEDURE_NAME')",
                  "type": "Expression"
                },
                "P_PARENT_RUN_ID": {
                  "value": "@pipeline().RunId",
                  "type": "Expression"
                },
                "P_METADATA_INSERT_CONSTRAINT_PROCEDURE_NAME": {
                  "value": "@variables('METADATA_INSERT_CONSTRAINT_PROCEDURE_NAME')",
                  "type": "Expression"
                }
              }
            }
          },
          {
            "name": "Execute Create Constraint Pipeline",
            "type": "ExecutePipeline",
            "dependsOn": [
              {
                "activity": "For Each Table To Mask",
                "dependencyConditions": [
                  "Completed"
                ]
              },
              {
                "activity": "For Each Table With No Masking",
                "dependencyConditions": [
                  "Completed"
                ]
              }
            ],
            "policy": {
              "secureInput": false
            },
            "userProperties": [],
            "typeProperties": {
              "pipeline": {
                "referenceName": "dcsazure_AzureSQL_to_AzureSQL_mask_create_constraint_pl",
                "type": "PipelineReference"
              },
              "waitOnCompletion": true,
              "parameters": {
                "P_SOURCE_DATABASE": {
                  "value": "@pipeline().parameters.P_SOURCE_DATABASE",
                  "type": "Expression"
                },
                "P_SINK_DATABASE": {
                  "value": "@pipeline().parameters.P_SINK_DATABASE",
                  "type": "Expression"
                },
                "P_SOURCE_SCHEMA": {
                  "value": "@pipeline().parameters.P_SOURCE_SCHEMA",
                  "type": "Expression"
                },
                "P_SINK_SCHEMA": {
                  "value": "@pipeline().parameters.P_SINK_SCHEMA",
                  "type": "Expression"
                },
                "P_METADATA_SCHEMA": {
                  "value": "@variables('METADATA_SCHEMA')",
                  "type": "Expression"
                },
                "P_METADATA_CONSTRAINT_TABLE": {
                  "value": "@variables('METADATA_CONSTRAINT_TABLE')",
                  "type": "Expression"
                },
                "P_DATASET": {
                  "value": "@variables('DATASET')",
                  "type": "Expression"
                },
                "P_METADATA_SOURCE_TO_SINK_MAPPING_TABLE": {
                  "value": "@variables('METADATA_SOURCE_TO_SINK_MAPPING_TABLE')",
                  "type": "Expression"
                },
                "P_METADATA_EVENT_PROCEDURE_NAME": {
                  "value": "@variables('METADATA_EVENT_PROCEDURE_NAME')",
                  "type": "Expression"
                },
                "P_PARENT_RUN_ID": {
                  "value": "@pipeline().RunId",
                  "type": "Expression"
                },
                "P_METADATA_UPDATE_CONSTRAINT_PROCEDURE_NAME": {
                  "value": "@variables('METADATA_UPDATE_CONSTRAINT_PROCEDURE_NAME')",
                  "type": "Expression"
                }
              }
            }
          },
          {
            "name": "Check And Set Pipeline Status",
            "description": "Checks if the variable PIPELINE_FAILED is true and fails the pipeline",
            "type": "IfCondition",
            "dependsOn": [
              {
                "activity": "Execute Create Constraint Pipeline",
                "dependencyConditions": [
                  "Succeeded"
                ]
              }
            ],
            "userProperties": [],
            "typeProperties": {
              "expression": {
                "value": "@equals(variables('PIPELINE_FAILED'), true)",
                "type": "Expression"
              },
              "ifTrueActivities": [
                {
                  "name": "Fail Pipeline",
                  "type": "Fail",
                  "dependsOn": [],
                  "userProperties": [],
                  "typeProperties": {
                    "message": {
                      "value": "The pipeline failed due to one or more previous activities failed.",
                      "type": "Expression"
                    },
                    "errorCode": "500"
                  }
                }
              ]
            }
          },
          {
            "name": "Set Pipeline Failure",
            "description": "Set the PIPELINE_FAILED variable to true, so as to correctly set the overall final status of the pipeline. ",
            "type": "SetVariable",
            "dependsOn": [
              {
                "activity": "For Each Table To Mask",
                "dependencyConditions": [
                  "Failed"
                ]
              },
              {
                "activity": "For Each Table With No Masking",
                "dependencyConditions": [
                  "Failed"
                ]
              }
            ],
            "policy": {
              "secureOutput": false,
              "secureInput": false
            },
            "userProperties": [],
            "typeProperties": {
              "variableName": "PIPELINE_FAILED",
              "value": true
            }
          }
        ],
        "policy": {
          "elapsedTimeMetric": {}
        },
        "parameters": {
          "P_COPY_UNMASKED_TABLES": {
            "type": "bool",
            "defaultValue": false
          },
          "P_USE_COPY_DATAFLOW": {
            "type": "bool",
            "defaultValue": false
          },
          "P_FAIL_ON_NONCONFORMANT_DATA": {
            "type": "bool",
            "defaultValue": true
          },
          "P_SOURCE_DATABASE": {
            "type": "string"
          },
          "P_SINK_DATABASE": {
            "type": "string"
          },
          "P_SOURCE_SCHEMA": {
            "type": "string"
          },
          "P_SINK_SCHEMA": {
            "type": "string"
          },
          "P_REAPPLY_MAPPING": {
            "type": "bool",
            "defaultValue": true
          },
          "P_TRUNCATE_SINK_BEFORE_WRITE": {
            "type": "bool",
            "defaultValue": true
          }
        },
        "variables": {
          "METADATA_SCHEMA": {
            "type": "String",
            "defaultValue": "dbo"
          },
          "METADATA_RULESET_TABLE": {
            "type": "String",
            "defaultValue": "discovered_ruleset"
          },
          "METADATA_SOURCE_TO_SINK_MAPPING_TABLE": {
            "type": "String",
            "defaultValue": "adf_data_mapping"
          },
          "METADATA_ADF_TYPE_MAPPING_TABLE": {
            "type": "String",
            "defaultValue": "adf_type_mapping"
          },
          "BLOB_STORE_STAGING_STORAGE_PATH": {
            "type": "String",
            "defaultValue": "staging-containter"
          },
          "DATASET": {
            "type": "String",
            "defaultValue": "AZURESQL"
          },
          "CONDITIONAL_MASKING_RESERVED_CHARACTER": {
            "type": "String",
            "defaultValue": "%"
          },
          "METADATA_EVENT_PROCEDURE_NAME": {
            "type": "String",
            "defaultValue": "insert_adf_masking_event"
          },
          "TARGET_BATCH_SIZE": {
            "type": "Integer",
            "defaultValue": 2000
          },
          "METADATA_CONSTRAINT_TABLE": {
            "type": "String",
            "defaultValue": "capture_constraints"
          },
          "PIPELINE_FAILED": {
            "type": "Boolean",
            "defaultValue": false
          },
          "METADATA_INSERT_CONSTRAINT_PROCEDURE_NAME": {
            "type": "String",
            "defaultValue": "insert_constraints"
          },
          "METADATA_UPDATE_CONSTRAINT_PROCEDURE_NAME": {
            "type": "String",
            "defaultValue": "update_constraints_status"
          },
          "METADATA_MASKING_PARAMS_PROCEDURE_NAME": {
            "type": "String",
            "defaultValue": "generate_masking_parameters"
          }
        },
        "folder": {
          "name": "dcsazure_AzureSQL_to_AzureSQL"
        },
        "annotations": [],
        "lastPublishTime": "2025-10-08T11:34:30Z"
      },
      "dependsOn": [
        "[concat(variables('factoryId'), '/datasets/dcsazure_AzureSQL_to_AzureSQL_mask_metadata_ds')]",
        "[concat(variables('factoryId'), '/dataflows/dcsazure_AzureSQL_to_AzureSQL_filter_test_utility_df')]",
        "[concat(variables('factoryId'), '/pipelines/dcsazure_AzureSQL_to_AzureSQL_mask_drop_constraint_pl')]",
        "[concat(variables('factoryId'), '/pipelines/dcsazure_AzureSQL_to_AzureSQL_mask_create_constraint_pl')]",
        "[concat(variables('factoryId'), '/dataflows/dcsazure_AzureSQL_to_AzureSQL_unfiltered_mask_df')]",
        "[concat(variables('factoryId'), '/dataflows/dcsazure_AzureSQL_to_AzureSQL_filtered_mask_df')]",
        "[concat(variables('factoryId'), '/datasets/dcsazure_AzureSQL_to_AzureSQL_mask_source_ds')]",
        "[concat(variables('factoryId'), '/datasets/dcsazure_AzureSQL_to_AzureSQL_mask_sink_ds')]",
        "[concat(variables('factoryId'), '/dataflows/dcsazure_AzureSQL_to_AzureSQL_copy_df')]"
      ]
    },
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_AzureSQL_to_AzureSQL_mask_metadata_ds')]",
      "type": "Microsoft.DataFactory/factories/datasets",
      "apiVersion": "2018-06-01",
      "properties": {
        "linkedServiceName": {
          "referenceName": "[parameters('azuresql_mask_metadata_store_db')]",
          "type": "LinkedServiceReference"
        },
        "parameters": {
          "DS_METADATA_SCHEMA": {
            "type": "string"
          },
          "DS_METADATA_TABLE": {
            "type": "string"
          }
        },
        "folder": {
          "name": "dcsazure_AzureSQL_to_AzureSQL"
        },
        "annotations": [],
        "type": "AzureSqlTable",
        "schema": [],
        "typeProperties": {
          "schema": {
            "value": "@dataset().DS_METADATA_SCHEMA",
            "type": "Expression"
          },
          "table": {
            "value": "@dataset().DS_METADATA_TABLE",
            "type": "Expression"
          }
        }
      },
      "dependsOn": []
    },
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_AzureSQL_to_AzureSQL_filter_test_utility_df')]",
      "type": "Microsoft.DataFactory/factories/dataflows",
      "apiVersion": "2018-06-01",
      "properties": {
        "folder": {
          "name": "dcsazure_AzureSQL_to_AzureSQL"
        },
        "type": "MappingDataFlow",
        "typeProperties": {
          "sources": [
            {
              "linkedService": {
                "referenceName": "[parameters('azuresql_mask_source_db')]",
                "type": "LinkedServiceReference"
              },
              "name": "Source",
              "description": "Select source data at DF_SOURCE_SCHEMA.DF_SOURCE_TABLE using an inline dataset"
            }
          ],
          "sinks": [
            {
              "linkedService": {
                "referenceName": "[parameters('azuresql_mask_sink_db')]",
                "type": "LinkedServiceReference"
              },
              "name": "Sink",
              "description": "Sink results of masking to data store by sinking the unrolled results of the masking call to the columns of the same name in the data sink"
            }
          ],
          "transformations": [
            {
              "name": "FilterToAppropriateRows",
              "description": "Filter base table based on supplied filter"
            }
          ],
          "scriptLines": [
            "parameters{",
            "     runId as string (''),",
            "     DF_SOURCE_SCHEMA as string (''),",
            "     DF_SOURCE_TABLE as string (''),",
            "     DF_SINK_SCHEMA as string (''),",
            "     DF_SINK_TABLE as string (''),",
            "     DF_FIELD_ALGORITHM_ASSIGNMENT as string ('{}'),",
            "     DF_COLUMNS_TO_MASK as string[] ([\"\"]),",
            "     DF_BODY_TYPE_MAPPING as string ('(timestamp as date, status as string, message as string, trace_id as string, items as (DELPHIX_COMPLIANCE_SERVICE_BATCH_ID as long)[])'),",
            "     DF_NUMBER_OF_BATCHES as integer (100),",
            "     DF_TRIM_LENGTHS as integer[] ([1000]),",
            "     DF_FAIL_ON_NONCONFORMANT_DATA as boolean (true()),",
            "     DF_FIELD_DATE_FORMAT as string ('{}'),",
            "     DF_FILTER_CONDITION as boolean (true())",
            "}",
            "source(allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'table',",
            "     store: 'sqlserver',",
            "     schemaName: ($DF_SOURCE_SCHEMA),",
            "     tableName: ($DF_SOURCE_TABLE),",
            "     isolationLevel: 'READ_UNCOMMITTED',",
            "     partitionBy('roundRobin', 32)) ~> Source",
            "Source filter($DF_FILTER_CONDITION) ~> FilterToAppropriateRows",
            "FilterToAppropriateRows sink(allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'table',",
            "     store: 'sqlserver',",
            "     schemaName: ($DF_SINK_SCHEMA),",
            "     tableName: ($DF_SINK_TABLE),",
            "     insertable: true,",
            "     updateable: false,",
            "     deletable: false,",
            "     upsertable: false,",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true,",
            "     errorHandlingOption: 'stopOnFirstError',",
            "     mapColumn(",
            "          each(match(name!=\"DELPHIX_COMPLIANCE_SERVICE_BATCH_ID\"&&name!=\"DELPHIX_COMPLIANCE_SERVICE_SORT_ID\"))",
            "     ),",
            "     preCommands: [],",
            "     postCommands: []) ~> Sink"
          ]
        }
      },
      "dependsOn": []
    },
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_AzureSQL_to_AzureSQL_mask_drop_constraint_pl')]",
      "type": "Microsoft.DataFactory/factories/pipelines",
      "apiVersion": "2018-06-01",
      "properties": {
        "activities": [
          {
            "name": "For Each Constraint To Drop",
            "description": "Drop constraints for all tables in sink schema",
            "type": "ForEach",
            "dependsOn": [
              {
                "activity": "Select Discovered Constraints",
                "dependencyConditions": [
                  "Succeeded"
                ]
              }
            ],
            "userProperties": [],
            "typeProperties": {
              "items": {
                "value": "@activity('Select Discovered Constraints').output.value",
                "type": "Expression"
              },
              "activities": [
                {
                  "name": "Drop Constraint",
                  "type": "Script",
                  "dependsOn": [],
                  "policy": {
                    "timeout": "0.12:00:00",
                    "retry": 0,
                    "retryIntervalInSeconds": 30,
                    "secureOutput": false,
                    "secureInput": false
                  },
                  "userProperties": [],
                  "linkedServiceName": {
                    "referenceName": "[parameters('azuresql_mask_sink_db')]",
                    "type": "LinkedServiceReference",
                    "parameters": {
                      "LS_DATABASE": {
                        "value": "@pipeline().parameters.P_SINK_DATABASE",
                        "type": "Expression"
                      }
                    }
                  },
                  "typeProperties": {
                    "scripts": [
                      {
                        "type": "Query",
                        "text": {
                          "value": "@concat('IF (OBJECT_ID(''',item().specified_schema, '.',item().constraint_name,''') IS NOT NULL) BEGIN ALTER TABLE [',item().specified_schema, '].[', item().child_table, '] DROP CONSTRAINT ', item().constraint_name, ' END ')",
                          "type": "Expression"
                        }
                      }
                    ],
                    "scriptBlockExecutionTimeout": "02:00:00"
                  }
                },
                {
                  "name": "Update Drop Contraint Error",
                  "description": "Log the error message encountered during the Drop Constraint activity in the database",
                  "type": "Script",
                  "dependsOn": [
                    {
                      "activity": "Update Masked State With Drop Constraint Error",
                      "dependencyConditions": [
                        "Succeeded"
                      ]
                    }
                  ],
                  "policy": {
                    "timeout": "0.12:00:00",
                    "retry": 0,
                    "retryIntervalInSeconds": 30,
                    "secureOutput": false,
                    "secureInput": false
                  },
                  "userProperties": [],
                  "linkedServiceName": {
                    "referenceName": "[parameters('azuresql_mask_metadata_store_db')]",
                    "type": "LinkedServiceReference"
                  },
                  "typeProperties": {
                    "scripts": [
                      {
                        "type": "Query",
                        "text": {
                          "value": "UPDATE @{pipeline().parameters.P_METADATA_SCHEMA}.@{pipeline().parameters.P_METADATA_CONSTRAINT_TABLE}\nSET drop_error_message = @{concat('''', replace(activity('Drop Constraint').Error.message, '''', ''''''), '''')}\nWHERE pipeline_run_id = '@{pipeline().parameters.P_PARENT_RUN_ID}'\n    AND dataset = '@{pipeline().parameters.P_DATASET}'\n    AND specified_database = '@{pipeline().parameters.P_SINK_DATABASE}'\n    AND specified_schema = '@{pipeline().parameters.P_SINK_SCHEMA}'\n    AND identified_parent_table = '@{item().identified_parent_table}'\n    AND child_table = '@{item().child_table}'\n    AND constraint_name = '@{item().constraint_name}'",
                          "type": "Expression"
                        }
                      }
                    ],
                    "scriptBlockExecutionTimeout": "02:00:00"
                  }
                },
                {
                  "name": "Fail on Drop Constraint Error",
                  "description": "Fail on Drop Constraint Error",
                  "type": "Fail",
                  "dependsOn": [
                    {
                      "activity": "Update Drop Contraint Error",
                      "dependencyConditions": [
                        "Succeeded"
                      ]
                    }
                  ],
                  "userProperties": [],
                  "typeProperties": {
                    "message": {
                      "value": "Failed to drop constraint @{item().constraint_name} on @{item().child_table}",
                      "type": "Expression"
                    },
                    "errorCode": "500"
                  }
                },
                {
                  "name": "Update Masked State With Drop Constraint Error",
                  "description": "Update Masked State With Drop Constraint Error",
                  "type": "SqlServerStoredProcedure",
                  "dependsOn": [
                    {
                      "activity": "Drop Constraint",
                      "dependencyConditions": [
                        "Failed"
                      ]
                    }
                  ],
                  "policy": {
                    "timeout": "0.12:00:00",
                    "retry": 0,
                    "retryIntervalInSeconds": 30,
                    "secureOutput": false,
                    "secureInput": false
                  },
                  "userProperties": [],
                  "typeProperties": {
                    "storedProcedureName": {
                      "value": "@concat(pipeline().parameters.P_METADATA_SCHEMA, '.', pipeline().parameters.P_METADATA_EVENT_PROCEDURE_NAME)",
                      "type": "Expression"
                    },
                    "storedProcedureParameters": {
                      "activity_run_id": {
                        "value": {
                          "value": "@activity('Drop Constraint').ActivityRunId",
                          "type": "Expression"
                        },
                        "type": "Guid"
                      },
                      "error_message": {
                        "value": {
                          "value": "@activity('Drop Constraint').Error.message",
                          "type": "Expression"
                        },
                        "type": "String"
                      },
                      "execution_end_time": {
                        "value": {
                          "value": "@activity('Drop Constraint').ExecutionEndTime",
                          "type": "Expression"
                        },
                        "type": "DateTimeOffset"
                      },
                      "execution_start_time": {
                        "value": {
                          "value": "@activity('Drop Constraint').ExecutionStartTime",
                          "type": "Expression"
                        },
                        "type": "DateTimeOffset"
                      },
                      "filter_alias": {
                        "value": null,
                        "type": "String"
                      },
                      "filter_condition": {
                        "value": null,
                        "type": "String"
                      },
                      "input_parameters": {
                        "value": null,
                        "type": "String"
                      },
                      "is_masking_activity": {
                        "value": "false",
                        "type": "Boolean"
                      },
                      "pipeline_name": {
                        "value": {
                          "value": "@pipeline().Pipeline",
                          "type": "Expression"
                        },
                        "type": "String"
                      },
                      "pipeline_run_id": {
                        "value": {
                          "value": "@pipeline().RunId",
                          "type": "Expression"
                        },
                        "type": "Guid"
                      },
                      "pipeline_success": {
                        "value": "false",
                        "type": "Boolean"
                      },
                      "sink_database": {
                        "value": {
                          "value": "@pipeline().parameters.P_SINK_DATABASE",
                          "type": "Expression"
                        },
                        "type": "String"
                      },
                      "sink_dataset": {
                        "value": {
                          "value": "@pipeline().parameters.P_DATASET",
                          "type": "Expression"
                        },
                        "type": "String"
                      },
                      "sink_metadata": {
                        "value": null,
                        "type": "String"
                      },
                      "sink_schema": {
                        "value": {
                          "value": "@pipeline().parameters.P_SINK_SCHEMA",
                          "type": "Expression"
                        },
                        "type": "String"
                      },
                      "sink_table": {
                        "value": {
                          "value": "@item().sink_table",
                          "type": "Expression"
                        },
                        "type": "String"
                      },
                      "source_database": {
                        "value": {
                          "value": "@pipeline().parameters.P_SOURCE_DATABASE",
                          "type": "Expression"
                        },
                        "type": "String"
                      },
                      "source_dataset": {
                        "value": {
                          "value": "@pipeline().parameters.P_DATASET",
                          "type": "Expression"
                        },
                        "type": "String"
                      },
                      "source_metadata": {
                        "value": null,
                        "type": "String"
                      },
                      "source_schema": {
                        "value": {
                          "value": "@pipeline().parameters.P_SOURCE_SCHEMA",
                          "type": "Expression"
                        },
                        "type": "String"
                      },
                      "source_table": {
                        "value": {
                          "value": "@item().source_table",
                          "type": "Expression"
                        },
                        "type": "String"
                      }
                    }
                  },
                  "linkedServiceName": {
                    "referenceName": "[parameters('azuresql_mask_metadata_store_db')]",
                    "type": "LinkedServiceReference"
                  }
                }
              ]
            }
          },
          {
            "name": "Capture Referential Constraints",
            "type": "Copy",
            "dependsOn": [],
            "policy": {
              "timeout": "0.12:00:00",
              "retry": 0,
              "retryIntervalInSeconds": 30,
              "secureOutput": false,
              "secureInput": false
            },
            "userProperties": [],
            "typeProperties": {
              "source": {
                "type": "AzureSqlSource",
                "sqlReaderQuery": {
                  "value": "SELECT \n    '@{pipeline().parameters.P_PARENT_RUN_ID}' AS pipeline_run_id,\n    '@{pipeline().parameters.P_DATASET}' AS dataset, \n    '@{pipeline().parameters.P_SINK_DATABASE}' AS specified_database, \n    '@{pipeline().parameters.P_SINK_SCHEMA}' AS specified_schema, \n    parent_table.name AS identified_parent_table, \n    child_table.name AS child_table, \n    fk.name AS constraint_name, \n    STUFF(\n        (\n            SELECT ',' + parent_col.name \n            FROM sys.foreign_key_columns AS fk_col \n            INNER JOIN sys.columns AS parent_col \n                ON fk_col.parent_object_id = parent_col.object_id \n                AND fk_col.parent_column_id = parent_col.column_id \n            WHERE fk_col.parent_object_id = fk.parent_object_id \n                AND fk_col.constraint_object_id = fk.object_id \n            FOR XML PATH(''), TYPE\n        ).value('.', 'NVARCHAR(MAX)'), \n        1, 1, ''\n    ) AS children_columns, \n    STUFF(\n        (\n            SELECT ',' + child_col.name \n            FROM sys.foreign_key_columns AS fk_col \n            INNER JOIN sys.columns AS child_col \n                ON fk_col.referenced_object_id = child_col.object_id \n                AND fk_col.referenced_column_id = child_col.column_id \n            WHERE fk_col.parent_object_id = fk.parent_object_id \n                AND fk_col.constraint_object_id = fk.object_id \n            FOR XML PATH(''), TYPE\n        ).value('.', 'NVARCHAR(MAX)'), \n        1, 1, ''\n    ) AS parent_columns, \n    CASE \n        WHEN fk.is_disabled = 0 THEN 'Enabled' \n        ELSE 'Disabled' \n    END AS pre_drop_status, \n    GETDATE() AS drop_timestamp, \n    'N/A' AS post_create_status\nFROM sys.foreign_keys AS fk \nINNER JOIN sys.tables AS child_table \n    ON fk.parent_object_id = child_table.object_id \nINNER JOIN sys.tables AS parent_table \n    ON fk.referenced_object_id = parent_table.object_id \nWHERE\n    LOWER(SCHEMA_NAME(parent_table.schema_id)) = LOWER('@{pipeline().parameters.P_SINK_SCHEMA}') ",
                  "type": "Expression"
                },
                "queryTimeout": "02:00:00",
                "partitionOption": "None"
              },
              "sink": {
                "type": "AzureSqlSink",
                "sqlWriterStoredProcedureName": {
                  "value": "@concat(pipeline().parameters.P_METADATA_SCHEMA, '.', pipeline().parameters.P_METADATA_INSERT_CONSTRAINT_PROCEDURE_NAME)",
                  "type": "Expression"
                },
                "sqlWriterTableType": "sink_drop_constraint_type",
                "storedProcedureTableTypeParameterName": "source",
                "disableMetricsCollection": false
              },
              "enableStaging": false,
              "translator": {
                "type": "TabularTranslator",
                "mappings": [
                  {
                    "source": {
                      "name": "pipeline_run_id",
                      "type": "String",
                      "physicalType": "varchar"
                    },
                    "sink": {
                      "name": "pipeline_run_id",
                      "type": "String",
                      "physicalType": "nvarchar"
                    }
                  },
                  {
                    "source": {
                      "name": "dataset",
                      "type": "String",
                      "physicalType": "varchar"
                    },
                    "sink": {
                      "name": "dataset",
                      "type": "String",
                      "physicalType": "nvarchar"
                    }
                  },
                  {
                    "source": {
                      "name": "specified_database",
                      "type": "String",
                      "physicalType": "varchar"
                    },
                    "sink": {
                      "name": "specified_database",
                      "type": "String",
                      "physicalType": "nvarchar"
                    }
                  },
                  {
                    "source": {
                      "name": "specified_schema",
                      "type": "String",
                      "physicalType": "varchar"
                    },
                    "sink": {
                      "name": "specified_schema",
                      "type": "String",
                      "physicalType": "nvarchar"
                    }
                  },
                  {
                    "source": {
                      "name": "identified_parent_table",
                      "type": "String",
                      "physicalType": "nvarchar"
                    },
                    "sink": {
                      "name": "identified_parent_table",
                      "type": "String",
                      "physicalType": "nvarchar"
                    }
                  },
                  {
                    "source": {
                      "name": "child_table",
                      "type": "String",
                      "physicalType": "nvarchar"
                    },
                    "sink": {
                      "name": "child_table",
                      "type": "String",
                      "physicalType": "nvarchar"
                    }
                  },
                  {
                    "source": {
                      "name": "constraint_name",
                      "type": "String",
                      "physicalType": "nvarchar"
                    },
                    "sink": {
                      "name": "constraint_name",
                      "type": "String",
                      "physicalType": "nvarchar"
                    }
                  },
                  {
                    "source": {
                      "name": "children_columns",
                      "type": "String",
                      "physicalType": "nvarchar"
                    },
                    "sink": {
                      "name": "children_columns",
                      "type": "String",
                      "physicalType": "nvarchar"
                    }
                  },
                  {
                    "source": {
                      "name": "parent_columns",
                      "type": "String",
                      "physicalType": "nvarchar"
                    },
                    "sink": {
                      "name": "parent_columns",
                      "type": "String",
                      "physicalType": "nvarchar"
                    }
                  },
                  {
                    "source": {
                      "name": "pre_drop_status",
                      "type": "String",
                      "physicalType": "varchar"
                    },
                    "sink": {
                      "name": "pre_drop_status",
                      "type": "String",
                      "physicalType": "nvarchar"
                    }
                  },
                  {
                    "source": {
                      "name": "drop_timestamp",
                      "type": "DateTime",
                      "physicalType": "datetime"
                    },
                    "sink": {
                      "name": "drop_timestamp",
                      "type": "DateTime",
                      "physicalType": "datetime"
                    }
                  },
                  {
                    "source": {
                      "name": "post_create_status",
                      "type": "String",
                      "physicalType": "varchar"
                    },
                    "sink": {
                      "name": "post_create_status",
                      "type": "String",
                      "physicalType": "nvarchar"
                    }
                  }
                ],
                "typeConversion": true,
                "typeConversionSettings": {
                  "allowDataTruncation": true,
                  "treatBooleanAsNumber": false
                }
              }
            },
            "inputs": [
              {
                "referenceName": "dcsazure_AzureSQL_to_AzureSQL_mask_sink_ds",
                "type": "DatasetReference",
                "parameters": {
                  "DS_SINK_SCHEMA": "-",
                  "DS_SINK_TABLE": "-",
                  "DS_SINK_DATABASE": {
                    "value": "@pipeline().parameters.P_SINK_DATABASE",
                    "type": "Expression"
                  }
                }
              }
            ],
            "outputs": [
              {
                "referenceName": "dcsazure_AzureSQL_to_AzureSQL_mask_metadata_ds",
                "type": "DatasetReference",
                "parameters": {
                  "DS_METADATA_SCHEMA": {
                    "value": "@pipeline().parameters.P_METADATA_SCHEMA",
                    "type": "Expression"
                  },
                  "DS_METADATA_TABLE": {
                    "value": "@pipeline().parameters.P_METADATA_CONSTRAINT_TABLE",
                    "type": "Expression"
                  }
                }
              }
            ]
          },
          {
            "name": "Select Discovered Constraints",
            "type": "Lookup",
            "dependsOn": [
              {
                "activity": "Capture Referential Constraints",
                "dependencyConditions": [
                  "Succeeded"
                ]
              }
            ],
            "policy": {
              "timeout": "0.12:00:00",
              "retry": 0,
              "retryIntervalInSeconds": 30,
              "secureOutput": false,
              "secureInput": false
            },
            "userProperties": [],
            "typeProperties": {
              "source": {
                "type": "AzureSqlSource",
                "sqlReaderQuery": {
                  "value": "WITH discovered_constraints AS (    \n    SELECT  \n        ct.specified_database AS specified_database, \n        ct.specified_schema AS specified_schema, \n        ct.identified_parent_table AS identified_parent_table, \n        ct.child_table AS child_table, \n        ct.constraint_name AS constraint_name, \n        ct.parent_columns AS parent_columns, \n        ct.children_columns AS children_columns, \n        ct.pre_drop_status AS pre_drop_status,\n        dm.source_table AS source_table,\n        dm.sink_table AS sink_table,\n        ROW_NUMBER() OVER (PARTITION BY ct.constraint_name ORDER BY dm.source_table) AS row_num\n    FROM \n        @{pipeline().parameters.P_METADATA_SCHEMA}.@{pipeline().parameters.P_METADATA_CONSTRAINT_TABLE} ct\n    JOIN @{pipeline().parameters.P_METADATA_SCHEMA}.@{pipeline().parameters.P_METADATA_SOURCE_TO_SINK_MAPPING_TABLE} dm\n    ON \n        ct.dataset = dm.sink_dataset \n        AND ct.specified_database = dm.sink_database \n        AND ct.specified_schema = dm.sink_schema \n        AND (\n            ct.identified_parent_table = dm.sink_table OR\n            ct.child_table = dm.sink_table \n        )\n    WHERE\n        pipeline_run_id = '@{pipeline().parameters.P_PARENT_RUN_ID}'\n        AND LOWER(ct.specified_database) = LOWER('@{pipeline().parameters.P_SINK_DATABASE}')\n        AND LOWER(ct.specified_schema) = LOWER('@{pipeline().parameters.P_SINK_SCHEMA}')\n        AND dataset = '@{pipeline().parameters.P_DATASET}'\n        AND (dm.mapping_complete IS NULL OR dm.mapping_complete = 0)\n        AND (ISJSON(dm.masked_status) = 0 OR dm.masked_status IS NULL)\n)\nSELECT \n    specified_database, \n    specified_schema, \n    identified_parent_table, \n    child_table, \n    constraint_name, \n    parent_columns, \n    children_columns, \n    pre_drop_status,\n    source_table,\n    sink_table\nFROM \n    discovered_constraints\nWHERE\n    row_num = 1",
                  "type": "Expression"
                },
                "queryTimeout": "02:00:00",
                "partitionOption": "None"
              },
              "dataset": {
                "referenceName": "dcsazure_AzureSQL_to_AzureSQL_mask_metadata_ds",
                "type": "DatasetReference",
                "parameters": {
                  "DS_METADATA_SCHEMA": {
                    "value": "@pipeline().parameters.P_METADATA_SCHEMA",
                    "type": "Expression"
                  },
                  "DS_METADATA_TABLE": {
                    "value": "@pipeline().parameters.P_METADATA_CONSTRAINT_TABLE",
                    "type": "Expression"
                  }
                }
              },
              "firstRowOnly": false
            }
          }
        ],
        "policy": {
          "elapsedTimeMetric": {}
        },
        "parameters": {
          "P_SOURCE_DATABASE": {
            "type": "string"
          },
          "P_SINK_DATABASE": {
            "type": "string"
          },
          "P_SOURCE_SCHEMA": {
            "type": "string"
          },
          "P_SINK_SCHEMA": {
            "type": "string"
          },
          "P_DATASET": {
            "type": "string",
            "defaultValue": "AZURESQL"
          },
          "P_METADATA_CONSTRAINT_TABLE": {
            "type": "string",
            "defaultValue": "capture_constraints"
          },
          "P_METADATA_SCHEMA": {
            "type": "string",
            "defaultValue": "dbo"
          },
          "P_METADATA_SOURCE_TO_SINK_MAPPING_TABLE": {
            "type": "string",
            "defaultValue": "adf_data_mapping"
          },
          "P_METADATA_EVENT_PROCEDURE_NAME": {
            "type": "string",
            "defaultValue": "insert_adf_masking_event"
          },
          "P_PARENT_RUN_ID": {
            "type": "string"
          },
          "P_METADATA_INSERT_CONSTRAINT_PROCEDURE_NAME": {
            "type": "string",
            "defaultValue": "insert_constraints"
          }
        },
        "folder": {
          "name": "dcsazure_AzureSQL_to_AzureSQL"
        },
        "annotations": [],
        "lastPublishTime": "2025-10-08T06:38:20Z"
      },
      "dependsOn": [
        "[concat(variables('factoryId'), '/datasets/dcsazure_AzureSQL_to_AzureSQL_mask_sink_ds')]",
        "[concat(variables('factoryId'), '/datasets/dcsazure_AzureSQL_to_AzureSQL_mask_metadata_ds')]"
      ]
    },
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_AzureSQL_to_AzureSQL_mask_create_constraint_pl')]",
      "type": "Microsoft.DataFactory/factories/pipelines",
      "apiVersion": "2018-06-01",
      "properties": {
        "activities": [
          {
            "name": "For Each Constraint To Create",
            "description": "Create constraints for all tables in sink schema",
            "type": "ForEach",
            "dependsOn": [
              {
                "activity": "Select Discovered Constraints",
                "dependencyConditions": [
                  "Succeeded"
                ]
              }
            ],
            "userProperties": [],
            "typeProperties": {
              "items": {
                "value": "@activity('Select Discovered Constraints').output.value",
                "type": "Expression"
              },
              "activities": [
                {
                  "name": "Create Constraint",
                  "type": "Script",
                  "dependsOn": [],
                  "policy": {
                    "timeout": "0.12:00:00",
                    "retry": 0,
                    "retryIntervalInSeconds": 30,
                    "secureOutput": false,
                    "secureInput": false
                  },
                  "userProperties": [],
                  "linkedServiceName": {
                    "referenceName": "[parameters('azuresql_mask_sink_db')]",
                    "type": "LinkedServiceReference",
                    "parameters": {
                      "LS_DATABASE": {
                        "value": "@pipeline().parameters.P_SINK_DATABASE",
                        "type": "Expression"
                      }
                    }
                  },
                  "typeProperties": {
                    "scripts": [
                      {
                        "type": "Query",
                        "text": {
                          "value": "@concat('IF (OBJECT_ID(''',item().specified_schema, '.',item().constraint_name,''') IS NULL) BEGIN ALTER TABLE [', item().specified_schema, '].[', item().child_table,'] ADD CONSTRAINT ', item().constraint_name,' FOREIGN KEY (',item().children_columns,') REFERENCES [',item().specified_schema, '].[', item().identified_parent_table, '] (', item().parent_columns,'); ', if(equals(toLower(item().pre_drop_status), toLower('Disabled')), concat('ALTER TABLE [', item().specified_schema, '].[', item().child_table, '] NOCHECK CONSTRAINT ', item().constraint_name, '; '), ''), ' END ')",
                          "type": "Expression"
                        }
                      }
                    ],
                    "scriptBlockExecutionTimeout": "02:00:00"
                  }
                },
                {
                  "name": "Update Create Constraint error",
                  "description": "Log the error message encountered during the Create Constraint activity in the database",
                  "type": "Script",
                  "dependsOn": [
                    {
                      "activity": "Create Constraint",
                      "dependencyConditions": [
                        "Failed"
                      ]
                    }
                  ],
                  "policy": {
                    "timeout": "0.12:00:00",
                    "retry": 0,
                    "retryIntervalInSeconds": 30,
                    "secureOutput": false,
                    "secureInput": false
                  },
                  "userProperties": [],
                  "linkedServiceName": {
                    "referenceName": "[parameters('azuresql_mask_metadata_store_db')]",
                    "type": "LinkedServiceReference"
                  },
                  "typeProperties": {
                    "scripts": [
                      {
                        "type": "Query",
                        "text": {
                          "value": "UPDATE @{pipeline().parameters.P_METADATA_SCHEMA}.@{pipeline().parameters.P_METADATA_CONSTRAINT_TABLE}\nSET create_error_message = @{concat('''', replace(activity('Create Constraint').Error.message, '''', ''''''), '''')},\ncreate_timestamp = GETDATE()\nWHERE pipeline_run_id = '@{pipeline().parameters.P_PARENT_RUN_ID}'\n    AND dataset = '@{pipeline().parameters.P_DATASET}'\n    AND specified_database = '@{pipeline().parameters.P_SINK_DATABASE}'\n    AND specified_schema = '@{pipeline().parameters.P_SINK_SCHEMA}'\n    AND identified_parent_table = '@{item().identified_parent_table}'\n    AND child_table = '@{item().child_table}'\n    AND constraint_name = '@{item().constraint_name}'",
                          "type": "Expression"
                        }
                      }
                    ],
                    "scriptBlockExecutionTimeout": "02:00:00"
                  }
                },
                {
                  "name": "Fail on Create Constraint Error",
                  "description": "Fail on Create Constraint Error",
                  "type": "Fail",
                  "dependsOn": [
                    {
                      "activity": "Update Create Constraint error",
                      "dependencyConditions": [
                        "Succeeded"
                      ]
                    }
                  ],
                  "userProperties": [],
                  "typeProperties": {
                    "message": {
                      "value": "Failed to create constraint @{item().constraint_name} on @{item().child_table}",
                      "type": "Expression"
                    },
                    "errorCode": "500"
                  }
                }
              ]
            }
          },
          {
            "name": "Capture Referential Constraints Status",
            "type": "Copy",
            "dependsOn": [
              {
                "activity": "For Each Constraint To Create",
                "dependencyConditions": [
                  "Completed"
                ]
              }
            ],
            "policy": {
              "timeout": "0.12:00:00",
              "retry": 0,
              "retryIntervalInSeconds": 30,
              "secureOutput": false,
              "secureInput": false
            },
            "userProperties": [],
            "typeProperties": {
              "source": {
                "type": "AzureSqlSource",
                "sqlReaderQuery": {
                  "value": "SELECT \n    '@{pipeline().parameters.P_PARENT_RUN_ID}' AS pipeline_run_id,\n    '@{pipeline().parameters.P_DATASET}' AS dataset, \n    '@{pipeline().parameters.P_SINK_DATABASE}' AS specified_database, \n    '@{pipeline().parameters.P_SINK_SCHEMA}' AS specified_schema, \n    parent_table.name AS identified_parent_table, \n    child_table.name AS child_table, \n    fk.name AS constraint_name, \n    STUFF(\n        (\n            SELECT ',' + parent_col.name \n            FROM sys.foreign_key_columns AS fk_col \n            INNER JOIN sys.columns AS parent_col \n                ON fk_col.parent_object_id = parent_col.object_id \n                AND fk_col.parent_column_id = parent_col.column_id \n            WHERE fk_col.parent_object_id = fk.parent_object_id \n                AND fk_col.constraint_object_id = fk.object_id \n            FOR XML PATH(''), TYPE\n        ).value('.', 'NVARCHAR(MAX)'), \n        1, 1, ''\n    ) AS children_columns, \n    STUFF(\n        (\n            SELECT ',' + child_col.name \n            FROM sys.foreign_key_columns AS fk_col \n            INNER JOIN sys.columns AS child_col \n                ON fk_col.referenced_object_id = child_col.object_id \n                AND fk_col.referenced_column_id = child_col.column_id \n            WHERE fk_col.parent_object_id = fk.parent_object_id \n                AND fk_col.constraint_object_id = fk.object_id \n            FOR XML PATH(''), TYPE\n        ).value('.', 'NVARCHAR(MAX)'), \n        1, 1, ''\n    ) AS parent_columns, \n    CASE \n        WHEN fk.is_disabled = 0 THEN 'Enabled' \n        ELSE 'Disabled' \n    END AS post_create_status, \n    GETDATE() AS create_timestamp\nFROM sys.foreign_keys AS fk \nINNER JOIN sys.tables AS child_table \n    ON fk.parent_object_id = child_table.object_id \nINNER JOIN sys.tables AS parent_table \n    ON fk.referenced_object_id = parent_table.object_id \nWHERE\n    LOWER(SCHEMA_NAME(parent_table.schema_id)) = LOWER('@{pipeline().parameters.P_SINK_SCHEMA}') ",
                  "type": "Expression"
                },
                "queryTimeout": "02:00:00",
                "partitionOption": "None"
              },
              "sink": {
                "type": "AzureSqlSink",
                "sqlWriterStoredProcedureName": {
                  "value": "@concat(pipeline().parameters.P_METADATA_SCHEMA, '.', pipeline().parameters.P_METADATA_UPDATE_CONSTRAINT_PROCEDURE_NAME)",
                  "type": "Expression"
                },
                "sqlWriterTableType": "sink_create_constraint_type",
                "storedProcedureTableTypeParameterName": "source",
                "disableMetricsCollection": false
              },
              "enableStaging": false,
              "translator": {
                "type": "TabularTranslator",
                "mappings": [
                  {
                    "source": {
                      "name": "pipeline_run_id",
                      "type": "String",
                      "physicalType": "varchar"
                    },
                    "sink": {
                      "name": "pipeline_run_id",
                      "type": "String",
                      "physicalType": "nvarchar"
                    }
                  },
                  {
                    "source": {
                      "name": "dataset",
                      "type": "String",
                      "physicalType": "varchar"
                    },
                    "sink": {
                      "name": "dataset",
                      "type": "String",
                      "physicalType": "nvarchar"
                    }
                  },
                  {
                    "source": {
                      "name": "specified_database",
                      "type": "String",
                      "physicalType": "varchar"
                    },
                    "sink": {
                      "name": "specified_database",
                      "type": "String",
                      "physicalType": "nvarchar"
                    }
                  },
                  {
                    "source": {
                      "name": "specified_schema",
                      "type": "String",
                      "physicalType": "varchar"
                    },
                    "sink": {
                      "name": "specified_schema",
                      "type": "String",
                      "physicalType": "nvarchar"
                    }
                  },
                  {
                    "source": {
                      "name": "identified_parent_table",
                      "type": "String",
                      "physicalType": "nvarchar"
                    },
                    "sink": {
                      "name": "identified_parent_table",
                      "type": "String",
                      "physicalType": "nvarchar"
                    }
                  },
                  {
                    "source": {
                      "name": "child_table",
                      "type": "String",
                      "physicalType": "nvarchar"
                    },
                    "sink": {
                      "name": "child_table",
                      "type": "String",
                      "physicalType": "nvarchar"
                    }
                  },
                  {
                    "source": {
                      "name": "constraint_name",
                      "type": "String",
                      "physicalType": "nvarchar"
                    },
                    "sink": {
                      "name": "constraint_name",
                      "type": "String",
                      "physicalType": "nvarchar"
                    }
                  },
                  {
                    "source": {
                      "name": "children_columns",
                      "type": "String",
                      "physicalType": "nvarchar"
                    },
                    "sink": {
                      "name": "children_columns",
                      "type": "String",
                      "physicalType": "nvarchar"
                    }
                  },
                  {
                    "source": {
                      "name": "parent_columns",
                      "type": "String",
                      "physicalType": "nvarchar"
                    },
                    "sink": {
                      "name": "parent_columns",
                      "type": "String",
                      "physicalType": "nvarchar"
                    }
                  },
                  {
                    "source": {
                      "name": "post_create_status",
                      "type": "String",
                      "physicalType": "varchar"
                    },
                    "sink": {
                      "name": "post_create_status",
                      "type": "String",
                      "physicalType": "nvarchar"
                    }
                  },
                  {
                    "source": {
                      "name": "create_timestamp",
                      "type": "DateTime",
                      "physicalType": "datetime"
                    },
                    "sink": {
                      "name": "create_timestamp",
                      "type": "DateTime",
                      "physicalType": "datetime"
                    }
                  }
                ],
                "typeConversion": true,
                "typeConversionSettings": {
                  "allowDataTruncation": true,
                  "treatBooleanAsNumber": false
                }
              }
            },
            "inputs": [
              {
                "referenceName": "dcsazure_AzureSQL_to_AzureSQL_mask_sink_ds",
                "type": "DatasetReference",
                "parameters": {
                  "DS_SINK_SCHEMA": "-",
                  "DS_SINK_TABLE": "-",
                  "DS_SINK_DATABASE": {
                    "value": "@pipeline().parameters.P_SINK_DATABASE",
                    "type": "Expression"
                  }
                }
              }
            ],
            "outputs": [
              {
                "referenceName": "dcsazure_AzureSQL_to_AzureSQL_mask_metadata_ds",
                "type": "DatasetReference",
                "parameters": {
                  "DS_METADATA_SCHEMA": {
                    "value": "@pipeline().parameters.P_METADATA_SCHEMA",
                    "type": "Expression"
                  },
                  "DS_METADATA_TABLE": {
                    "value": "@pipeline().parameters.P_METADATA_CONSTRAINT_TABLE",
                    "type": "Expression"
                  }
                }
              }
            ]
          },
          {
            "name": "Select Discovered Constraints",
            "type": "Lookup",
            "dependsOn": [],
            "policy": {
              "timeout": "0.12:00:00",
              "retry": 0,
              "retryIntervalInSeconds": 30,
              "secureOutput": false,
              "secureInput": false
            },
            "userProperties": [],
            "typeProperties": {
              "source": {
                "type": "AzureSqlSource",
                "sqlReaderQuery": {
                  "value": "WITH discovered_constraints AS (\n    SELECT  \n        ct.specified_database AS specified_database, \n        ct.specified_schema AS specified_schema, \n        ct.identified_parent_table AS identified_parent_table, \n        ct.child_table AS child_table, \n        ct.constraint_name AS constraint_name, \n        ct.parent_columns AS parent_columns, \n        ct.children_columns AS children_columns, \n        ct.pre_drop_status AS pre_drop_status,\n        dm.source_table AS source_table,\n        dm.sink_table AS sink_table,\n        ROW_NUMBER() OVER (PARTITION BY ct.constraint_name ORDER BY dm.source_table) AS row_num\n    FROM \n        @{pipeline().parameters.P_METADATA_SCHEMA}.@{pipeline().parameters.P_METADATA_CONSTRAINT_TABLE} ct\n    JOIN @{pipeline().parameters.P_METADATA_SCHEMA}.@{pipeline().parameters.P_METADATA_SOURCE_TO_SINK_MAPPING_TABLE} dm\n    ON \n        ct.dataset = dm.sink_dataset \n        AND ct.specified_database = dm.sink_database \n        AND ct.specified_schema = dm.sink_schema \n        AND (\n            ct.identified_parent_table = dm.sink_table OR\n            ct.child_table = dm.sink_table \n        )\n    WHERE\n        pipeline_run_id = '@{pipeline().parameters.P_PARENT_RUN_ID}'\n        AND LOWER(ct.specified_database) = LOWER('@{pipeline().parameters.P_SINK_DATABASE}')\n        AND LOWER(ct.specified_schema) = LOWER('@{pipeline().parameters.P_SINK_SCHEMA}')\n        AND dataset = '@{pipeline().parameters.P_DATASET}'\n)\nSELECT\n    specified_database,\n    specified_schema,\n    identified_parent_table, \n    child_table, \n    constraint_name, \n    parent_columns, \n    children_columns, \n    pre_drop_status,\n    source_table,\n    sink_table\nFROM \n    discovered_constraints\nWHERE\n    row_num = 1",
                  "type": "Expression"
                },
                "queryTimeout": "02:00:00",
                "partitionOption": "None"
              },
              "dataset": {
                "referenceName": "dcsazure_AzureSQL_to_AzureSQL_mask_metadata_ds",
                "type": "DatasetReference",
                "parameters": {
                  "DS_METADATA_SCHEMA": {
                    "value": "@pipeline().parameters.P_METADATA_SCHEMA",
                    "type": "Expression"
                  },
                  "DS_METADATA_TABLE": {
                    "value": "@pipeline().parameters.P_METADATA_CONSTRAINT_TABLE",
                    "type": "Expression"
                  }
                }
              },
              "firstRowOnly": false
            }
          }
        ],
        "policy": {
          "elapsedTimeMetric": {}
        },
        "parameters": {
          "P_SOURCE_DATABASE": {
            "type": "string"
          },
          "P_SINK_DATABASE": {
            "type": "string"
          },
          "P_SOURCE_SCHEMA": {
            "type": "string"
          },
          "P_SINK_SCHEMA": {
            "type": "string"
          },
          "P_METADATA_SCHEMA": {
            "type": "string",
            "defaultValue": "dbo"
          },
          "P_METADATA_CONSTRAINT_TABLE": {
            "type": "string",
            "defaultValue": "capture_constraints"
          },
          "P_DATASET": {
            "type": "string",
            "defaultValue": "AZURESQL"
          },
          "P_METADATA_SOURCE_TO_SINK_MAPPING_TABLE": {
            "type": "string",
            "defaultValue": "adf_data_mapping"
          },
          "P_METADATA_EVENT_PROCEDURE_NAME": {
            "type": "string",
            "defaultValue": "insert_adf_masking_event"
          },
          "P_PARENT_RUN_ID": {
            "type": "string"
          },
          "P_METADATA_UPDATE_CONSTRAINT_PROCEDURE_NAME": {
            "type": "string",
            "defaultValue": "update_constraints_status"
          }
        },
        "folder": {
          "name": "dcsazure_AzureSQL_to_AzureSQL"
        },
        "annotations": [],
        "lastPublishTime": "2025-10-08T06:38:20Z"
      },
      "dependsOn": [
        "[concat(variables('factoryId'), '/datasets/dcsazure_AzureSQL_to_AzureSQL_mask_sink_ds')]",
        "[concat(variables('factoryId'), '/datasets/dcsazure_AzureSQL_to_AzureSQL_mask_metadata_ds')]"
      ]
    },
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_AzureSQL_to_AzureSQL_mask_sink_ds')]",
      "type": "Microsoft.DataFactory/factories/datasets",
      "apiVersion": "2018-06-01",
      "properties": {
        "linkedServiceName": {
          "referenceName": "[parameters('azuresql_mask_sink_db')]",
          "type": "LinkedServiceReference",
          "parameters": {
            "LS_DATABASE": {
              "value": "@dataset().DS_SINK_DATABASE",
              "type": "Expression"
            }
          }
        },
        "parameters": {
          "DS_SINK_SCHEMA": {
            "type": "string"
          },
          "DS_SINK_TABLE": {
            "type": "string"
          },
          "DS_SINK_DATABASE": {
            "type": "string"
          }
        },
        "folder": {
          "name": "dcsazure_AzureSQL_to_AzureSQL"
        },
        "annotations": [],
        "type": "AzureSqlTable",
        "schema": [],
        "typeProperties": {
          "schema": {
            "value": "@dataset().DS_SINK_SCHEMA",
            "type": "Expression"
          },
          "table": {
            "value": "@dataset().DS_SINK_TABLE",
            "type": "Expression"
          }
        }
      },
      "dependsOn": []
    },
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_AzureSQL_to_AzureSQL_unfiltered_mask_df')]",
      "type": "Microsoft.DataFactory/factories/dataflows",
      "apiVersion": "2018-06-01",
      "properties": {
        "folder": {
          "name": "dcsazure_AzureSQL_to_AzureSQL"
        },
        "type": "MappingDataFlow",
        "typeProperties": {
          "sources": [
            {
              "linkedService": {
                "referenceName": "[parameters('azuresql_mask_source_db')]",
                "type": "LinkedServiceReference"
              },
              "name": "Source",
              "description": "Select source data at DF_SOURCE_SCHEMA.DF_SOURCE_TABLE using an inline dataset"
            }
          ],
          "sinks": [
            {
              "linkedService": {
                "referenceName": "[parameters('azuresql_mask_sink_db')]",
                "type": "LinkedServiceReference"
              },
              "name": "Sink",
              "description": "Sink results of masking to data store by sinking the unrolled results of the masking call to the columns of the same name in the data sink"
            }
          ],
          "transformations": [
            {
              "name": "DCSForAzureAPI",
              "linkedService": {
                "referenceName": "[parameters('ProdDCSForAzureService')]",
                "type": "LinkedServiceReference"
              }
            },
            {
              "name": "AddSortKey",
              "description": "Create column DELPHIX_COMPLIANCE_SERVICE_SORT_ID that consists of SHA of the data across all columns in the table - every row will have this value and it cannot be null"
            },
            {
              "name": "SortBySortKey",
              "description": "Sort the table by the value in DELPHIX_COMPLIANCE_SERVICE_SORT_ID, as we need the table to be in a particular order before we apply a surrogate key"
            },
            {
              "name": "CreateSurrogateKey",
              "description": "Add a DELPHIX_COMPLIANCE_SERVICE_BATCH_ID column that increments by 1 and starts at 1 after applying the sorting"
            },
            {
              "name": "WrapValuesInArray",
              "description": "For each column we wish to mask, convert the value into an array, this is needed to preserve null values as null when using collect, as null values become [], and encode the column names to handle body type mapping changes"
            },
            {
              "name": "SelectColumnsUnmasked",
              "description": "Select only columns that don't require masking"
            },
            {
              "name": "AggregateColumnsByBatch",
              "description": "For each column we wish to mask, aggregate to a list using collect, grouped by DELPHIX_COMPLIANCE_SERVICE_BATCH_ID with integer division by DF_NUMBER_OF_ROWS_PER_BATCH - so there will be a targeted number of total rows in each aggregation, name the group as DELPHIX_COMPLIANCE_SERVICE_BATCH_GROUP"
            },
            {
              "name": "FlattenValuesOutOfArray",
              "description": "For each column we wish to mask, flatten the value out of the array, in the case where the value was previously [], it becomes null"
            },
            {
              "name": "AssertNoFailures",
              "description": "Confirm that we received a 200 response status from the API request"
            },
            {
              "name": "FlattenAggregateData",
              "description": "Unroll the API response body into decoded named columns"
            },
            {
              "name": "JoinMaskedAndUnmaskedData",
              "description": "Inner join on SelectColumnsUnmasked and TrimMaskedStrings based on matching DELPHIX_COMPLIANCE_SERVICE_BATCH_ID"
            },
            {
              "name": "TrimMaskedStrings",
              "description": "For each column with a string type, trim the string to length based on the value in DF_TRIM_LENGTHS - this is needed as masking a string may produce a longer string that exceeds the column width in the sink"
            },
            {
              "name": "CastColumnsBackAsRequired",
              "description": "For columns that need to be cast back to a compatible type, cast them back"
            },
            {
              "name": "CastRequiredColumnsAsStrings",
              "description": "For columns that require casting to string, cast them to string"
            }
          ],
          "scriptLines": [
            "parameters{",
            "     runId as string (''),",
            "     DF_SOURCE_SCHEMA as string (''),",
            "     DF_SOURCE_TABLE as string (''),",
            "     DF_SINK_SCHEMA as string (''),",
            "     DF_SINK_TABLE as string (''),",
            "     DF_FIELD_ALGORITHM_ASSIGNMENT as string ('{}'),",
            "     DF_COLUMNS_TO_MASK as string[] ([\"\"]),",
            "     DF_BODY_TYPE_MAPPING as string ('(timestamp as date, status as string, message as string, trace_id as string, items as (DELPHIX_COMPLIANCE_SERVICE_BATCH_ID as long)[])'),",
            "     DF_NUMBER_OF_ROWS_PER_BATCH as integer (1000),",
            "     DF_TRIM_LENGTHS as integer[] ([1000]),",
            "     DF_FAIL_ON_NONCONFORMANT_DATA as boolean (true()),",
            "     DF_FIELD_DATE_FORMAT as string ('{}'),",
            "     DF_COLUMNS_TO_CAST_AS_STRINGS as string[] ([\"\"]),",
            "     DF_COLUMNS_TO_CAST_BACK_TO_BINARY as string[] ([\"\"]),",
            "     DF_COLUMNS_TO_CAST_BACK_TO_BOOLEAN as string[] ([\"\"]),",
            "     DF_COLUMNS_TO_CAST_BACK_TO_DATE as string[] ([\"\"]),",
            "     DF_COLUMNS_TO_CAST_BACK_TO_DOUBLE as string[] ([\"\"]),",
            "     DF_COLUMNS_TO_CAST_BACK_TO_FLOAT as string[] ([\"\"]),",
            "     DF_COLUMNS_TO_CAST_BACK_TO_INTEGER as string[] ([\"\"]),",
            "     DF_COLUMNS_TO_CAST_BACK_TO_LONG as string[] ([\"\"]),",
            "     DF_COLUMNS_TO_CAST_BACK_TO_TIMESTAMP as string[] ([\"\"]),",
            "     DF_NUMBER_OF_BATCHES as integer (100)",
            "}",
            "source(allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'table',",
            "     store: 'sqlserver',",
            "     schemaName: ($DF_SOURCE_SCHEMA),",
            "     tableName: ($DF_SOURCE_TABLE),",
            "     isolationLevel: 'READ_UNCOMMITTED',",
            "     partitionBy('roundRobin', 32)) ~> Source",
            "FlattenValuesOutOfArray call(mapColumn(",
            "          each(match(name!='DELPHIX_COMPLIANCE_SERVICE_BATCH_GROUP'))",
            "     ),",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true,",
            "     output(",
            "          headers as [string,string],",
            "          body as (timestamp as date, status as string, message as string, trace_id as string, items as (DELPHIX_COMPLIANCE_SERVICE_BATCH_ID as long)[]),",
            "          status as string",
            "     ),",
            "     allowSchemaDrift: true,",
            "     format: 'rest',",
            "     store: 'restservice',",
            "     timeout: 30,",
            "     requestInterval: 0,",
            "     headers = ['Run-Id' -> $runId, 'Field-Algorithm-Assignment' -> $DF_FIELD_ALGORITHM_ASSIGNMENT, 'Fail-On-Non-Conformant-Data' -> iif($DF_FAIL_ON_NONCONFORMANT_DATA,'true','false'), 'Field-Date-Format' -> $DF_FIELD_DATE_FORMAT],",
            "     httpMethod: 'POST',",
            "     entity: '/v1/masking/batchMaskByColumn',",
            "     headerColumnName: 'headers',",
            "     bodyColumnName: 'body',",
            "     statusColumnName: 'status',",
            "     addResponseCode: true,",
            "     requestFormat: ['type' -> 'json'],",
            "     responseFormat: ['type' -> 'json', 'documentForm' -> 'documentPerLine'],",
            "     columnTypeMap: ['body'->'$DF_BODY_TYPE_MAPPING']) ~> DCSForAzureAPI",
            "Source derive(DELPHIX_COMPLIANCE_SERVICE_SORT_ID = sha2(256, columns())) ~> AddSortKey",
            "AddSortKey sort(asc(DELPHIX_COMPLIANCE_SERVICE_SORT_ID, false)) ~> SortBySortKey",
            "SortBySortKey keyGenerate(output(DELPHIX_COMPLIANCE_SERVICE_BATCH_ID as long),",
            "     startAt: 1L,",
            "     stepValue: 1L) ~> CreateSurrogateKey",
            "CastRequiredColumnsAsStrings derive(each(match(contains($DF_COLUMNS_TO_MASK,#item==name)), concat('x',hex(encode($$))) = array($$))) ~> WrapValuesInArray",
            "CreateSurrogateKey select(mapColumn(",
            "          each(match(!contains($DF_COLUMNS_TO_MASK,#item==name)))",
            "     ),",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true) ~> SelectColumnsUnmasked",
            "WrapValuesInArray aggregate(groupBy(DELPHIX_COMPLIANCE_SERVICE_BATCH_GROUP = DELPHIX_COMPLIANCE_SERVICE_BATCH_ID%$DF_NUMBER_OF_BATCHES),",
            "     each(match((startsWith(name,'x')&&not(contains($DF_COLUMNS_TO_MASK,#item==name)))||(name==\"DELPHIX_COMPLIANCE_SERVICE_BATCH_ID\")), $$ = collect($$))) ~> AggregateColumnsByBatch",
            "AggregateColumnsByBatch derive(each(match(startsWith(name,'x')||(name==\"DELPHIX_COMPLIANCE_SERVICE_BATCH_ID\")), $$ = flatten($$))) ~> FlattenValuesOutOfArray",
            "DCSForAzureAPI assert(expectTrue(toInteger(regexExtract(status, '(\\\\d+)', 1)) == 200, false, 'Failed_request', null, iif(isNull(body.message), status, concatWS(', ', 'timestamp: ' + toString(body.timestamp), 'status: ' + body.status, 'message: ' + body.message, 'trace_id: ' + body.trace_id))),",
            "     abort: true) ~> AssertNoFailures",
            "AssertNoFailures foldDown(unroll(body.items),",
            "     mapColumn(",
            "          every(body.items,match(name==\"DELPHIX_COMPLIANCE_SERVICE_BATCH_ID\")),",
            "          every(body.items,match(startsWith(name,'x')),",
            "               decode(unhex(replace($$,'x',''))) = $$)",
            "     ),",
            "     skipDuplicateMapInputs: false,",
            "     skipDuplicateMapOutputs: false) ~> FlattenAggregateData",
            "SelectColumnsUnmasked, TrimMaskedStrings join(SelectColumnsUnmasked@DELPHIX_COMPLIANCE_SERVICE_BATCH_ID == FlattenAggregateData@DELPHIX_COMPLIANCE_SERVICE_BATCH_ID,",
            "     joinType:'inner',",
            "     matchType:'exact',",
            "     ignoreSpaces: false,",
            "     broadcast: 'off')~> JoinMaskedAndUnmaskedData",
            "CastColumnsBackAsRequired derive(each(match(type=='string'), $$ = iif(greater($DF_TRIM_LENGTHS[toInteger($# - 1)], 0), substring($$, 1, $DF_TRIM_LENGTHS[toInteger($# - 1)]), toString($$)))) ~> TrimMaskedStrings",
            "FlattenAggregateData derive(each(match(contains($DF_COLUMNS_TO_CAST_BACK_TO_BINARY,#item==name)), $$ = toBinary($$)),",
            "          each(match(contains($DF_COLUMNS_TO_CAST_BACK_TO_BOOLEAN,#item==name)), $$ = toBoolean($$)),",
            "          each(match(contains($DF_COLUMNS_TO_CAST_BACK_TO_DATE,#item==name)), $$ = toDate(toString($$))),",
            "          each(match(contains($DF_COLUMNS_TO_CAST_BACK_TO_DOUBLE,#item==name)), $$ = toDouble($$)),",
            "          each(match(contains($DF_COLUMNS_TO_CAST_BACK_TO_FLOAT,#item==name)), $$ = toFloat($$)),",
            "          each(match(contains($DF_COLUMNS_TO_CAST_BACK_TO_INTEGER,#item==name)), $$ = toInteger($$)),",
            "          each(match(contains($DF_COLUMNS_TO_CAST_BACK_TO_LONG,#item==name)), $$ = toLong($$)),",
            "          each(match(contains($DF_COLUMNS_TO_CAST_BACK_TO_TIMESTAMP,#item==name)), $$ = toTimestamp(toString($$)))) ~> CastColumnsBackAsRequired",
            "CreateSurrogateKey derive(each(match(contains($DF_COLUMNS_TO_CAST_AS_STRINGS,#item==name)), $$ = toString($$))) ~> CastRequiredColumnsAsStrings",
            "JoinMaskedAndUnmaskedData sink(allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'table',",
            "     store: 'sqlserver',",
            "     schemaName: ($DF_SINK_SCHEMA),",
            "     tableName: ($DF_SINK_TABLE),",
            "     preSQLs:[(concat(\"IF EXISTS (SELECT 1 FROM sys.columns WHERE object_id = OBJECT_ID('\", $DF_SINK_SCHEMA, \"' + '.' + '\", $DF_SINK_TABLE, \"') AND is_identity = 1) BEGIN \", 'SET IDENTITY_INSERT', ' ', $DF_SINK_SCHEMA, '.', $DF_SINK_TABLE, ' ', 'ON; END'))],",
            "     insertable: true,",
            "     updateable: false,",
            "     deletable: false,",
            "     upsertable: false,",
            "     postSQLs:[(concat(\"IF EXISTS (SELECT 1 FROM sys.columns WHERE object_id = OBJECT_ID('\", $DF_SINK_SCHEMA, \"' + '.' + '\", $DF_SINK_TABLE, \"') AND is_identity = 1) BEGIN \", 'SET IDENTITY_INSERT', ' ', $DF_SINK_SCHEMA, '.', $DF_SINK_TABLE, ' ', 'OFF; END'))],",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true,",
            "     errorHandlingOption: 'stopOnFirstError',",
            "     mapColumn(",
            "          each(match(name!=\"DELPHIX_COMPLIANCE_SERVICE_BATCH_ID\"&&name!=\"DELPHIX_COMPLIANCE_SERVICE_SORT_ID\"))",
            "     ),",
            "     preCommands: [],",
            "     postCommands: []) ~> Sink"
          ]
        }
      },
      "dependsOn": []
    },
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_AzureSQL_to_AzureSQL_filtered_mask_df')]",
      "type": "Microsoft.DataFactory/factories/dataflows",
      "apiVersion": "2018-06-01",
      "properties": {
        "folder": {
          "name": "dcsazure_AzureSQL_to_AzureSQL"
        },
        "type": "MappingDataFlow",
        "typeProperties": {
          "sources": [
            {
              "linkedService": {
                "referenceName": "[parameters('azuresql_mask_source_db')]",
                "type": "LinkedServiceReference"
              },
              "name": "Source",
              "description": "Select source data at DF_SOURCE_SCHEMA.DF_SOURCE_TABLE using an inline dataset"
            }
          ],
          "sinks": [
            {
              "linkedService": {
                "referenceName": "[parameters('azuresql_mask_sink_db')]",
                "type": "LinkedServiceReference"
              },
              "name": "Sink",
              "description": "Sink results of masking to data store by sinking the unrolled results of the masking call to the columns of the same name in the data sink"
            }
          ],
          "transformations": [
            {
              "name": "DCSForAzureAPI",
              "linkedService": {
                "referenceName": "[parameters('ProdDCSForAzureService')]",
                "type": "LinkedServiceReference"
              }
            },
            {
              "name": "AddSortKey",
              "description": "Create column DELPHIX_COMPLIANCE_SERVICE_SORT_ID that consists of SHA of the data across all columns in the table - every row will have this value and it cannot be null"
            },
            {
              "name": "SortBySortKey",
              "description": "Sort the table by the value in DELPHIX_COMPLIANCE_SERVICE_SORT_ID, as we need the table to be in a particular order before we apply a surrogate key"
            },
            {
              "name": "CreateSurrogateKey",
              "description": "Add a DELPHIX_COMPLIANCE_SERVICE_BATCH_ID column that increments by 1 and starts at 1 after applying the sorting"
            },
            {
              "name": "SelectColumnsUnmasked",
              "description": "Select only columns that don't require masking"
            },
            {
              "name": "AggregateColumnsByBatch",
              "description": "For each column we wish to mask, aggregate to a list using collect, grouped by DELPHIX_COMPLIANCE_SERVICE_BATCH_ID with integer division by DF_NUMBER_OF_ROWS_PER_BATCH - so there will be a targeted number of total rows in each aggregation, name the group as DELPHIX_COMPLIANCE_SERVICE_BATCH_GROUP"
            },
            {
              "name": "FlattenValuesOutOfArray",
              "description": "For each column we wish to mask, flatten the value out of the array, in the case where the value was previously [], it becomes null"
            },
            {
              "name": "AssertNoFailures",
              "description": "Confirm that we received a 200 response status from the API request"
            },
            {
              "name": "FlattenAggregateData",
              "description": "Unroll the API response body into decoded named columns"
            },
            {
              "name": "JoinMaskedAndUnmaskedData",
              "description": "Inner join on SelectColumnsUnmasked and TrimMaskedStrings based on matching DELPHIX_COMPLIANCE_SERVICE_BATCH_ID"
            },
            {
              "name": "TrimMaskedStrings",
              "description": "For each column with a string type, trim the string to length based on the value in DF_TRIM_LENGTHS - this is needed as masking a string may produce a longer string that exceeds the column width in the sink"
            },
            {
              "name": "ApplyTableFilter",
              "description": "Filter base table based on supplied filter"
            },
            {
              "name": "CastRequiredColumnsAsStrings",
              "description": "For columns that require casting to string, cast them to string"
            },
            {
              "name": "CastColumnsBackAsRequired",
              "description": "For columns that need to be cast back to a compatible type, cast them back"
            },
            {
              "name": "WrapValuesInArray",
              "description": "For each column we wish to mask, convert the value into an array, this is needed to preserve null values as null when using collect, as null values become [], and encode the column names to handle body type mapping changes"
            }
          ],
          "scriptLines": [
            "parameters{",
            "     runId as string (''),",
            "     DF_SOURCE_SCHEMA as string (''),",
            "     DF_SOURCE_TABLE as string (''),",
            "     DF_SINK_SCHEMA as string (''),",
            "     DF_SINK_TABLE as string (''),",
            "     DF_FIELD_ALGORITHM_ASSIGNMENT as string ('{}'),",
            "     DF_COLUMNS_TO_MASK as string[] ([\"\"]),",
            "     DF_BODY_TYPE_MAPPING as string ('(timestamp as date, status as string, message as string, trace_id as string, items as (DELPHIX_COMPLIANCE_SERVICE_BATCH_ID as long)[])'),",
            "     DF_NUMBER_OF_ROWS_PER_BATCH as integer (1000),",
            "     DF_TRIM_LENGTHS as integer[] ([1000]),",
            "     DF_FAIL_ON_NONCONFORMANT_DATA as boolean (true()),",
            "     DF_FIELD_DATE_FORMAT as string ('{}'),",
            "     DF_FILTER_CONDITION as boolean (true()),",
            "     DF_COLUMNS_TO_CAST_AS_STRINGS as string[] ([\"\"]),",
            "     DF_COLUMNS_TO_CAST_BACK_TO_BINARY as string[] ([\"\"]),",
            "     DF_COLUMNS_TO_CAST_BACK_TO_BOOLEAN as string[] ([\"\"]),",
            "     DF_COLUMNS_TO_CAST_BACK_TO_DATE as string[] ([\"\"]),",
            "     DF_COLUMNS_TO_CAST_BACK_TO_DOUBLE as string[] ([\"\"]),",
            "     DF_COLUMNS_TO_CAST_BACK_TO_FLOAT as string[] ([\"\"]),",
            "     DF_COLUMNS_TO_CAST_BACK_TO_INTEGER as string[] ([\"\"]),",
            "     DF_COLUMNS_TO_CAST_BACK_TO_LONG as string[] ([\"\"]),",
            "     DF_COLUMNS_TO_CAST_BACK_TO_TIMESTAMP as string[] ([\"\"])",
            "}",
            "source(allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'table',",
            "     store: 'sqlserver',",
            "     schemaName: ($DF_SOURCE_SCHEMA),",
            "     tableName: ($DF_SOURCE_TABLE),",
            "     isolationLevel: 'READ_UNCOMMITTED',",
            "     partitionBy('roundRobin', 32)) ~> Source",
            "FlattenValuesOutOfArray call(mapColumn(",
            "          each(match(name!='DELPHIX_COMPLIANCE_SERVICE_BATCH_GROUP'))",
            "     ),",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true,",
            "     output(",
            "          headers as [string,string],",
            "          body as (timestamp as date, status as string, message as string, trace_id as string, items as (DELPHIX_COMPLIANCE_SERVICE_BATCH_ID as long)[]),",
            "          status as string",
            "     ),",
            "     allowSchemaDrift: true,",
            "     format: 'rest',",
            "     store: 'restservice',",
            "     timeout: 30,",
            "     requestInterval: 0,",
            "     headers = ['Run-Id' -> $runId, 'Field-Algorithm-Assignment' -> $DF_FIELD_ALGORITHM_ASSIGNMENT, 'Fail-On-Non-Conformant-Data' -> iif($DF_FAIL_ON_NONCONFORMANT_DATA,'true','false'), 'Field-Date-Format' -> $DF_FIELD_DATE_FORMAT],",
            "     httpMethod: 'POST',",
            "     entity: '/v1/masking/batchMaskByColumn',",
            "     headerColumnName: 'headers',",
            "     bodyColumnName: 'body',",
            "     statusColumnName: 'status',",
            "     addResponseCode: true,",
            "     requestFormat: ['type' -> 'json'],",
            "     responseFormat: ['type' -> 'json', 'documentForm' -> 'documentPerLine'],",
            "     columnTypeMap: ['body'->'$DF_BODY_TYPE_MAPPING']) ~> DCSForAzureAPI",
            "ApplyTableFilter derive(DELPHIX_COMPLIANCE_SERVICE_SORT_ID = sha2(256, columns())) ~> AddSortKey",
            "AddSortKey sort(asc(DELPHIX_COMPLIANCE_SERVICE_SORT_ID, false)) ~> SortBySortKey",
            "SortBySortKey keyGenerate(output(DELPHIX_COMPLIANCE_SERVICE_BATCH_ID as long),",
            "     startAt: 1L,",
            "     stepValue: 1L) ~> CreateSurrogateKey",
            "CreateSurrogateKey select(mapColumn(",
            "          each(match(!contains($DF_COLUMNS_TO_MASK,#item==name)))",
            "     ),",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true) ~> SelectColumnsUnmasked",
            "WrapValuesInArray aggregate(groupBy(DELPHIX_COMPLIANCE_SERVICE_BATCH_GROUP = toInteger(ceil(DELPHIX_COMPLIANCE_SERVICE_BATCH_ID/$DF_NUMBER_OF_ROWS_PER_BATCH))),",
            "     each(match((startsWith(name,'x')&&not(contains($DF_COLUMNS_TO_MASK,#item==name)))||(name==\"DELPHIX_COMPLIANCE_SERVICE_BATCH_ID\")), $$ = collect($$))) ~> AggregateColumnsByBatch",
            "AggregateColumnsByBatch derive(each(match(startsWith(name,'x')||(name==\"DELPHIX_COMPLIANCE_SERVICE_BATCH_ID\")), $$ = flatten($$))) ~> FlattenValuesOutOfArray",
            "DCSForAzureAPI assert(expectTrue(toInteger(regexExtract(status, '(\\\\d+)', 1)) == 200, false, 'Failed_request', null, iif(isNull(body.message), status, concatWS(', ', 'timestamp: ' + toString(body.timestamp), 'status: ' + body.status, 'message: ' + body.message, 'trace_id: ' + body.trace_id))),",
            "     abort: true) ~> AssertNoFailures",
            "AssertNoFailures foldDown(unroll(body.items),",
            "     mapColumn(",
            "          every(body.items,match(name==\"DELPHIX_COMPLIANCE_SERVICE_BATCH_ID\")),",
            "          every(body.items,match(startsWith(name,'x')),",
            "               decode(unhex(replace($$,'x',''))) = $$)",
            "     ),",
            "     skipDuplicateMapInputs: false,",
            "     skipDuplicateMapOutputs: false) ~> FlattenAggregateData",
            "SelectColumnsUnmasked, TrimMaskedStrings join(SelectColumnsUnmasked@DELPHIX_COMPLIANCE_SERVICE_BATCH_ID == FlattenAggregateData@DELPHIX_COMPLIANCE_SERVICE_BATCH_ID,",
            "     joinType:'inner',",
            "     matchType:'exact',",
            "     ignoreSpaces: false,",
            "     broadcast: 'off')~> JoinMaskedAndUnmaskedData",
            "CastColumnsBackAsRequired derive(each(match(type=='string'), $$ = iif(greater($DF_TRIM_LENGTHS[toInteger($# - 1)], 0), substring($$, 1, $DF_TRIM_LENGTHS[toInteger($# - 1)]), toString($$)))) ~> TrimMaskedStrings",
            "Source filter($DF_FILTER_CONDITION) ~> ApplyTableFilter",
            "CreateSurrogateKey derive(each(match(contains($DF_COLUMNS_TO_CAST_AS_STRINGS,#item==name)), $$ = toString($$))) ~> CastRequiredColumnsAsStrings",
            "FlattenAggregateData derive(each(match(contains($DF_COLUMNS_TO_CAST_BACK_TO_BINARY,#item==name)), $$ = toBinary($$)),",
            "          each(match(contains($DF_COLUMNS_TO_CAST_BACK_TO_BOOLEAN,#item==name)), $$ = toBoolean($$)),",
            "          each(match(contains($DF_COLUMNS_TO_CAST_BACK_TO_DATE,#item==name)), $$ = toDate(toString($$))),",
            "          each(match(contains($DF_COLUMNS_TO_CAST_BACK_TO_DOUBLE,#item==name)), $$ = toDouble($$)),",
            "          each(match(contains($DF_COLUMNS_TO_CAST_BACK_TO_FLOAT,#item==name)), $$ = toFloat($$)),",
            "          each(match(contains($DF_COLUMNS_TO_CAST_BACK_TO_INTEGER,#item==name)), $$ = toInteger($$)),",
            "          each(match(contains($DF_COLUMNS_TO_CAST_BACK_TO_LONG,#item==name)), $$ = toLong($$)),",
            "          each(match(contains($DF_COLUMNS_TO_CAST_BACK_TO_TIMESTAMP,#item==name)), $$ = toTimestamp(toString($$)))) ~> CastColumnsBackAsRequired",
            "CastRequiredColumnsAsStrings derive(each(match(contains($DF_COLUMNS_TO_MASK,#item==name)), concat('x',hex(encode($$))) = array($$))) ~> WrapValuesInArray",
            "JoinMaskedAndUnmaskedData sink(allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'table',",
            "     store: 'sqlserver',",
            "     schemaName: ($DF_SINK_SCHEMA),",
            "     tableName: ($DF_SINK_TABLE),",
            "     preSQLs:[(concat(\"IF EXISTS (SELECT 1 FROM sys.columns WHERE object_id = OBJECT_ID('\", $DF_SINK_SCHEMA, \"' + '.' + '\", $DF_SINK_TABLE, \"') AND is_identity = 1) BEGIN \", 'SET IDENTITY_INSERT', ' ', $DF_SINK_SCHEMA, '.', $DF_SINK_TABLE, ' ', 'ON; END'))],",
            "     insertable: true,",
            "     updateable: false,",
            "     deletable: false,",
            "     upsertable: false,",
            "     postSQLs:[(concat(\"IF EXISTS (SELECT 1 FROM sys.columns WHERE object_id = OBJECT_ID('\", $DF_SINK_SCHEMA, \"' + '.' + '\", $DF_SINK_TABLE, \"') AND is_identity = 1) BEGIN \", 'SET IDENTITY_INSERT', ' ', $DF_SINK_SCHEMA, '.', $DF_SINK_TABLE, ' ', 'OFF; END'))],",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true,",
            "     errorHandlingOption: 'stopOnFirstError',",
            "     mapColumn(",
            "          each(match(name!=\"DELPHIX_COMPLIANCE_SERVICE_BATCH_ID\"&&name!=\"DELPHIX_COMPLIANCE_SERVICE_SORT_ID\"))",
            "     ),",
            "     preCommands: [],",
            "     postCommands: []) ~> Sink"
          ]
        }
      },
      "dependsOn": []
    },
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_AzureSQL_to_AzureSQL_mask_source_ds')]",
      "type": "Microsoft.DataFactory/factories/datasets",
      "apiVersion": "2018-06-01",
      "properties": {
        "linkedServiceName": {
          "referenceName": "[parameters('azuresql_mask_source_db')]",
          "type": "LinkedServiceReference",
          "parameters": {
            "LS_DATABASE": {
              "value": "@dataset().DS_SOURCE_DATABASE",
              "type": "Expression"
            }
          }
        },
        "parameters": {
          "DS_SOURCE_SCHEMA": {
            "type": "string"
          },
          "DS_SOURCE_TABLE": {
            "type": "string"
          },
          "DS_SOURCE_DATABASE": {
            "type": "string"
          }
        },
        "folder": {
          "name": "dcsazure_AzureSQL_to_AzureSQL"
        },
        "annotations": [],
        "type": "AzureSqlTable",
        "schema": [],
        "typeProperties": {
          "schema": {
            "value": "@dataset().DS_SOURCE_SCHEMA",
            "type": "Expression"
          },
          "table": {
            "value": "@dataset().DS_SOURCE_TABLE",
            "type": "Expression"
          }
        }
      },
      "dependsOn": []
    },
    {
      "name": "[concat(parameters('factoryName'), '/dcsazure_AzureSQL_to_AzureSQL_copy_df')]",
      "type": "Microsoft.DataFactory/factories/dataflows",
      "apiVersion": "2018-06-01",
      "properties": {
        "folder": {
          "name": "dcsazure_AzureSQL_to_AzureSQL"
        },
        "type": "MappingDataFlow",
        "typeProperties": {
          "sources": [
            {
              "linkedService": {
                "referenceName": "[parameters('azuresql_mask_source_db')]",
                "type": "LinkedServiceReference"
              },
              "name": "SourceData",
              "description": "Select source data at DF_SOURCE_SCHEMA.DF_SOURCE_TABLE using an inline dataset"
            }
          ],
          "sinks": [
            {
              "linkedService": {
                "referenceName": "[parameters('azuresql_mask_sink_db')]",
                "type": "LinkedServiceReference"
              },
              "name": "SinkData",
              "description": "Select sink data at DF_SINK_SCHEMA.DF_SINK_TABLE using an inline dataset"
            }
          ],
          "transformations": [],
          "scriptLines": [
            "parameters{",
            "     runId as string (''),",
            "     DF_SOURCE_SCHEMA as string (''),",
            "     DF_SINK_SCHEMA as string (''),",
            "     DF_SOURCE_TABLE as string (''),",
            "     DF_SINK_TABLE as string ('')",
            "}",
            "source(allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'table',",
            "     store: 'sqlserver',",
            "     schemaName: ($DF_SOURCE_SCHEMA),",
            "     tableName: ($DF_SOURCE_TABLE),",
            "     isolationLevel: 'READ_UNCOMMITTED') ~> SourceData",
            "SourceData sink(allowSchemaDrift: true,",
            "     validateSchema: false,",
            "     format: 'table',",
            "     store: 'sqlserver',",
            "     schemaName: ($DF_SINK_SCHEMA),",
            "     tableName: ($DF_SINK_TABLE),",
            "     preSQLs:[(concat(\"IF EXISTS (SELECT 1 FROM sys.columns WHERE object_id = OBJECT_ID('\", $DF_SINK_SCHEMA, \"' + '.' + '\", $DF_SINK_TABLE, \"') AND is_identity = 1) BEGIN \", 'SET IDENTITY_INSERT', ' ', $DF_SINK_SCHEMA, '.', $DF_SINK_TABLE, ' ', 'ON; END'))],",
            "     insertable: true,",
            "     updateable: false,",
            "     deletable: false,",
            "     upsertable: false,",
            "     postSQLs:[(concat(\"IF EXISTS (SELECT 1 FROM sys.columns WHERE object_id = OBJECT_ID('\", $DF_SINK_SCHEMA, \"' + '.' + '\", $DF_SINK_TABLE, \"') AND is_identity = 1) BEGIN \", 'SET IDENTITY_INSERT', ' ', $DF_SINK_SCHEMA, '.', $DF_SINK_TABLE, ' ', 'OFF; END'))],",
            "     skipDuplicateMapInputs: true,",
            "     skipDuplicateMapOutputs: true,",
            "     errorHandlingOption: 'stopOnFirstError',",
            "     preCommands: [],",
            "     postCommands: []) ~> SinkData"
          ]
        }
      },
      "dependsOn": []
    }
  ]
}
